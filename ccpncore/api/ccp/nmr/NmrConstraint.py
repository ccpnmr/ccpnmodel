"""
#######################################################################

CCPN Data Model version 3.0.2

Autogenerated by PyFileApiGen on Mon Apr 30 12:40:08 2018
  from data model element ccp.nmr.NmrConstraint

#######################################################################
======================COPYRIGHT/LICENSE START==========================

NmrConstraint.py: python API for CCPN data model, MetaPackage ccp.nmr.NmrConstraint

Copyright (C) 2007  (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

A copy of this license can be found in ../../../../../../..//LGPL.license

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
"""

#import sets
import traceback
import types
import operator
import functools
import collections

# special function for fast whitespace checking.
# used in DataType Word and Token handcode
import re
containsWhitespace = re.compile('\s').search
containsNonAlphanumeric = re.compile('[^a-zA-Z0-9_]').search

# Global NaN constant
NaN = float('NaN')

from ccpn.util.Undo import _deleteAllApiObjects, restoreOriginalLinks, no_op
 
from ccpnmodel.ccpncore.memops.ApiError import ApiError

# imported packages:
import ccpnmodel.ccpncore.api.ccp.general.Method
import ccpnmodel.ccpncore.api.ccp.lims.RefSampleComponent
import ccpnmodel.ccpncore.api.ccp.lims.Sample
import ccpnmodel.ccpncore.api.ccp.molecule.ChemElement
import ccpnmodel.ccpncore.api.ccp.molecule.MolStructure
import ccpnmodel.ccpncore.api.ccp.molecule.MolSystem
import ccpnmodel.ccpncore.api.ccp.molecule.Validation
import ccpnmodel.ccpncore.api.ccp.nmr.Nmr
import ccpnmodel.ccpncore.api.memops.Implementation

metaPackage = ccpnmodel.ccpncore.api.memops.Implementation.topPackage.metaObjFromQualName('ccp.nmr.NmrConstraint')

###############################################################################
class AbstractConstraint(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Constraint (of any type)
  """
  #   from data model element ccp.nmr.NmrConstraint.AbstractConstraint
  _metaclass = metaPackage.getElement('AbstractConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'weight', 'constraintGroups', 'contributions', 'method', 'nmrConstraintValidations', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addConstraintGroup(self, value):
    """
    Add for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    if (not isinstance(value, ConstraintGroup)):
      raise ApiError("""%s.addConstraintGroup:
       value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addConstraintGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addConstraintGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addConstraintGroup:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addConstraintGroup:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addConstraintGroup:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('constraints')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addConstraintGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setConstraintGroups, self.addConstraintGroup,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addNmrConstraintValidation(self, value):
    """
    Add for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addNmrConstraintValidation:
       value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addNmrConstraintValidation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addNmrConstraintValidation:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addNmrConstraintValidation:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addNmrConstraintValidation:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.addNmrConstraintValidation:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          ll= value.keywordDefinition.targetNames
          isValid = (not ll or self.qualifiedName in ll)
          if (not (isValid)):
            raise ApiError("""%s.addNmrConstraintValidation:
             nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('nmrConstraints')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addNmrConstraintValidation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNmrConstraintValidations, self.addNmrConstraintValidation,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addPeak(self, value):
    """
    add function for derived link peaks
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addPeak:
       value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getPeaks()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addPeak:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addPeak:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addPeak:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addPeak:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = set(currentValues)
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      ConstraintPeakContrib(self, peak=value)
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addPeak')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPeaks, self.addPeak,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraintGroups(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraintGroups')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraintGroups')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.contributions
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findAllContributions:
     findAllContributions should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def findAllNmrConstraintValidations(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('nmrConstraintValidations')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('nmrConstraintValidations')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'booleanValue', 'ccpnInternalData', 'context', 'details', 'figOfMerit', 'floatValue', 'intValue', 'keyword', 'serial', 'textValue', 'validationStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllPeakContribs(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.peakContribs
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('peakContribs').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('peakContribs').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'dataSourceSerial', 'experimentSerial', 'peakListSerial', 'peakSerial', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllPeaks(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.peaks
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getPeaks()
      result = set(currentValues)

    else:
      currentValues = self.getPeaks()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'annotation', 'ccpnInternalData', 'constraintWeight', 'details', 'figOfMerit', 'height', 'heightError', 'offset', 'serial', 'volume', 'volumeError', 'fitMethod', 'peakList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllViolations(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('violations')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('violations')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'calcValue', 'calcValueError', 'ccpnInternalData', 'fractionViolated', 'violation', 'constraint', 'method', 'violationList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraintGroup(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraintGroups')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('constraintGroups')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.contributions
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findFirstContribution:
     findFirstContribution should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def findFirstNmrConstraintValidation(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('nmrConstraintValidations')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('nmrConstraintValidations')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'booleanValue', 'ccpnInternalData', 'context', 'details', 'figOfMerit', 'floatValue', 'intValue', 'keyword', 'serial', 'textValue', 'validationStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstPeak(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.peaks
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getPeaks()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = self.getPeaks()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'annotation', 'ccpnInternalData', 'constraintWeight', 'details', 'figOfMerit', 'height', 'heightError', 'offset', 'serial', 'volume', 'volumeError', 'fitMethod', 'peakList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstPeakContrib(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.peakContribs
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('peakContribs').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      ll = list()
      objKey = conditions.get('experimentSerial')
      ll.append(objKey)
      if (objKey is not None):
        objKey = conditions.get('dataSourceSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = conditions.get('peakListSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = conditions.get('peakSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = tuple(ll)

      if (objKey is not None):
        result = dataDict.get('peakContribs').get(objKey)

        if (nConditions <= 4):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('peakContribs').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'dataSourceSerial', 'experimentSerial', 'peakListSerial', 'peakSerial', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstViolation(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('violations')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('violations')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'calcValue', 'calcValueError', 'ccpnInternalData', 'fractionViolated', 'violation', 'constraint', 'method', 'violationList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.AbstractConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AbstractConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AbstractConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraintGroups(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraintGroups')
    result = frozenset(tempVar)
    return result
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.contributions
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getContributions:
     getContributions should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.AbstractConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.AbstractConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getMethod(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.method
    """
    dataDict = self.__dict__
    result = dataDict.get('method')
    return result
  
  def getNmrConstraintValidations(self):
    """
    Get for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('nmrConstraintValidations')
    result = frozenset(tempVar)
    return result
  
  def getOrigData(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.origData
    """
    dataDict = self.__dict__
    result = dataDict.get('origData')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.parentList
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getParentList:
     getParentList should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getPeakContribs(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.peakContribs
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('peakContribs').values()
    result = frozenset(tempVar)
    return result
  
  def getPeaks(self):
    """
    getter for derived link peaks
    """
    dataDict = self.__dict__
    result = [x.peak for x in self.peakContribs]
    result = frozenset(x for x in result if x is not None)
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getViolations(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('violations')
    result = frozenset(tempVar)
    return result
  
  def getWeight(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.weight
    """
    dataDict = self.__dict__
    result = dataDict.get('weight')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newConstraintPeakContrib(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    return ConstraintPeakContrib(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeConstraintGroup(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    if (not isinstance(value, ConstraintGroup)):
      raise ApiError("""%s.removeConstraintGroup:
       value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeConstraintGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeConstraintGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeConstraintGroup:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeConstraintGroup:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('constraints')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeConstraintGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setConstraintGroups, self.removeConstraintGroup,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeNmrConstraintValidation(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeNmrConstraintValidation:
       value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeNmrConstraintValidation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeNmrConstraintValidation:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeNmrConstraintValidation:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeNmrConstraintValidation:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('nmrConstraints')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeNmrConstraintValidation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNmrConstraintValidations, self.removeNmrConstraintValidation,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removePeak(self, value):
    """
    remove function for derived link peaks
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removePeak:
       value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getPeaks()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removePeak:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removePeak:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removePeak:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removePeak:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = set(currentValues)
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      obj = self.findFirstPeakContrib(peak=value)
      if obj is not None:
        obj.delete()
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removePeak')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPeaks, self.removePeak,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setConstraintGroups(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setConstraintGroups:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, ConstraintGroup)):
        raise ApiError("""%s.setConstraintGroups:
         value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setConstraintGroups:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraintGroups:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConstraintGroups:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setConstraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('constraints')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('constraints')
        oldSelves.add(self)

    dataDict['constraintGroups'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setConstraintGroups')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setConstraintGroups, self.setConstraintGroups,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setMethod(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.method
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMethod:
         value is not of class ccp.general.Method.Method""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('method')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMethod:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMethod:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setMethod:
         cannot set method, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setMethod:
           Link method between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('constraints')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setMethod:
         Read link 'method' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('constraints')
      newSelves.add(self)

    dataDict['method'] = value

    # doNotifies
  
  def setNmrConstraintValidations(self, values):
    """
    Set for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setNmrConstraintValidations:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setNmrConstraintValidations:
         value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNmrConstraintValidations:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrConstraintValidations:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrConstraintValidations:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.setNmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          ll= value.keywordDefinition.targetNames
          isValid = (not ll or self.qualifiedName in ll)
          if (not (isValid)):
            raise ApiError("""%s.setNmrConstraintValidations:
             nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('nmrConstraints')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('nmrConstraints')
        oldSelves.add(self)

    dataDict['nmrConstraintValidations'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNmrConstraintValidations')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNmrConstraintValidations, self.setNmrConstraintValidations,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setOrigData(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.origData
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setOrigData:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setOrigData:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('origData')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOrigData:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOrigData:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['origData'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOrigData')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrigData, self.setOrigData,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPeaks(self, values):
    """
    setter for derived link peaks
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setPeaks:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setPeaks:
         value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getPeaks()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPeaks:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeaks:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPeaks:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      for xx in self.peakContribs:
        xx.delete()
      for peak in values:
        ConstraintPeakContrib(self, peak=peak)
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPeaks')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPeaks, self.setPeaks,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('parentList')
    oldSerial = parent.__dict__.get('_serialDict').get('constraints')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['constraints'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['constraints'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setViolations(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setViolations:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, Violation)):
        raise ApiError("""%s.setViolations:
         value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('violations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setViolations:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setViolations:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setViolations:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setViolations:
           locard constraint: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setViolations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['constraint'] = self

    dataDict['violations'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setViolations')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setViolations, self.setViolations,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setWeight(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.weight
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setWeight:
       memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (0.0 <= value)):
      raise ApiError("""%s.setWeight:
       NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setWeight:
       NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('weight')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWeight:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWeight:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setWeight:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['weight'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWeight')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWeight, self.setWeight,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraintGroups(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    ll = dataDict.get('constraintGroups')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.contributions
    """
    dataDict = self.__dict__
    raise ApiError("""%s.sortedContributions:
     sortedContributions should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def sortedNmrConstraintValidations(self):
    """
    Sorted for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    ll = dataDict.get('nmrConstraintValidations')
    ll = [(repr(x),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedPeakContribs(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.peakContribs
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('peakContribs')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedPeaks(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.peaks
    """
    dataDict = self.__dict__
    ll = self.getPeaks()
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedViolations(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    ll = dataDict.get('violations')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  origData = property(getOrigData, setOrigData, None,
  r"""Value of original measurement that gave rise to Constraint. E.g. 
  Crosspeak Intensity or Volume (for a distance constraint), Coupling 
  Constant (In Hz) for a dihedral constraint, etc. Provided to cater for 
  structure generation programs that keep this kind of information in 
  their constraint lists.
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  weight = property(getWeight, setWeight, None,
  r"""Relative weight of constraint in constraint list
  """)
  
  constraintGroups = property(getConstraintGroups, setConstraintGroups, None,
  r"""Constraint groups that constraint takes part in
  """)
  
  contributions = property(getContributions,  None, None,
  r"""child link to class ConstraintContribution
  """)
  
  method = property(getMethod, setMethod, None,
  r"""Method used to calculate Constraint. Overrides any Method attached to 
  parent ConstraintList.
  """)
  
  nmrConstraintValidations = property(getNmrConstraintValidations, setNmrConstraintValidations, None,
  r"""Validation results that include AbstractConstraint
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)
  
  peakContribs = property(getPeakContribs,  None, None,
  r"""child link to class ConstraintPeakContrib
  """)
  
  peaks = property(getPeaks, setPeaks, None,
  r"""peaks used in derivation of AbstractConstraint.
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject
  
  violations = property(getViolations, setViolations, None,
  r"""Violation of Constraint in a given structure or set of structures.
  """)

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.AbstractConstraint', AbstractConstraint)

###############################################################################
class AbstractConstraintList(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""List of constraints (of any type).
  """
  #   from data model element ccp.nmr.NmrConstraint.AbstractConstraintList
  _metaclass = metaPackage.getElement('AbstractConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parent', 'root', 'topObject',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addExperiment(self, value):
    """
    add function for derived link experiments
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addExperiment:
       value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getExperiments()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addExperiment:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addExperiment:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addExperiment:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addExperiment:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = set(currentValues)
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.addExperimentSerial(value.serial)
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addExperiment')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setExperiments, self.addExperiment,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addExperimentSerial(self, value):
    """
    Add for ccp.nmr.NmrConstraint.AbstractConstraintList.experimentSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.addExperimentSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('experimentSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addExperimentSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addExperimentSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addExperimentSerial:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addExperimentSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setExperimentSerials, self.addExperimentSerial,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addMeasureListSerial(self, value):
    """
    Add for ccp.nmr.NmrConstraint.AbstractConstraintList.measureListSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.addMeasureListSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('measureListSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addMeasureListSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addMeasureListSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addMeasureListSerial:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addMeasureListSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMeasureListSerials, self.addMeasureListSerial,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addMeasurementList(self, value):
    """
    add function for drived link measurementLists
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addMeasurementList:
       value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getMeasurementLists()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addMeasurementList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addMeasurementList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addMeasurementList:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addMeasurementList:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = set(currentValues)
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.addMeasureListSerial(value.serial)
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addMeasurementList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMeasurementLists, self.addMeasurementList,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addNmrConstraintListValidation(self, value):
    """
    Add for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addNmrConstraintListValidation:
       value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintListValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addNmrConstraintListValidation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addNmrConstraintListValidation:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addNmrConstraintListValidation:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addNmrConstraintListValidation:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.addNmrConstraintListValidation:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          ll= value.keywordDefinition.targetNames
          isValid = (not ll or self.qualifiedName in ll)
          if (not (isValid)):
            raise ApiError("""%s.addNmrConstraintListValidation:
             nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('nmrConstraintLists')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addNmrConstraintListValidation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNmrConstraintListValidations, self.addNmrConstraintListValidation,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraintList.constraints
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findAllConstraints:
     findAllConstraints should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def findAllExperiments(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraintList.experiments
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getExperiments()
      result = set(currentValues)

    else:
      currentValues = self.getExperiments()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'date', 'details', 'experimentType', 'name', 'nmrTubeType', 'numDim', 'numScans', 'refComponentName', 'sampleState', 'sampleVolume', 'serial', 'spinningAngle', 'spinningRate', 'temperature', 'userExpCode', 'volumeUnit', 'derivationMethod', 'dipolarRelaxList', 'hExchProtectionList', 'hExchRateList', 'isotropicS2List', 'jCouplingList', 'nmrProject', 'noeList', 'pkaList', 'probe', 'rawData', 'rdcList', 'sample', 'sampleConditionSet', 'shiftAnisotropyList', 'shiftDifferenceList', 'shiftList', 'spectralDensityList', 'spectrometer', 't1List', 't1RhoList', 't2List',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllMeasurementLists(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.AbstractConstraintList.measurementLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getMeasurementLists()
      result = set(currentValues)

    else:
      currentValues = self.getMeasurementLists()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'isSimulated', 'name', 'serial', 'unit', 'method', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllNmrConstraintListValidations(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('nmrConstraintListValidations')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('nmrConstraintListValidations')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'booleanValue', 'ccpnInternalData', 'context', 'details', 'figOfMerit', 'floatValue', 'intValue', 'keyword', 'serial', 'textValue', 'validationStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraintList.constraints
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findFirstConstraint:
     findFirstConstraint should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def findFirstExperiment(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraintList.experiments
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getExperiments()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = self.getExperiments()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'date', 'details', 'experimentType', 'name', 'nmrTubeType', 'numDim', 'numScans', 'refComponentName', 'sampleState', 'sampleVolume', 'serial', 'spinningAngle', 'spinningRate', 'temperature', 'userExpCode', 'volumeUnit', 'derivationMethod', 'dipolarRelaxList', 'hExchProtectionList', 'hExchRateList', 'isotropicS2List', 'jCouplingList', 'nmrProject', 'noeList', 'pkaList', 'probe', 'rawData', 'rdcList', 'sample', 'sampleConditionSet', 'shiftAnisotropyList', 'shiftDifferenceList', 'shiftList', 'spectralDensityList', 'spectrometer', 't1List', 't1RhoList', 't2List',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstMeasurementList(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.AbstractConstraintList.measurementLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getMeasurementLists()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = self.getMeasurementLists()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'isSimulated', 'name', 'serial', 'unit', 'method', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstNmrConstraintListValidation(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('nmrConstraintListValidations')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('nmrConstraintListValidations')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'booleanValue', 'ccpnInternalData', 'context', 'details', 'figOfMerit', 'floatValue', 'intValue', 'keyword', 'serial', 'textValue', 'validationStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.AbstractConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AbstractConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AbstractConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConditionState(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.conditionState
    """
    dataDict = self.__dict__
    result = dataDict.get('conditionState')
    return result
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.constraints
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getConstraints:
     getConstraints should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey
  
  def getExperimentSerials(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.experimentSerials
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('experimentSerials')
    result = frozenset(tempVar)
    return result
  
  def getExperiments(self):
    """
    getter for derived link experiments
    """
    dataDict = self.__dict__
    func = self.nmrConstraintStore.nmrProject.findFirstExperiment
    aset = set(func(serial=x) for x in self.experimentSerials)
    if None in aset:
      aset.remove(None)
    result = frozenset(aset)
    return result

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.AbstractConstraintList
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.AbstractConstraintList
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getMeasureListSerials(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.measureListSerials
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('measureListSerials')
    result = frozenset(tempVar)
    return result
  
  def getMeasurementLists(self):
    """
    getter for derived link measurementLists
    """
    dataDict = self.__dict__
    func = self.nmrConstraintStore.nmrProject.findFirstMeasurementList
    aset = set(func(serial=x) for x in self.measureListSerials)
    if None in aset:
      aset.remove(None)
    result = frozenset(aset)
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getMethod(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.method
    """
    dataDict = self.__dict__
    result = dataDict.get('method')
    return result
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintListValidations(self):
    """
    Get for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('nmrConstraintListValidations')
    result = frozenset(tempVar)
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result
  
  def getOrigin(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.origin
    """
    dataDict = self.__dict__
    result = dataDict.get('origin')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result
  
  def getPotentialType(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.potentialType
    """
    dataDict = self.__dict__
    result = dataDict.get('potentialType')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnit(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.unit
    """
    dataDict = self.__dict__
    result = dataDict.get('unit')
    return result
  
  def getUsedForCalculation(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.usedForCalculation
    """
    dataDict = self.__dict__
    result = dataDict.get('usedForCalculation')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeExperiment(self, value):
    """
    remove function for derived link experiments
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeExperiment:
       value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getExperiments()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeExperiment:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeExperiment:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeExperiment:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeExperiment:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = set(currentValues)
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.removeExperimentSerial(value.serial)
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeExperiment')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setExperiments, self.removeExperiment,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeExperimentSerial(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraintList.experimentSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeExperimentSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('experimentSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeExperimentSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeExperimentSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeExperimentSerial:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeExperimentSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setExperimentSerials, self.removeExperimentSerial,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeMeasureListSerial(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraintList.measureListSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeMeasureListSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('measureListSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeMeasureListSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeMeasureListSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeMeasureListSerial:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeMeasureListSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMeasureListSerials, self.removeMeasureListSerial,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeMeasurementList(self, value):
    """
    remove function for derived link measurementLists
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeMeasurementList:
       value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getMeasurementLists()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeMeasurementList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeMeasurementList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeMeasurementList:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeMeasurementList:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = set(currentValues)
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.removeMeasureListSerial(value.serial)
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeMeasurementList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMeasurementLists, self.removeMeasurementList,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeNmrConstraintListValidation(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeNmrConstraintListValidation:
       value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintListValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeNmrConstraintListValidation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeNmrConstraintListValidation:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeNmrConstraintListValidation:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeNmrConstraintListValidation:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('nmrConstraintLists')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeNmrConstraintListValidation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNmrConstraintListValidations, self.removeNmrConstraintListValidation,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setConditionState(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.conditionState
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, ConditionState)):
        raise ApiError("""%s.setConditionState:
         value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('conditionState')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setConditionState:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConditionState:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConditionState:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setConditionState:
           Link conditionState between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('constraintLists')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setConditionState:
         Read link 'conditionState' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('constraintLists')
      newSelves.add(self)

    dataDict['conditionState'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setConditionState')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setConditionState, self.setConditionState,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setExperimentSerials(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.experimentSerials
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setExperimentSerials:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setExperimentSerials:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('experimentSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setExperimentSerials:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setExperimentSerials:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['experimentSerials'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setExperimentSerials')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setExperimentSerials, self.setExperimentSerials,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setExperiments(self, values):
    """
    setter for derived link experiments
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setExperiments:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setExperiments:
         value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getExperiments()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setExperiments:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setExperiments:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setExperiments:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.experimentSerials = [x.serial for x in values]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setExperiments')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setExperiments, self.setExperiments,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setMeasureListSerials(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.measureListSerials
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setMeasureListSerials:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setMeasureListSerials:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('measureListSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setMeasureListSerials:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMeasureListSerials:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['measureListSerials'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setMeasureListSerials')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMeasureListSerials, self.setMeasureListSerials,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setMeasurementLists(self, values):
    """
    setter for derived link measurementLists
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setMeasurementLists:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMeasurementLists:
         value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getMeasurementLists()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setMeasurementLists:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMeasurementLists:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMeasurementLists:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.measureListSerials = [x.serial for x in values]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setMeasurementLists')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMeasurementLists, self.setMeasurementLists,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setMethod(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.method
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMethod:
         value is not of class ccp.general.Method.Method""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('method')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMethod:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMethod:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setMethod:
         cannot set method, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setMethod:
           Link method between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('constraintLists')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setMethod:
         Read link 'method' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('constraintLists')
      newSelves.add(self)

    dataDict['method'] = value

    # doNotifies
  
  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setName, self.setName,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setNmrConstraintListValidations(self, values):
    """
    Set for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setNmrConstraintListValidations:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setNmrConstraintListValidations:
         value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintListValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNmrConstraintListValidations:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrConstraintListValidations:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrConstraintListValidations:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.setNmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          ll= value.keywordDefinition.targetNames
          isValid = (not ll or self.qualifiedName in ll)
          if (not (isValid)):
            raise ApiError("""%s.setNmrConstraintListValidations:
             nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('nmrConstraintLists')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('nmrConstraintLists')
        oldSelves.add(self)

    dataDict['nmrConstraintListValidations'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNmrConstraintListValidations')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNmrConstraintListValidations, self.setNmrConstraintListValidations,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setOrigin(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.origin
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setOrigin:
         ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setOrigin:
         ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setOrigin:
         ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setOrigin:
         ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('origin')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOrigin:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOrigin:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['origin'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOrigin')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrigin, self.setOrigin,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPotentialType(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.potentialType
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setPotentialType:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setPotentialType:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setPotentialType:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setPotentialType:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('potentialType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPotentialType:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPotentialType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setPotentialType:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['potentialType'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPotentialType')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPotentialType, self.setPotentialType,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('constraintLists')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['constraintLists'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['constraintLists'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setUnit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.unit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setUnit:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setUnit:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setUnit:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setUnit:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('unit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['unit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnit, self.setUnit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setUsedForCalculation(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.usedForCalculation
    """
    dataDict = self.__dict__
    if (not (value in [True, False])):
      raise ApiError("""%s.setUsedForCalculation:
       memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('usedForCalculation')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUsedForCalculation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUsedForCalculation:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setUsedForCalculation:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['usedForCalculation'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUsedForCalculation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUsedForCalculation, self.setUsedForCalculation,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraintList.constraints
    """
    dataDict = self.__dict__
    raise ApiError("""%s.sortedConstraints:
     sortedConstraints should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def sortedExperiments(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraintList.experiments
    """
    dataDict = self.__dict__
    ll = self.getExperiments()
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedMeasurementLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraintList.measurementLists
    """
    dataDict = self.__dict__
    ll = self.getMeasurementLists()
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedNmrConstraintListValidations(self):
    """
    Sorted for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    ll = dataDict.get('nmrConstraintListValidations')
    ll = [(repr(x),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""free text containing notes, descriptive remarks, etc.
  """)
  
  experimentSerials = property(getExperimentSerials, setExperimentSerials, None,
  r"""Serials for experiments that have contributed to Constraints in 
  constraintList. Serve as key for derived link experiments
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  measureListSerials = property(getMeasureListSerials, setMeasureListSerials, None,
  r"""Serials for measurementLists that have contributed to Constraints in 
  constraintList. Serve as key for derived link measurementLists.
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of constraint list. Serves as a descriptive addition to the serial 
  number.
  """)
  
  origin = property(getOrigin, setOrigin, None,
  r"""Source of data for creating constraint list.
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  potentialType = property(getPotentialType, setPotentialType, None,
  r"""Potential type string (recommended values:
  'log-hamonic', 'parabolic', 
  'square-well-parabolic', 'square-well-parabolic-linear')
  NBNB TBD make 
  into proper data type once NEF format stabilises.
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""The serial number is the key for class AbstractConstraintList and 
  together with the parent object serves as a unique identifier for the 
  AbstractConstraintList.
  Serial numbers are generated by the API. Serial 
  numbers of deleted objects are not reused.
  """)
  
  unit = property(getUnit, setUnit, None,
  r"""Measurement unit of listed constraints. Should be made into an 
  enumeration.
  """)
  
  usedForCalculation = property(getUsedForCalculation, setUsedForCalculation, None,
  r"""Determines if the ConstraintList was (or should be) used for structure 
  calculation.
  """)
  
  conditionState = property(getConditionState, setConditionState, None,
  r"""COndition set that COnstraint list refers to
  """)
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class AbstractConstraint
  """)
  
  experiments = property(getExperiments, setExperiments, None,
  r"""Experiments from which ConstraintLists are derived. May be incomplete or 
  not set.
  """)
  
  measurementLists = property(getMeasurementLists, setMeasurementLists, None,
  r"""Measurement Lists used in deriving Constraint list
  """)
  
  method = property(getMethod, setMethod, None,
  r"""Default Method used for calculating Constraints in ConstraintList. May 
  be overwritten by Method for individual Constraints.
  """)
  
  nmrConstraintListValidations = property(getNmrConstraintListValidations, setNmrConstraintListValidations, None,
  r"""Validation results that include AbstractConstraintList
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.AbstractConstraintList', AbstractConstraintList)

###############################################################################
class CalculationStep(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Calculation steps that the data have passed through to produce the 
current data set. NB this may reflcet not only calsulation but also data 
acquisition.
  """
  #   from data model element ccp.nmr.NmrConstraint.CalculationStep
  _metaclass = metaPackage.getElement('CalculationStep')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'inputDataUuid', 'isDeleted', 'metaclass', 'outputDataUuid', 'packageName', 'packageShortName', 'programName', 'programVersion', 'qualifiedName', 'script', 'scriptName', 'serial', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.CalculationStep
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['inputDataUuid'] = None
      dataDict['outputDataUuid'] = None
      dataDict['programName'] = None
      dataDict['programVersion'] = None
      dataDict['script'] = None
      dataDict['scriptName'] = None
      dataDict['serial'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.CalculationStep', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.CalculationStep.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.CalculationStep')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('calculationSteps')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.CalculationStep:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.CalculationStep:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('calculationSteps')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.CalculationStep:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('calculationSteps')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.CalculationStep
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.CalculationStep
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('calculationSteps')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('inputDataUuid')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: inputDataUuid:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: inputDataUuid:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: inputDataUuid:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: inputDataUuid:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('outputDataUuid')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: outputDataUuid:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: outputDataUuid:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: outputDataUuid:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: outputDataUuid:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('programName')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: programName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: programName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: programName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: programName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('programVersion')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: programVersion:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: programVersion:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: programVersion:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: programVersion:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('script')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: script:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('scriptName')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: scriptName:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: scriptName:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: scriptName:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: scriptName:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('inputDataUuid')
    value = dataDict.get('outputDataUuid')
    value = dataDict.get('programName')
    if (value is None):
      raise ApiError("""%s.checkValid: programName:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('programVersion')
    value = dataDict.get('script')
    value = dataDict.get('scriptName')
    # check roles
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.CalculationStep
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.CalculationStep
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CalculationStep'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CalculationStep'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('calculationSteps').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.CalculationStep
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor
  
  def getInputDataUuid(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.inputDataUuid
    """
    dataDict = self.__dict__
    result = dataDict.get('inputDataUuid')
    return result

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.CalculationStep
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result
  
  def getOutputDataUuid(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.outputDataUuid
    """
    dataDict = self.__dict__
    result = dataDict.get('outputDataUuid')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result
  
  def getProgramName(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.programName
    """
    dataDict = self.__dict__
    result = dataDict.get('programName')
    return result
  
  def getProgramVersion(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.programVersion
    """
    dataDict = self.__dict__
    result = dataDict.get('programVersion')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getScript(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.script
    """
    dataDict = self.__dict__
    result = dataDict.get('script')
    return result
  
  def getScriptName(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.scriptName
    """
    dataDict = self.__dict__
    result = dataDict.get('scriptName')
    return result
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.CalculationStep.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.CalculationStep
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setInputDataUuid(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CalculationStep.inputDataUuid
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setInputDataUuid:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setInputDataUuid:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setInputDataUuid:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setInputDataUuid:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('inputDataUuid')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setInputDataUuid:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setInputDataUuid:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['inputDataUuid'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setInputDataUuid')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setInputDataUuid, self.setInputDataUuid,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setOutputDataUuid(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CalculationStep.outputDataUuid
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setOutputDataUuid:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setOutputDataUuid:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setOutputDataUuid:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setOutputDataUuid:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('outputDataUuid')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOutputDataUuid:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOutputDataUuid:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['outputDataUuid'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOutputDataUuid')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOutputDataUuid, self.setOutputDataUuid,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setProgramName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CalculationStep.programName
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setProgramName:
       memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 80):
      raise ApiError("""%s.setProgramName:
       memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setProgramName:
       memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.splitlines()) <= 1)):
      raise ApiError("""%s.setProgramName:
       Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('programName')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setProgramName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setProgramName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setProgramName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['programName'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setProgramName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setProgramName, self.setProgramName,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setProgramVersion(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CalculationStep.programVersion
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setProgramVersion:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setProgramVersion:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setProgramVersion:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setProgramVersion:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('programVersion')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setProgramVersion:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setProgramVersion:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['programVersion'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setProgramVersion')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setProgramVersion, self.setProgramVersion,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setScript(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CalculationStep.script
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setScript:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('script')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setScript:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setScript:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['script'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setScript')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setScript, self.setScript,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setScriptName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CalculationStep.scriptName
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setScriptName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setScriptName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setScriptName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setScriptName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('scriptName')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setScriptName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setScriptName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['scriptName'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setScriptName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setScriptName, self.setScriptName,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CalculationStep.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('calculationSteps')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['calculationSteps'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['calculationSteps'] = value

    dataDict['serial'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor
  
  inputDataUuid = property(getInputDataUuid, setInputDataUuid, None,
  r"""Globally unique identifier of data set used as input for calculation 
  step. If multiple steps were carried out together, several 
  CalculationSteps can have the same inputDataUuid
  """)

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  outputDataUuid = property(getOutputDataUuid, setOutputDataUuid, None,
  r"""Globally unique identifier of data set produced by calculation step. If 
  multiple steps were carried out together, several CalculationSteps can 
  have the same outputDataUuid
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  programName = property(getProgramName, setProgramName, None,
  r"""Name of program carrying out calculationstep
  """)
  
  programVersion = property(getProgramVersion, setProgramVersion, None,
  r"""Version of program carrying out calculationstep
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  script = property(getScript, setScript, None,
  r"""Full text of program script used for carrying out calculation step.
  """)
  
  scriptName = property(getScriptName, setScriptName, None,
  r"""Name of program script carrying out calculation step
  """)
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.CalculationStep', CalculationStep)

###############################################################################
class ConditionState(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Conditions relevant for ConstraintLists
  """
  #   from data model element ccp.nmr.NmrConstraint.ConditionState
  _metaclass = metaPackage.getElement('ConditionState')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'dynamicAlignment', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'staticAlignment', 'constraintLists', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['dynamicAlignment'] = None
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['staticAlignment'] = None
      dataDict['constraintLists'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ConditionState', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ConditionState.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ConditionState')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('conditionStates')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ConditionState:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ConditionState:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintList in dataDict.get('constraintLists'):
      if (not (constraintList in objsToBeDeleted)):
        constraintList.__dict__['conditionState'] = None

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('conditionStates')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ConditionState:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('conditionStates')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for constraintList in dataDict.get('constraintLists'):
      if (not (constraintList in objsToBeUnDeleted)):
        if (constraintList.__dict__.get('conditionState') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of ConditionState object constraintLists link - backLink AbstractConstraintList.conditionState is not None""" % self.qualifiedName
          )

        constraintList.__dict__['conditionState'] = self

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addConstraintList(self, value):
    """
    Add for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraintList)):
      raise ApiError("""%s.addConstraintList:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.conditionState}

    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addConstraintList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addConstraintList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addConstraintList:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addConstraintList:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addConstraintList:
           Link constraintLists between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('conditionState')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('constraintLists')
      siblingValues.remove(value)

    value.__dict__['conditionState'] = self
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addConstraintList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addConstraintList, undoArgs=(undoValueDict, 'conditionState'),  redoArgs=(value,))

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('conditionStates')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('dynamicAlignment')
      if (value is not None):
        from ccpnmodel.ccpncore.api.memops.Implementation import SymmTracelessMatrix as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: dynamicAlignment:
           value is not of class memops.Implementation.SymmTracelessMatrix""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('staticAlignment')
      if (value is not None):
        from ccpnmodel.ccpncore.api.memops.Implementation import SymmTracelessMatrix as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: staticAlignment:
           value is not of class memops.Implementation.SymmTracelessMatrix""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      values = dataDict.get('constraintLists')
      for value in values:
        if (not isinstance(value, AbstractConstraintList)):
          raise ApiError("""%s.checkValid: constraintLists:
           value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('conditionState')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraintLists:
           non-reciprocal link constraintLists from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintLists:
           Link constraintLists between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('dynamicAlignment')
    if (value is not None):
      value.checkAllValid(complete)

    value = dataDict.get('name')
    value = dataDict.get('staticAlignment')
    if (value is not None):
      value.checkAllValid(complete)

    # check roles
    values = dataDict.get('constraintLists')
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraintLists(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraintLists')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraintLists')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'origin', 'potentialType', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'method', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraintList(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraintLists')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('constraintLists')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'origin', 'potentialType', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'method', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ConditionState
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConditionState'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConditionState'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('conditionStates').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraintLists(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraintLists')
    result = frozenset(tempVar)
    return result
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result
  
  def getDynamicAlignment(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.dynamicAlignment
    """
    dataDict = self.__dict__
    result = dataDict.get('dynamicAlignment')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getStaticAlignment(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.staticAlignment
    """
    dataDict = self.__dict__
    result = dataDict.get('staticAlignment')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeConstraintList(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraintList)):
      raise ApiError("""%s.removeConstraintList:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeConstraintList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeConstraintList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeConstraintList:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeConstraintList:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['conditionState'] = None
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeConstraintList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setConstraintLists, self.removeConstraintList,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setConstraintLists(self, values):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setConstraintLists:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, AbstractConstraintList)):
        raise ApiError("""%s.setConstraintLists:
         value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.conditionState) for y in (currentValues, values) for x in y)

    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setConstraintLists:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraintLists:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConstraintLists:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setConstraintLists:
           Link constraintLists between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['conditionState'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('conditionState')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('constraintLists')
          vv.remove(cv)

      cv.__dict__['conditionState'] = self

    dataDict['constraintLists'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setConstraintLists')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setConstraintLists, undoArgs=(undoValueDict, 'conditionState'),  redoArgs=(values,))

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setDynamicAlignment(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.dynamicAlignment
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.memops.Implementation import SymmTracelessMatrix as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setDynamicAlignment:
         value is not of class memops.Implementation.SymmTracelessMatrix""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('dynamicAlignment')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDynamicAlignment:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDynamicAlignment:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['dynamicAlignment'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDynamicAlignment')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDynamicAlignment, self.setDynamicAlignment,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setName, self.setName,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('conditionStates')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['conditionStates'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['conditionStates'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setStaticAlignment(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.staticAlignment
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.memops.Implementation import SymmTracelessMatrix as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setStaticAlignment:
         value is not of class memops.Implementation.SymmTracelessMatrix""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('staticAlignment')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStaticAlignment:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStaticAlignment:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['staticAlignment'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStaticAlignment')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setStaticAlignment, self.setStaticAlignment,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraintLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    ll = dataDict.get('constraintLists')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)
  
  dynamicAlignment = property(getDynamicAlignment, setDynamicAlignment, None,
  r"""dynamic alignment tensor
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of ConditionSet
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  staticAlignment = property(getStaticAlignment, setStaticAlignment, None,
  r"""Static alignment tensor
  """)
  
  constraintLists = property(getConstraintLists, setConstraintLists, None,
  r"""Constraint lists relevant to condition set
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ConditionState', ConditionState)

###############################################################################
class ConstraintContribution(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Contribution to Constraint, with targe value, upper and lower limits, 
and combination logic. Abstract class.
  """
  #   from data model element ccp.nmr.NmrConstraint.ConstraintContribution
  _metaclass = metaPackage.getElement('ConstraintContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'root', 'topObject',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ConstraintContribution.items
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findAllItems:
     findAllItems should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ConstraintContribution.items
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findFirstItem:
     findFirstItem should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def findUnorderedItem(self, resonances):
    """
    Find ConstraintItem by resonances, checking both given and reversed
    order.
    """
    dataDict = self.__dict__
    if len(resonances) == 1:
      result = self.findFirstItem(resonance=resonances[1])
    else:
      result = self.findFirstItem(resonances=resonances)
      if result is None:
        result = self.findFirstItem(resonances=reversed(resonances))
    return result
  
  def getAdditionalLowerLimit(self):
    """
    Get for
    ccp.nmr.NmrConstraint.ConstraintContribution.additionalLowerLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('additionalLowerLimit')
    return result
  
  def getAdditionalUpperLimit(self):
    """
    Get for
    ccp.nmr.NmrConstraint.ConstraintContribution.additionalUpperLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('additionalUpperLimit')
    return result

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ConstraintContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getCombinationId(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.combinationId
    """
    dataDict = self.__dict__
    result = dataDict.get('combinationId')
    return result
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.constraint
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getConstraint:
     getConstraint should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getError(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.error
    """
    dataDict = self.__dict__
    result = dataDict.get('error')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ConstraintContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.items
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getItems:
     getItems should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ConstraintContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getLowerLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.lowerLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('lowerLimit')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getTargetValue(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.targetValue
    """
    dataDict = self.__dict__
    result = dataDict.get('targetValue')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUpperLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.upperLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('upperLimit')
    return result
  
  def getWeight(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintContribution.weight
    """
    dataDict = self.__dict__
    result = dataDict.get('weight')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def setAdditionalLowerLimit(self, value):
    """
    Set for
    ccp.nmr.NmrConstraint.ConstraintContribution.additionalLowerLimit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setAdditionalLowerLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setAdditionalLowerLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('additionalLowerLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAdditionalLowerLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAdditionalLowerLimit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['additionalLowerLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAdditionalLowerLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAdditionalLowerLimit, self.setAdditionalLowerLimit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setAdditionalUpperLimit(self, value):
    """
    Set for
    ccp.nmr.NmrConstraint.ConstraintContribution.additionalUpperLimit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setAdditionalUpperLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setAdditionalUpperLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('additionalUpperLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAdditionalUpperLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAdditionalUpperLimit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['additionalUpperLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAdditionalUpperLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAdditionalUpperLimit, self.setAdditionalUpperLimit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setCombinationId(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintContribution.combinationId
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setCombinationId:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('combinationId')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCombinationId:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCombinationId:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['combinationId'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCombinationId')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCombinationId, self.setCombinationId,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setError(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintContribution.error
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setError:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setError:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('error')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setError:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setError:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['error'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setError')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setError, self.setError,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setLowerLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintContribution.lowerLimit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setLowerLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setLowerLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('lowerLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setLowerLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setLowerLimit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['lowerLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setLowerLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setLowerLimit, self.setLowerLimit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintContribution.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('constraint')
    oldSerial = parent.__dict__.get('_serialDict').get('contributions')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['contributions'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['contributions'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setTargetValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintContribution.targetValue
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setTargetValue:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setTargetValue:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('targetValue')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTargetValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTargetValue:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['targetValue'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTargetValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTargetValue, self.setTargetValue,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setUpperLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintContribution.upperLimit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setUpperLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setUpperLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('upperLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUpperLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUpperLimit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['upperLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUpperLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUpperLimit, self.setUpperLimit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setWeight(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintContribution.weight
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setWeight:
       memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (0.0 <= value)):
      raise ApiError("""%s.setWeight:
       NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setWeight:
       NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('weight')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWeight:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWeight:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setWeight:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['weight'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWeight')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWeight, self.setWeight,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ConstraintContribution.items
    """
    dataDict = self.__dict__
    raise ApiError("""%s.sortedItems:
     sortedItems should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID
  
  additionalLowerLimit = property(getAdditionalLowerLimit, setAdditionalLowerLimit, None,
  r"""Second lower limit cutoff, for potentials that use two-part contraint 
  functions (e.g. quadratic-linear). Should be smaller than lowerLimit
  """)
  
  additionalUpperLimit = property(getAdditionalUpperLimit, setAdditionalUpperLimit, None,
  r"""Second Upper limit cutoff, for potentials that use two-part contraint 
  functions (e.g. quadratic-linear). Should be larger than upperLimit
  """)

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  combinationId = property(getCombinationId, setCombinationId, None,
  r"""Cmbination contribution ID. If hte attribute is set, all contributions 
  with the same ID within the same CONstraint are combined using the AND 
  operator. different AND gorups and contributions without a combinationId 
  are combined using OR.
  """)
  
  error = property(getError, setError, None,
  r"""Error (estimated statndard deviation) in targetValue.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  lowerLimit = property(getLowerLimit, setLowerLimit, None,
  r"""
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  targetValue = property(getTargetValue, setTargetValue, None,
  r"""Target valule for constraint
  """)
  
  upperLimit = property(getUpperLimit, setUpperLimit, None,
  r"""Upper limit of constraint
  """)
  
  weight = property(getWeight, setWeight, None,
  r"""Relative weight of constraint in constraint list
  """)
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class ConstraintItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ConstraintContribution', ConstraintContribution)

###############################################################################
class ConstraintGroup(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Group of constraints, for organisation, annotation, etc. purposes.
  """
  #   from data model element ccp.nmr.NmrConstraint.ConstraintGroup
  _metaclass = metaPackage.getElement('ConstraintGroup')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'constraints', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['serial'] = None
      dataDict['constraints'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ConstraintGroup', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ConstraintGroup.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ConstraintGroup')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintGroups')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ConstraintGroup:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ConstraintGroup:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraint in dataDict.get('constraints'):
      if (not (constraint in objsToBeDeleted)):
        constraintGroups = constraint.__dict__.get('constraintGroups')
        constraintGroups.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintGroups')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ConstraintGroup:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintGroups')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for constraint in dataDict.get('constraints'):
      if (not (constraint in objsToBeUnDeleted)):
        constraintGroups = constraint.__dict__.get('constraintGroups')
        constraintGroups.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addConstraint(self, value):
    """
    Add for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraint)):
      raise ApiError("""%s.addConstraint:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addConstraint:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addConstraint:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addConstraint:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addConstraint:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addConstraint:
           Link constraints between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('constraintGroups')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addConstraint')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setConstraints, self.addConstraint,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintGroups')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraints')
      for value in values:
        if (not isinstance(value, AbstractConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintGroups')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    # check roles
    values = dataDict.get('constraints')
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'origData', 'serial', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('constraints')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'origData', 'serial', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ConstraintGroup
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintGroup'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintGroup'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintGroups').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints')
    result = frozenset(tempVar)
    return result
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeConstraint(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraint)):
      raise ApiError("""%s.removeConstraint:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeConstraint:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeConstraint:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeConstraint:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeConstraint:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('constraintGroups')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeConstraint')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setConstraints, self.removeConstraint,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setConstraints(self, values):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setConstraints:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, AbstractConstraint)):
        raise ApiError("""%s.setConstraints:
         value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setConstraints:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraints:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConstraints:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setConstraints:
           Link constraints between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('constraintGroups')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('constraintGroups')
        oldSelves.add(self)

    dataDict['constraints'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setConstraints')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setConstraints, self.setConstraints,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintGroup.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintGroup.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('constraintGroups')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['constraintGroups'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['constraintGroups'] = value

    dataDict['serial'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    ll = dataDict.get('constraints')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  constraints = property(getConstraints, setConstraints, None,
  r"""Constraints included in constraintGroup
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ConstraintGroup', ConstraintGroup)

###############################################################################
class ConstraintItem(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""
  """
  #   from data model element ccp.nmr.NmrConstraint.ConstraintItem
  _metaclass = metaPackage.getElement('ConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'root', 'topObject',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintItem.contribution
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getContribution:
     getContribution should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ConstraintItem', ConstraintItem)

###############################################################################
class ConstraintListParameter(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""General-purpose keyword-value parameter for constraintLists, 
corresponding to the Parameters of the Data class
  """
  #   from data model element ccp.nmr.NmrConstraint.ConstraintListParameter
  _metaclass = metaPackage.getElement('ConstraintListParameter')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'value', 'genericConstraintList', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ConstraintListParameter
    """
    dataDict = self.__dict__
    dataDict['genericConstraintList'] = parent
    if (not isinstance(parent, GenericConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.GenericConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['name'] = None
      dataDict['value'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ConstraintListParameter', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ConstraintListParameter.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('parameters')
        objKey = dataDict.get('name')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['name'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ConstraintListParameter:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ConstraintListParameter:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    genericConstraintList = dataDict.get('genericConstraintList')
    if (not (genericConstraintList in objsToBeDeleted)):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = genericConstraintList.__dict__.get('parameters')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ConstraintListParameter:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    genericConstraintList = dataDict.get('genericConstraintList')
    if (not (genericConstraintList in objsToBeUnDeleted)):

      childrenDict = genericConstraintList.__dict__.get('parameters')
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['name'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ConstraintListParameter
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ConstraintListParameter
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('genericConstraintList')
        dd = value.__dict__.get('parameters')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'genericConstraintList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: name:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('value')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: value:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      value = dataDict.get('genericConstraintList')
      if (not isinstance(value, GenericConstraintList)):
        raise ApiError("""%s.checkValid: genericConstraintList:
         value is not of class ccp.nmr.NmrConstraint.GenericConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('name')
    if (value is None):
      raise ApiError("""%s.checkValid: name:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('value')
    # check roles
    value = dataDict.get('genericConstraintList')
    if (value is None):
      raise ApiError("""%s.checkValid: genericConstraintList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ConstraintListParameter
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ConstraintListParameter
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintListParameter'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintListParameter'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('parameters').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ConstraintListParameter
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('genericConstraintList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('name'))

    return result
  
  def getGenericConstraintList(self):
    """
    Get for
    ccp.nmr.NmrConstraint.ConstraintListParameter.genericConstraintList
    """
    dataDict = self.__dict__
    result = dataDict.get('genericConstraintList')
    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ConstraintListParameter
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintListParameter.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintListParameter.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('genericConstraintList')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getValue(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintListParameter.value
    """
    dataDict = self.__dict__
    result = dataDict.get('value')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ConstraintListParameter
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintListParameter.name
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setName:
       memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 80):
      raise ApiError("""%s.setName:
       memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setName:
       memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.splitlines()) <= 1)):
      raise ApiError("""%s.setName:
       Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setName:
         cannot set name, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['name'] = value

    # doNotifies
  
  def setValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintListParameter.value
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
        pass
      else:
        raise ApiError("""%s.setValue:
         memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('value')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setValue:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['value'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setValue, self.setValue,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of parameter - key for object.
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  value = property(getValue, setValue, None,
  r"""Parameter value - can be of any of the several types supported by the 
  Multiple data type
  """)
  
  genericConstraintList = property(getGenericConstraintList,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for genericConstraintList
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ConstraintListParameter', ConstraintListParameter)

###############################################################################
class ConstraintPeakContrib(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Connecting class, connecting AbstractConstraint to AbstractPeak. 
Necessary to avoid direct link between the classes, which would be 
inappropriate whenever peaks were deleted.
  """
  #   from data model element ccp.nmr.NmrConstraint.ConstraintPeakContrib
  _metaclass = metaPackage.getElement('ConstraintPeakContrib')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'dataSourceSerial', 'experimentSerial', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'peakListSerial', 'peakSerial', 'qualifiedName', 'constraint', 'parent', 'peak', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, AbstractConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['dataSourceSerial'] = None
      dataDict['experimentSerial'] = None
      dataDict['peakListSerial'] = None
      dataDict['peakSerial'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ConstraintPeakContrib', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ConstraintPeakContrib.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('peakContribs')
        ll = list()
        objKey = dataDict.get('experimentSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('dataSourceSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = dataDict.get('peakListSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = dataDict.get('peakSerial')
              ll.append(objKey)
              if (objKey is not None):
                objKey = tuple(ll)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['experimentSerial', 'dataSourceSerial', 'peakListSerial', 'peakSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ConstraintPeakContrib:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ConstraintPeakContrib:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      ll = list()
      objKey = dataDict.get('experimentSerial')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('dataSourceSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('peakListSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = dataDict.get('peakSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('peakContribs')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ConstraintPeakContrib:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('peakContribs')
      ll = list()
      objKey = dataDict.get('experimentSerial')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('dataSourceSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('peakListSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = dataDict.get('peakSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['experimentSerial', 'dataSourceSerial', 'peakListSerial', 'peakSerial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      ll = list()
      objKey = dataDict.get('experimentSerial')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('dataSourceSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('peakListSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = dataDict.get('peakSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('peakContribs')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('dataSourceSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: dataSourceSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('experimentSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: experimentSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('peakListSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: peakListSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('peakSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: peakSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, AbstractConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getPeak()
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peak:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peak:
           Link peak between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('dataSourceSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: dataSourceSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('experimentSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: experimentSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('peakListSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: peakListSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('peakSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: peakSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (7 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintPeakContrib'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (6 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintPeakContrib'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-6]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-5]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          ll = list()
          objKey = fullKey[-4]
          ll.append(objKey)
          if (objKey is not None):
            objKey = fullKey[-3]
            ll.append(objKey)
            if (objKey is not None):
              objKey = fullKey[-2]
              ll.append(objKey)
              if (objKey is not None):
                objKey = fullKey[-1]
                ll.append(objKey)
                if (objKey is not None):
                  objKey = tuple(ll)

          obj4 = obj3.__dict__.get('peakContribs').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result
  
  def getDataSourceSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.dataSourceSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('dataSourceSerial')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey
  
  def getExperimentSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.experimentSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('experimentSerial')
    return result

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('experimentSerial'))
    result.append(dataDict.get('dataSourceSerial'))
    result.append(dataDict.get('peakListSerial'))
    result.append(dataDict.get('peakSerial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    ll = list()
    result = dataDict.get('experimentSerial')
    ll.append(result)
    if (result is not None):
      result = dataDict.get('dataSourceSerial')
      ll.append(result)
      if (result is not None):
        result = dataDict.get('peakListSerial')
        ll.append(result)
        if (result is not None):
          result = dataDict.get('peakSerial')
          ll.append(result)
          if (result is not None):
            result = tuple(ll)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result
  
  def getPeak(self):
    """
    getter for derived link peak
    """
    dataDict = self.__dict__
    result = self.getByNavigation('constraint', 'parentList', 'nmrConstraintStore', 'nmrProject', ('experiments',self.experimentSerial), ('dataSources',self.dataSourceSerial), ('peakLists',self.peakListSerial), ('peaks',self.peakSerial),)
    return result
  
  def getPeakListSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.peakListSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('peakListSerial')
    return result
  
  def getPeakSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.peakSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('peakSerial')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setDataSourceSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintPeakContrib.dataSourceSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setDataSourceSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('dataSourceSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDataSourceSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setDataSourceSerial:
         cannot set dataSourceSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setDataSourceSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['dataSourceSerial'] = value

    # doNotifies
  
  def setExperimentSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintPeakContrib.experimentSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setExperimentSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('experimentSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setExperimentSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setExperimentSerial:
         cannot set experimentSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setExperimentSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['experimentSerial'] = value

    # doNotifies
  
  def setPeak(self, value):
    """
    setter for derived link peak
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setPeak:
         value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = self.getPeak()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPeak:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeak:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPeak:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.peakSerial = value.serial
      pl = value.peakList
      self.peakListSerial = pl.serial
      ds = pl.dataSource
      self.dataSourceSerial = ds.serial
      self.experimentSerial = ds.experiment.serial
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPeak')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPeak, self.setPeak,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPeakListSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintPeakContrib.peakListSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setPeakListSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peakListSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakListSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeakListSerial:
         cannot set peakListSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPeakListSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['peakListSerial'] = value

    # doNotifies
  
  def setPeakSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintPeakContrib.peakSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setPeakSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peakSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeakSerial:
         cannot set peakSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPeakSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['peakSerial'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  dataSourceSerial = property(getDataSourceSerial, setDataSourceSerial, None,
  r"""Serial number for DataSource containing peak
  """)
  
  experimentSerial = property(getExperimentSerial, setExperimentSerial, None,
  r"""Serial number for Experiment containing peak
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  peakListSerial = property(getPeakListSerial, setPeakListSerial, None,
  r"""Serial number for peakList containing peak
  """)
  
  peakSerial = property(getPeakSerial, setPeakSerial, None,
  r"""Serial number for Peak
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)
  
  peak = property(getPeak, setPeak, None,
  r"""peak connected to by ConstraintPeakContrib.
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ConstraintPeakContrib', ConstraintPeakContrib)

###############################################################################
class Data(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""
  """
  #   from data model element ccp.nmr.NmrConstraint.Data
  _metaclass = metaPackage.getElement('Data')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'attachedObjectPid', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'nmrConstraintStore', 'parameters', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.Data
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['attachedObjectPid'] = None
      dataDict['ccpnInternalData'] = None
      dataDict['name'] = None
      dataDict['parameters'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.Data', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.Data.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('data')
        objKey = dataDict.get('name')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['name'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.Data:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    parameters = dataDict.get('parameters').values()
    for parameter in parameters:
      if (not (parameter in objsToBeDeleted)):
        objsToBeDeleted.add(parameter)
        objsToBeChecked.append(parameter)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.Data:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('data')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.Data:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('data')
    objKey = dataDict.get('name')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['name'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.Data
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('parameters').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.Data
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('data')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('attachedObjectPid')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: attachedObjectPid:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: attachedObjectPid:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: attachedObjectPid:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: attachedObjectPid:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: name:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('parameters').values()
      for value in values:
        if (not isinstance(value, Parameter)):
          raise ApiError("""%s.checkValid: parameters:
           value is not of class ccp.nmr.NmrConstraint.Parameter""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('data')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: parameters:
           non-reciprocal link parameters from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('attachedObjectPid')
    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('name')
    if (value is None):
      raise ApiError("""%s.checkValid: name:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('parameters').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllParameters(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.Data.parameters
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('parameters').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('parameters').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'value', 'data',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstParameter(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.Data.parameters
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('parameters').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('name')
      if (objKey is not None):
        result = dataDict.get('parameters').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('parameters').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'value', 'data',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.Data
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAttachedObjectPid(self):
    """
    Get for ccp.nmr.NmrConstraint.Data.attachedObjectPid
    """
    dataDict = self.__dict__
    result = dataDict.get('attachedObjectPid')
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.Data
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.Data'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.Data'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('data').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.Data
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('name'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.Data
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.Data.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.Data.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParameters(self):
    """
    Get for ccp.nmr.NmrConstraint.Data.parameters
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('parameters').values()
    result = frozenset(tempVar)
    return result
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.Data.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newParameter(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.Parameter
    """
    return Parameter(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.Data
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAttachedObjectPid(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Data.attachedObjectPid
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setAttachedObjectPid:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setAttachedObjectPid:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setAttachedObjectPid:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setAttachedObjectPid:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('attachedObjectPid')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAttachedObjectPid:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAttachedObjectPid:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['attachedObjectPid'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAttachedObjectPid')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAttachedObjectPid, self.setAttachedObjectPid,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Data.name
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setName:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setName:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setName:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setName:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setName:
         cannot set name, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['name'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedParameters(self):
    """
    Sorted for ccp.nmr.NmrConstraint.Data.parameters
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('parameters')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData
  
  attachedObjectPid = property(getAttachedObjectPid, setAttachedObjectPid, None,
  r"""Identifying string (V3 pid) for CCPN wrapper object matching Data. If 
  Pid matches a top-level existing object, the content of the object will 
  be written out, otherwise the pid will simply be reproduced.
  """)

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of data - key idenrtifier.
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parameters = property(getParameters,  None, None,
  r"""child link to class Parameter
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.Data', Data)

###############################################################################
class DihedralConstraintItem(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Range of dihedral angle values allowed for a Dihedral angle constraint. 
One of possibly several ranges allowed for a given (unambiguously 
assigned) constraint.
  """
  #   from data model element ccp.nmr.NmrConstraint.DihedralConstraintItem
  _metaclass = metaPackage.getElement('DihedralConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'constraint', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, DihedralConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DihedralConstraintItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DihedralConstraintItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DihedralConstraintItem')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DihedralConstraintItem:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DihedralConstraintItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DihedralConstraintItem:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('items')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: lowerLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: lowerLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: upperLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: upperLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, DihedralConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    if (value is None):
      raise ApiError("""%s.checkValid: lowerLimit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    if (value is None):
      raise ApiError("""%s.checkValid: upperLimit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result
  
  def getError(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.error
    """
    dataDict = self.__dict__
    result = dataDict.get('error')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getLowerLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.lowerLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('lowerLimit')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getTargetValue(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.targetValue
    """
    dataDict = self.__dict__
    result = dataDict.get('targetValue')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUpperLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.upperLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('upperLimit')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setError(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.error
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setError:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setError:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('error')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setError:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setError:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['error'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setError')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setError, self.setError,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setLowerLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.lowerLimit
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setLowerLimit:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setLowerLimit:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('lowerLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setLowerLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setLowerLimit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setLowerLimit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['lowerLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setLowerLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setLowerLimit, self.setLowerLimit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('constraint')
    oldSerial = parent.__dict__.get('_serialDict').get('items')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['items'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['items'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setTargetValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.targetValue
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setTargetValue:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setTargetValue:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('targetValue')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTargetValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTargetValue:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['targetValue'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTargetValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTargetValue, self.setTargetValue,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setUpperLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.upperLimit
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setUpperLimit:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setUpperLimit:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('upperLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUpperLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUpperLimit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setUpperLimit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['upperLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUpperLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUpperLimit, self.setUpperLimit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  error = property(getError, setError, None,
  r"""Uncertainty (estimated standard devaition) of targetValue
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  lowerLimit = property(getLowerLimit, setLowerLimit, None,
  r"""Lower Angle Limit (in degrees). Energy penalty is zero between 
  upperLimit and lowerLimit.
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""The serial number is the key for class DihedralConstraintItem and 
  together with the parent object serves as a unique identifier for the 
  DihedralConstraintItem.
  Serial numbers are generated by the API. Serial 
  numbers of deleted objects are not reused.
  """)
  
  targetValue = property(getTargetValue, setTargetValue, None,
  r"""Desired value of constrained parameter
  """)
  
  upperLimit = property(getUpperLimit, setUpperLimit, None,
  r"""Upper angle limit (in degrees). Energy penalty is zero between 
  upperLimit and lowerLimit.
  """)
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DihedralConstraintItem', DihedralConstraintItem)

###############################################################################
class FixedAtomSet(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Fixed version of AtomSet. When a Structure Generation run is started, 
AtomSets and ResonanceSets are copied to FixedAtomSets and 
FixedResonanceSets in order to preserve the Resonance-Atom assignment 
valid for a StructureGeneration and the associated ConstraintLists.
  """
  #   from data model element ccp.nmr.NmrConstraint.FixedAtomSet
  _metaclass = metaPackage.getElement('FixedAtomSet')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'atoms', 'nmrConstraintStore', 'parent', 'resonanceSets', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['atoms'] = set()
      dataDict['resonanceSets'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.FixedAtomSet', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.FixedAtomSet.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.FixedAtomSet')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('fixedAtomSets')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.FixedAtomSet:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    atoms = dataDict.get('atoms')
    pass
    for atom in atoms:
      topObject = atom.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    resonanceSets = dataDict.get('resonanceSets')
    for resonanceSet in resonanceSets:
      if (not (resonanceSet in objsToBeDeleted)):
        backlink = resonanceSet.__dict__.get('atomSets')
        key = (resonanceSet, 'atomSets')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 1):
          objsToBeDeleted.add(resonanceSet)
          objsToBeChecked.append(resonanceSet)
        else:
          linkCounter[key] = nFound

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.FixedAtomSet:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for atom in dataDict.get('atoms'):
      if (not (atom in objsToBeDeleted)):
        fixedAtomSets = atom.__dict__.get('fixedAtomSets')
        fixedAtomSets.remove(self)

    for resonanceSet in dataDict.get('resonanceSets'):
      if (not (resonanceSet in objsToBeDeleted)):
        atomSets = resonanceSet.__dict__.get('atomSets')
        atomSets.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('fixedAtomSets')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.FixedAtomSet:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('fixedAtomSets')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for atom in dataDict.get('atoms'):
      if (not (atom in objsToBeUnDeleted)):
        fixedAtomSets = atom.__dict__.get('fixedAtomSets')
        fixedAtomSets.add(self)

    for resonanceSet in dataDict.get('resonanceSets'):
      if (not (resonanceSet in objsToBeUnDeleted)):
        atomSets = resonanceSet.__dict__.get('atomSets')
        atomSets.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addAtom(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Atom as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addAtom:
       value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atoms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAtom:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAtom:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addAtom:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addAtom:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addAtom:
           Link atoms between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('fixedAtomSets')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAtom')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAtoms, self.addAtom,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addResonanceSet(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonanceSet)):
      raise ApiError("""%s.addResonanceSet:
       value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addResonanceSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addResonanceSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addResonanceSet:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addResonanceSet:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addResonanceSet:
           Link resonanceSets between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('atomSets')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addResonanceSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceSets, self.addResonanceSet,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('fixedAtomSets')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: name:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('atoms')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Atom as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: atoms:
           value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('fixedAtomSets')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: atoms:
           non-reciprocal link atoms from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: atoms:
           Link atoms between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonanceSets')
      for value in values:
        if (not isinstance(value, FixedResonanceSet)):
          raise ApiError("""%s.checkValid: resonanceSets:
           value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('atomSets')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonanceSets:
           non-reciprocal link resonanceSets from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('name')
    # check roles
    values = dataDict.get('atoms')
    if (len(values) < 1):
      raise ApiError("""%s.checkValid: atoms:
       locard: values must be of length >= 1""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonanceSets')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllAtoms(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atoms')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('atoms')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'atomSetName', 'atomType', 'ccpnInternalData', 'elementSymbol', 'name', 'atomSet', 'residue',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllResonanceSets(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonanceSets')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonanceSets')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAtom(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atoms')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('atoms')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'atomSetName', 'atomType', 'ccpnInternalData', 'elementSymbol', 'name', 'atomSet', 'residue',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstResonanceSet(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonanceSets')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonanceSets')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAtoms(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('atoms')
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.FixedAtomSet
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedAtomSet'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedAtomSet'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('fixedAtomSets').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonanceSets(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonanceSets')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeAtom(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Atom as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeAtom:
       value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atoms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAtom:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAtom:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeAtom:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAtom:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (1 + 1)):
        raise ApiError("""%s.removeAtom:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('fixedAtomSets')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAtom')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAtoms, self.removeAtom,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeResonanceSet(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonanceSet)):
      raise ApiError("""%s.removeResonanceSet:
       value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeResonanceSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeResonanceSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeResonanceSet:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeResonanceSet:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      oldSelves = value.__dict__.get('atomSets')
      if (len(oldSelves) < (1 + 1)):
        raise ApiError("""%s.removeResonanceSet:
         locard: oldSelves: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('atomSets')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeResonanceSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceSets, self.removeResonanceSet,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAtoms(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAtoms:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Atom as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setAtoms:
         value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atoms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAtoms:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAtoms:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAtoms:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (len(values) < 1):
        raise ApiError("""%s.setAtoms:
         locard: values must be of length >= 1""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAtoms:
           Link atoms between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('fixedAtomSets')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('fixedAtomSets')
        oldSelves.add(self)

    dataDict['atoms'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAtoms')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAtoms, self.setAtoms,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedAtomSet.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setName:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setName:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setName, self.setName,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setResonanceSets(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonanceSets:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonanceSet)):
        raise ApiError("""%s.setResonanceSets:
         value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceSets:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceSets:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonanceSets:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('atomSets')
          if (len(oldSelves) < (1 + 1)):
            raise ApiError("""%s.setResonanceSets:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonanceSets:
           Link resonanceSets between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('atomSets')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('atomSets')
        oldSelves.add(self)

    dataDict['resonanceSets'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceSets')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceSets, self.setResonanceSets,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedAtomSet.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('fixedAtomSets')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['fixedAtomSets'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['fixedAtomSets'] = value

    dataDict['serial'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedAtoms(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    ll = dataDict.get('atoms')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedResonanceSets(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonanceSets')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""name of FixedAtomSet
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  atoms = property(getAtoms, setAtoms, None,
  r"""Atoms making up FixedAtomSet
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)
  
  resonanceSets = property(getResonanceSets, setResonanceSets, None,
  r"""FixedResonanceSets associated with FixedAtomSet.
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.FixedAtomSet', FixedAtomSet)

###############################################################################
class FixedResonance(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Permanent, unchanging copy of Nmr.Resonance.
  """
  #   from data model element ccp.nmr.NmrConstraint.FixedResonance
  _metaclass = metaPackage.getElement('FixedResonance')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'chainCode', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'isotopeCode', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'atom', 'atomPairItems', 'chemicalShiftConstraints', 'chemicalShiftItems', 'covalentlyBound', 'csaConstraints', 'csaItems', 'dihedralConstraints', 'dihedralItems', 'distanceItems', 'fourAtomItems', 'hBondItems', 'isotope', 'jCouplingItem', 'nmrConstraintStore', 'pairwiseConstraintItems', 'parent', 'rdcItems', 'resonanceSet', 'root', 'singleAtomItems', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['chainCode'] = None
      dataDict['details'] = None
      dataDict['isotopeCode'] = None
      dataDict['name'] = None
      dataDict['residueType'] = None
      dataDict['resonanceSerial'] = None
      dataDict['sequenceCode'] = None
      dataDict['serial'] = None
      dataDict['atomPairItems'] = set()
      dataDict['chemicalShiftConstraints'] = set()
      dataDict['chemicalShiftItems'] = set()
      dataDict['covalentlyBound'] = set()
      dataDict['csaConstraints'] = set()
      dataDict['csaItems'] = set()
      dataDict['dihedralConstraints'] = set()
      dataDict['dihedralItems'] = set()
      dataDict['distanceItems'] = set()
      dataDict['fourAtomItems'] = set()
      dataDict['hBondItems'] = set()
      dataDict['jCouplingItem'] = None
      dataDict['pairwiseConstraintItems'] = set()
      dataDict['rdcItems'] = set()
      dataDict['resonanceSet'] = None
      dataDict['singleAtomItems'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.FixedResonance', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.FixedResonance.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.FixedResonance')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('fixedResonances')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.FixedResonance:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    atomPairItems = dataDict.get('atomPairItems')
    for atomPairItem in atomPairItems:
      if (not (atomPairItem in objsToBeDeleted)):
        objsToBeDeleted.add(atomPairItem)
        objsToBeChecked.append(atomPairItem)

    chemicalShiftConstraints = dataDict.get('chemicalShiftConstraints')
    for chemicalShiftConstraint in chemicalShiftConstraints:
      if (not (chemicalShiftConstraint in objsToBeDeleted)):
        objsToBeDeleted.add(chemicalShiftConstraint)
        objsToBeChecked.append(chemicalShiftConstraint)

    chemicalShiftItems = dataDict.get('chemicalShiftItems')
    for chemicalShiftItem in chemicalShiftItems:
      if (not (chemicalShiftItem in objsToBeDeleted)):
        objsToBeDeleted.add(chemicalShiftItem)
        objsToBeChecked.append(chemicalShiftItem)

    csaConstraints = dataDict.get('csaConstraints')
    for csaConstraint in csaConstraints:
      if (not (csaConstraint in objsToBeDeleted)):
        objsToBeDeleted.add(csaConstraint)
        objsToBeChecked.append(csaConstraint)

    csaItems = dataDict.get('csaItems')
    for csaItem in csaItems:
      if (not (csaItem in objsToBeDeleted)):
        objsToBeDeleted.add(csaItem)
        objsToBeChecked.append(csaItem)

    dihedralConstraints = dataDict.get('dihedralConstraints')
    for dihedralConstraint in dihedralConstraints:
      if (not (dihedralConstraint in objsToBeDeleted)):
        objsToBeDeleted.add(dihedralConstraint)
        objsToBeChecked.append(dihedralConstraint)

    dihedralItems = dataDict.get('dihedralItems')
    for dihedralItem in dihedralItems:
      if (not (dihedralItem in objsToBeDeleted)):
        objsToBeDeleted.add(dihedralItem)
        objsToBeChecked.append(dihedralItem)

    distanceItems = dataDict.get('distanceItems')
    for distanceItem in distanceItems:
      if (not (distanceItem in objsToBeDeleted)):
        objsToBeDeleted.add(distanceItem)
        objsToBeChecked.append(distanceItem)

    fourAtomItems = dataDict.get('fourAtomItems')
    for fourAtomItem in fourAtomItems:
      if (not (fourAtomItem in objsToBeDeleted)):
        objsToBeDeleted.add(fourAtomItem)
        objsToBeChecked.append(fourAtomItem)

    hBondItems = dataDict.get('hBondItems')
    for hBondItem in hBondItems:
      if (not (hBondItem in objsToBeDeleted)):
        objsToBeDeleted.add(hBondItem)
        objsToBeChecked.append(hBondItem)

    jCouplingItem = dataDict.get('jCouplingItem')
    if (jCouplingItem is not None):
      if (not (jCouplingItem in objsToBeDeleted)):
        objsToBeDeleted.add(jCouplingItem)
        objsToBeChecked.append(jCouplingItem)

    pairwiseConstraintItems = dataDict.get('pairwiseConstraintItems')
    for pairwiseConstraintItem in pairwiseConstraintItems:
      if (not (pairwiseConstraintItem in objsToBeDeleted)):
        objsToBeDeleted.add(pairwiseConstraintItem)
        objsToBeChecked.append(pairwiseConstraintItem)

    rdcItems = dataDict.get('rdcItems')
    for rdcItem in rdcItems:
      if (not (rdcItem in objsToBeDeleted)):
        objsToBeDeleted.add(rdcItem)
        objsToBeChecked.append(rdcItem)

    resonanceSet = dataDict.get('resonanceSet')
    if (resonanceSet is not None):
      if (not (resonanceSet in objsToBeDeleted)):
        backlink = resonanceSet.__dict__.get('resonances')
        key = (resonanceSet, 'resonances')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 1):
          objsToBeDeleted.add(resonanceSet)
          objsToBeChecked.append(resonanceSet)
        else:
          linkCounter[key] = nFound

    singleAtomItems = dataDict.get('singleAtomItems')
    for singleAtomItem in singleAtomItems:
      if (not (singleAtomItem in objsToBeDeleted)):
        objsToBeDeleted.add(singleAtomItem)
        objsToBeChecked.append(singleAtomItem)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.FixedResonance:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for covalentlyBound in dataDict.get('covalentlyBound'):
      if (not (covalentlyBound in objsToBeDeleted)):
        covalentlyBound_2 = covalentlyBound.__dict__.get('covalentlyBound')
        covalentlyBound_2.remove(self)

    resonanceSet = dataDict.get('resonanceSet')
    if ((resonanceSet is not None and not (resonanceSet in objsToBeDeleted))):
      resonances = resonanceSet.__dict__.get('resonances')
      resonances.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('fixedResonances')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.FixedResonance:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('fixedResonances')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for covalentlyBound in dataDict.get('covalentlyBound'):
      if (not (covalentlyBound in objsToBeUnDeleted)):
        covalentlyBound_2 = covalentlyBound.__dict__.get('covalentlyBound')
        covalentlyBound_2.add(self)

    resonanceSet = dataDict.get('resonanceSet')
    if ((resonanceSet is not None and not (resonanceSet in objsToBeUnDeleted))):
      resonances = resonanceSet.__dict__.get('resonances')
      resonances.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addCovalentlyBound(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedResonance.covalentlyBound
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.addCovalentlyBound:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('covalentlyBound')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addCovalentlyBound:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addCovalentlyBound:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addCovalentlyBound:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addCovalentlyBound:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addCovalentlyBound:
           Link covalentlyBound between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          if (self is value):
            raise ApiError("""%s.addCovalentlyBound:
             symmetrical link connects object to itself""" % self.qualifiedName
            )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('covalentlyBound')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addCovalentlyBound')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCovalentlyBound, self.addCovalentlyBound,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('fixedResonances')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('chainCode')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: chainCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: chainCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: chainCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: chainCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isotopeCode')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: isotopeCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: isotopeCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: isotopeCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: isotopeCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('residueType')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: residueType:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: residueType:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: residueType:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: residueType:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('resonanceSerial')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: resonanceSerial:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('sequenceCode')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: sequenceCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: sequenceCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: sequenceCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: sequenceCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = self.getAtom()
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Atom as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: atom:
           value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: atom:
           Link atom between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('atomPairItems')
      for value in values:
        if (not isinstance(value, AtomPairItem)):
          raise ApiError("""%s.checkValid: atomPairItems:
           value is not of class ccp.nmr.NmrConstraint.AtomPairItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: atomPairItems:
           non-reciprocal link atomPairItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: atomPairItems:
           Link atomPairItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('chemicalShiftConstraints')
      for value in values:
        if (not isinstance(value, ChemicalShiftConstraint)):
          raise ApiError("""%s.checkValid: chemicalShiftConstraints:
           value is not of class ccp.nmr.NmrConstraint.ChemicalShiftConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: chemicalShiftConstraints:
           non-reciprocal link chemicalShiftConstraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: chemicalShiftConstraints:
           Link chemicalShiftConstraints between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('chemicalShiftItems')
      for value in values:
        if (not isinstance(value, ChemicalShiftItem)):
          raise ApiError("""%s.checkValid: chemicalShiftItems:
           value is not of class ccp.nmr.NmrConstraint.ChemicalShiftItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: chemicalShiftItems:
           non-reciprocal link chemicalShiftItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: chemicalShiftItems:
           Link chemicalShiftItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('covalentlyBound')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: covalentlyBound:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('covalentlyBound')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: covalentlyBound:
           non-reciprocal link covalentlyBound from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: covalentlyBound:
           Link covalentlyBound between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('csaConstraints')
      for value in values:
        if (not isinstance(value, CsaConstraint)):
          raise ApiError("""%s.checkValid: csaConstraints:
           value is not of class ccp.nmr.NmrConstraint.CsaConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: csaConstraints:
           non-reciprocal link csaConstraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: csaConstraints:
           Link csaConstraints between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('csaItems')
      for value in values:
        if (not isinstance(value, CsaItem)):
          raise ApiError("""%s.checkValid: csaItems:
           value is not of class ccp.nmr.NmrConstraint.CsaItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: csaItems:
           non-reciprocal link csaItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: csaItems:
           Link csaItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('dihedralConstraints')
      for value in values:
        if (not isinstance(value, DihedralConstraint)):
          raise ApiError("""%s.checkValid: dihedralConstraints:
           value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: dihedralConstraints:
           non-reciprocal link dihedralConstraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: dihedralConstraints:
           Link dihedralConstraints between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('dihedralItems')
      for value in values:
        if (not isinstance(value, DihedralItem)):
          raise ApiError("""%s.checkValid: dihedralItems:
           value is not of class ccp.nmr.NmrConstraint.DihedralItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: dihedralItems:
           non-reciprocal link dihedralItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: dihedralItems:
           Link dihedralItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('distanceItems')
      for value in values:
        if (not isinstance(value, DistanceItem)):
          raise ApiError("""%s.checkValid: distanceItems:
           value is not of class ccp.nmr.NmrConstraint.DistanceItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: distanceItems:
           non-reciprocal link distanceItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: distanceItems:
           Link distanceItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('fourAtomItems')
      for value in values:
        if (not isinstance(value, FourAtomItem)):
          raise ApiError("""%s.checkValid: fourAtomItems:
           value is not of class ccp.nmr.NmrConstraint.FourAtomItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: fourAtomItems:
           non-reciprocal link fourAtomItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: fourAtomItems:
           Link fourAtomItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('hBondItems')
      for value in values:
        if (not isinstance(value, HBondItem)):
          raise ApiError("""%s.checkValid: hBondItems:
           value is not of class ccp.nmr.NmrConstraint.HBondItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: hBondItems:
           non-reciprocal link hBondItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: hBondItems:
           Link hBondItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = self.getIsotope()
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.molecule.ChemElement import Isotope as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: isotope:
           value is not of class ccp.molecule.ChemElement.Isotope""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: isotope:
           Link isotope between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('jCouplingItem')
      if (value is not None):
        if (not isinstance(value, JCouplingItem)):
          raise ApiError("""%s.checkValid: jCouplingItem:
           value is not of class ccp.nmr.NmrConstraint.JCouplingItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: jCouplingItem:
           non-reciprocal link jCouplingItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: jCouplingItem:
           Link jCouplingItem between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('pairwiseConstraintItems')
      for value in values:
        if (not isinstance(value, PairwiseConstraintItem)):
          raise ApiError("""%s.checkValid: pairwiseConstraintItems:
           value is not of class ccp.nmr.NmrConstraint.PairwiseConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: pairwiseConstraintItems:
           non-reciprocal link pairwiseConstraintItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: pairwiseConstraintItems:
           Link pairwiseConstraintItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('rdcItems')
      for value in values:
        if (not isinstance(value, RdcItem)):
          raise ApiError("""%s.checkValid: rdcItems:
           value is not of class ccp.nmr.NmrConstraint.RdcItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: rdcItems:
           non-reciprocal link rdcItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: rdcItems:
           Link rdcItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('resonanceSet')
      if (value is not None):
        if (not isinstance(value, FixedResonanceSet)):
          raise ApiError("""%s.checkValid: resonanceSet:
           value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonanceSet:
           non-reciprocal link resonanceSet from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('singleAtomItems')
      for value in values:
        if (not isinstance(value, SingleAtomItem)):
          raise ApiError("""%s.checkValid: singleAtomItems:
           value is not of class ccp.nmr.NmrConstraint.SingleAtomItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: singleAtomItems:
           non-reciprocal link singleAtomItems from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: singleAtomItems:
           Link singleAtomItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('chainCode')
    value = dataDict.get('details')
    value = dataDict.get('isotopeCode')
    if (value is None):
      raise ApiError("""%s.checkValid: isotopeCode:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('name')
    value = dataDict.get('residueType')
    value = dataDict.get('resonanceSerial')
    value = dataDict.get('sequenceCode')
    # check roles
    values = dataDict.get('atomPairItems')
    values = dataDict.get('chemicalShiftConstraints')
    for value in values:
      (self, value) = (value, self)
      if (not (self.parentList.isotopeCode in (None, value.isotopeCode))):
        raise ApiError("""%s.checkValid: chemicalShiftConstraints:
         resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      (value, self) = (self, value)

    values = dataDict.get('chemicalShiftItems')
    values = dataDict.get('covalentlyBound')
    for value in values:
      if (self is value):
        raise ApiError("""%s.checkValid: covalentlyBound:
         symmetrical link connects object to itself""" % self.qualifiedName
        )

    values = dataDict.get('csaConstraints')
    for value in values:
      (self, value) = (value, self)
      if (not (self.parentList.isotopeCode in (None, value.isotopeCode))):
        raise ApiError("""%s.checkValid: csaConstraints:
         resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      (value, self) = (self, value)

    values = dataDict.get('csaItems')
    values = dataDict.get('dihedralConstraints')
    values = dataDict.get('dihedralItems')
    values = dataDict.get('distanceItems')
    values = dataDict.get('fourAtomItems')
    values = dataDict.get('hBondItems')
    value = dataDict.get('jCouplingItem')
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('pairwiseConstraintItems')
    values = dataDict.get('rdcItems')
    value = dataDict.get('resonanceSet')
    values = dataDict.get('singleAtomItems')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllAtomPairItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.atomPairItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atomPairItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('atomPairItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllChemicalShiftConstraints(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('chemicalShiftConstraints')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('chemicalShiftConstraints')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllChemicalShiftItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('chemicalShiftItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('chemicalShiftItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllCovalentlyBound(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.covalentlyBound
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('covalentlyBound')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('covalentlyBound')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllCsaConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('csaConstraints')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('csaConstraints')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllCsaItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.csaItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('csaItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('csaItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllDihedralConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('dihedralConstraints')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('dihedralConstraints')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'origData', 'serial', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllDihedralItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.dihedralItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('dihedralItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('dihedralItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllDistanceItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.distanceItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('distanceItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('distanceItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllFourAtomItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.fourAtomItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('fourAtomItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('fourAtomItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllHBondItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.hBondItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('hBondItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('hBondItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllPairwiseConstraintItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('pairwiseConstraintItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('pairwiseConstraintItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllRdcItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.rdcItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('rdcItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('rdcItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllSingleAtomItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.singleAtomItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('singleAtomItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('singleAtomItems')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAtomPairItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.atomPairItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atomPairItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('atomPairItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstChemicalShiftConstraint(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('chemicalShiftConstraints')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('chemicalShiftConstraints')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstChemicalShiftItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('chemicalShiftItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('chemicalShiftItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstCovalentlyBound(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.covalentlyBound
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('covalentlyBound')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('covalentlyBound')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstCsaConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('csaConstraints')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('csaConstraints')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstCsaItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.csaItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('csaItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('csaItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstDihedralConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('dihedralConstraints')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('dihedralConstraints')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'origData', 'serial', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstDihedralItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.dihedralItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('dihedralItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('dihedralItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstDistanceItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.distanceItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('distanceItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('distanceItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstFourAtomItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.fourAtomItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('fourAtomItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('fourAtomItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstHBondItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.hBondItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('hBondItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('hBondItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstPairwiseConstraintItem(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('pairwiseConstraintItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('pairwiseConstraintItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstRdcItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.rdcItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('rdcItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('rdcItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstSingleAtomItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.singleAtomItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('singleAtomItems')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('singleAtomItems')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAtom(self):
    """
    geter for derived link Atom
    """
    dataDict = self.__dict__
    result = self.getByNavigation('nmrConstraintStore', 'nmrProject', 'molSystem', ('chains', self.chainCode), ('residues', self.sequenceCode), ('atoms', self.name))
    return result
  
  def getAtomPairItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.atomPairItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('atomPairItems')
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.FixedResonance
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedResonance'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedResonance'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('fixedResonances').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData
  
  def getChainCode(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.chainCode
    """
    dataDict = self.__dict__
    result = dataDict.get('chainCode')
    return result
  
  def getChemicalShiftConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftConstraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('chemicalShiftConstraints')
    result = frozenset(tempVar)
    return result
  
  def getChemicalShiftItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('chemicalShiftItems')
    result = frozenset(tempVar)
    return result

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getCovalentlyBound(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.covalentlyBound
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('covalentlyBound')
    result = frozenset(tempVar)
    return result
  
  def getCsaConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('csaConstraints')
    result = frozenset(tempVar)
    return result
  
  def getCsaItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.csaItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('csaItems')
    result = frozenset(tempVar)
    return result
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result
  
  def getDihedralConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('dihedralConstraints')
    result = frozenset(tempVar)
    return result
  
  def getDihedralItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.dihedralItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('dihedralItems')
    result = frozenset(tempVar)
    return result
  
  def getDistanceItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.distanceItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('distanceItems')
    result = frozenset(tempVar)
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFourAtomItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.fourAtomItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('fourAtomItems')
    result = frozenset(tempVar)
    return result
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result
  
  def getHBondItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.hBondItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('hBondItems')
    result = frozenset(tempVar)
    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getIsotope(self):
    """
    getter for derived link Isotope
    """
    dataDict = self.__dict__
    ss = self.isotopeCode
    if ss == '?':
      return None
    if ss[-2] in '0123456789':
      firstLetter = -1
    else:
      firstLetter = -2
    atomSymbol = ss[firstLetter:].capitalize()
    massNumber = int(ss[:firstLetter])
    
    result = ccpnmodel.ccpncore.api.ccp.molecule.ChemElement.Isotope.getByKey(self.root.currentChemElementStore,(atomSymbol, massNumber))
    return result
  
  def getIsotopeCode(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.isotopeCode
    """
    dataDict = self.__dict__
    result = dataDict.get('isotopeCode')
    return result
  
  def getJCouplingItem(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.jCouplingItem
    """
    dataDict = self.__dict__
    result = dataDict.get('jCouplingItem')
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getPairwiseConstraintItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('pairwiseConstraintItems')
    result = frozenset(tempVar)
    return result
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getRdcItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.rdcItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('rdcItems')
    result = frozenset(tempVar)
    return result
  
  def getResidueType(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.residueType
    """
    dataDict = self.__dict__
    result = dataDict.get('residueType')
    return result
  
  def getResonanceSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.resonanceSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('resonanceSerial')
    return result
  
  def getResonanceSet(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.resonanceSet
    """
    dataDict = self.__dict__
    result = dataDict.get('resonanceSet')
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSequenceCode(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.sequenceCode
    """
    dataDict = self.__dict__
    result = dataDict.get('sequenceCode')
    return result
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getSingleAtomItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.singleAtomItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('singleAtomItems')
    result = frozenset(tempVar)
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeCovalentlyBound(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedResonance.covalentlyBound
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.removeCovalentlyBound:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('covalentlyBound')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeCovalentlyBound:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeCovalentlyBound:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeCovalentlyBound:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeCovalentlyBound:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('covalentlyBound')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeCovalentlyBound')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCovalentlyBound, self.removeCovalentlyBound,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAtomPairItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.atomPairItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAtomPairItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, AtomPairItem)):
        raise ApiError("""%s.setAtomPairItems:
         value is not of class ccp.nmr.NmrConstraint.AtomPairItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atomPairItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAtomPairItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAtomPairItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAtomPairItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (2 + 1)):
            raise ApiError("""%s.setAtomPairItems:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 2):
            raise ApiError("""%s.setAtomPairItems:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAtomPairItems:
           Link atomPairItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.add(self)

    dataDict['atomPairItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAtomPairItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAtomPairItems, self.setAtomPairItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setChainCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.chainCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setChainCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setChainCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setChainCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setChainCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('chainCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setChainCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChainCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['chainCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setChainCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setChainCode, self.setChainCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setChemicalShiftConstraints(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftConstraints
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setChemicalShiftConstraints:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, ChemicalShiftConstraint)):
        raise ApiError("""%s.setChemicalShiftConstraints:
         value is not of class ccp.nmr.NmrConstraint.ChemicalShiftConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('chemicalShiftConstraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setChemicalShiftConstraints:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChemicalShiftConstraints:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setChemicalShiftConstraints:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setChemicalShiftConstraints:
           locard resonance: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setChemicalShiftConstraints:
           Link chemicalShiftConstraints between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          (self, value) = (value, self)
          if (not (self.parentList.isotopeCode in (None, value.isotopeCode))):
            raise ApiError("""%s.setChemicalShiftConstraints:
             resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

          (value, self) = (self, value)

    for cv in values:
      cv.__dict__['resonance'] = self

    dataDict['chemicalShiftConstraints'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setChemicalShiftConstraints')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setChemicalShiftConstraints, self.setChemicalShiftConstraints,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setChemicalShiftItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setChemicalShiftItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, ChemicalShiftItem)):
        raise ApiError("""%s.setChemicalShiftItems:
         value is not of class ccp.nmr.NmrConstraint.ChemicalShiftItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('chemicalShiftItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setChemicalShiftItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChemicalShiftItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setChemicalShiftItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setChemicalShiftItems:
           locard resonance: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setChemicalShiftItems:
           Link chemicalShiftItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['resonance'] = self

    dataDict['chemicalShiftItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setChemicalShiftItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setChemicalShiftItems, self.setChemicalShiftItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setCovalentlyBound(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.covalentlyBound
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setCovalentlyBound:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setCovalentlyBound:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('covalentlyBound')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCovalentlyBound:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCovalentlyBound:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setCovalentlyBound:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setCovalentlyBound:
           Link covalentlyBound between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          if (self is value):
            raise ApiError("""%s.setCovalentlyBound:
             symmetrical link connects object to itself""" % self.qualifiedName
            )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('covalentlyBound')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('covalentlyBound')
        oldSelves.add(self)

    dataDict['covalentlyBound'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCovalentlyBound')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCovalentlyBound, self.setCovalentlyBound,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setCsaConstraints(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setCsaConstraints:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, CsaConstraint)):
        raise ApiError("""%s.setCsaConstraints:
         value is not of class ccp.nmr.NmrConstraint.CsaConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('csaConstraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCsaConstraints:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCsaConstraints:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setCsaConstraints:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setCsaConstraints:
           locard resonance: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setCsaConstraints:
           Link csaConstraints between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          (self, value) = (value, self)
          if (not (self.parentList.isotopeCode in (None, value.isotopeCode))):
            raise ApiError("""%s.setCsaConstraints:
             resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

          (value, self) = (self, value)

    for cv in values:
      cv.__dict__['resonance'] = self

    dataDict['csaConstraints'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCsaConstraints')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCsaConstraints, self.setCsaConstraints,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setCsaItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.csaItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setCsaItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, CsaItem)):
        raise ApiError("""%s.setCsaItems:
         value is not of class ccp.nmr.NmrConstraint.CsaItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('csaItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCsaItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCsaItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setCsaItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setCsaItems:
           locard resonance: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setCsaItems:
           Link csaItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['resonance'] = self

    dataDict['csaItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCsaItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCsaItems, self.setCsaItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setDihedralConstraints(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setDihedralConstraints:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, DihedralConstraint)):
        raise ApiError("""%s.setDihedralConstraints:
         value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('dihedralConstraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDihedralConstraints:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDihedralConstraints:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setDihedralConstraints:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (4 + 1)):
            raise ApiError("""%s.setDihedralConstraints:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 4):
            raise ApiError("""%s.setDihedralConstraints:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setDihedralConstraints:
           Link dihedralConstraints between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.append(self)

    dataDict['dihedralConstraints'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDihedralConstraints')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDihedralConstraints, self.setDihedralConstraints,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setDihedralItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.dihedralItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setDihedralItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, DihedralItem)):
        raise ApiError("""%s.setDihedralItems:
         value is not of class ccp.nmr.NmrConstraint.DihedralItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('dihedralItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDihedralItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDihedralItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setDihedralItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (4 + 1)):
            raise ApiError("""%s.setDihedralItems:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 4):
            raise ApiError("""%s.setDihedralItems:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setDihedralItems:
           Link dihedralItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.append(self)

    dataDict['dihedralItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDihedralItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDihedralItems, self.setDihedralItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setDistanceItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.distanceItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setDistanceItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, DistanceItem)):
        raise ApiError("""%s.setDistanceItems:
         value is not of class ccp.nmr.NmrConstraint.DistanceItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('distanceItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDistanceItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDistanceItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setDistanceItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (2 + 1)):
            raise ApiError("""%s.setDistanceItems:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 2):
            raise ApiError("""%s.setDistanceItems:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setDistanceItems:
           Link distanceItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.add(self)

    dataDict['distanceItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDistanceItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDistanceItems, self.setDistanceItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setFourAtomItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.fourAtomItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setFourAtomItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FourAtomItem)):
        raise ApiError("""%s.setFourAtomItems:
         value is not of class ccp.nmr.NmrConstraint.FourAtomItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('fourAtomItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setFourAtomItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setFourAtomItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setFourAtomItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (4 + 1)):
            raise ApiError("""%s.setFourAtomItems:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 4):
            raise ApiError("""%s.setFourAtomItems:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setFourAtomItems:
           Link fourAtomItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.append(self)

    dataDict['fourAtomItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setFourAtomItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setFourAtomItems, self.setFourAtomItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setHBondItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.hBondItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setHBondItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, HBondItem)):
        raise ApiError("""%s.setHBondItems:
         value is not of class ccp.nmr.NmrConstraint.HBondItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('hBondItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setHBondItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setHBondItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setHBondItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (2 + 1)):
            raise ApiError("""%s.setHBondItems:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 2):
            raise ApiError("""%s.setHBondItems:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setHBondItems:
           Link hBondItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.add(self)

    dataDict['hBondItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setHBondItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setHBondItems, self.setHBondItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setIsotopeCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.isotopeCode
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setIsotopeCode:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setIsotopeCode:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setIsotopeCode:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setIsotopeCode:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isotopeCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsotopeCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsotopeCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setIsotopeCode:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['isotopeCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsotopeCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setIsotopeCode, self.setIsotopeCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setJCouplingItem(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.jCouplingItem
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, JCouplingItem)):
        raise ApiError("""%s.setJCouplingItem:
         value is not of class ccp.nmr.NmrConstraint.JCouplingItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('jCouplingItem')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setJCouplingItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setJCouplingItem:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setJCouplingItem:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (currentValue is not None):
        oldSelves = currentValue.__dict__.get('resonances')
        if (len(oldSelves) < (2 + 1)):
          raise ApiError("""%s.setJCouplingItem:
           locard: oldSelves: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        newSelves = value.__dict__.get('resonances')
        if (len(newSelves) >= 2):
          raise ApiError("""%s.setJCouplingItem:
           hicard: newSelves: cannot add value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setJCouplingItem:
           Link jCouplingItem between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('resonances')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setJCouplingItem:
         Read link 'jCouplingItem' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('resonances')
      newSelves.add(self)

    dataDict['jCouplingItem'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setJCouplingItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setJCouplingItem, self.setJCouplingItem,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setName, self.setName,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPairwiseConstraintItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setPairwiseConstraintItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, PairwiseConstraintItem)):
        raise ApiError("""%s.setPairwiseConstraintItems:
         value is not of class ccp.nmr.NmrConstraint.PairwiseConstraintItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('pairwiseConstraintItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPairwiseConstraintItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPairwiseConstraintItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPairwiseConstraintItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (2 + 1)):
            raise ApiError("""%s.setPairwiseConstraintItems:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 2):
            raise ApiError("""%s.setPairwiseConstraintItems:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setPairwiseConstraintItems:
           Link pairwiseConstraintItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.add(self)

    dataDict['pairwiseConstraintItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPairwiseConstraintItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPairwiseConstraintItems, self.setPairwiseConstraintItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setRdcItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.rdcItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setRdcItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, RdcItem)):
        raise ApiError("""%s.setRdcItems:
         value is not of class ccp.nmr.NmrConstraint.RdcItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('rdcItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setRdcItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setRdcItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setRdcItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (2 + 1)):
            raise ApiError("""%s.setRdcItems:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 2):
            raise ApiError("""%s.setRdcItems:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setRdcItems:
           Link rdcItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.add(self)

    dataDict['rdcItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setRdcItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setRdcItems, self.setRdcItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setResidueType(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.residueType
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setResidueType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setResidueType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setResidueType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setResidueType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('residueType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResidueType:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResidueType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['residueType'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResidueType')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResidueType, self.setResidueType,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setResonanceSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.resonanceSerial
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setResonanceSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonanceSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['resonanceSerial'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceSerial, self.setResonanceSerial,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setResonanceSet(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.resonanceSet
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, FixedResonanceSet)):
        raise ApiError("""%s.setResonanceSet:
         value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonanceSet')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonanceSet:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (currentValue is not None):
        oldSelves = currentValue.__dict__.get('resonances')
        if (len(oldSelves) < (1 + 1)):
          raise ApiError("""%s.setResonanceSet:
           locard: oldSelves: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonanceSet:
           Link resonanceSet between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('resonances')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonanceSet:
         Read link 'resonanceSet' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('resonances')
      newSelves.add(self)

    dataDict['resonanceSet'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceSet, self.setResonanceSet,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSequenceCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.sequenceCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setSequenceCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setSequenceCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setSequenceCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setSequenceCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('sequenceCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSequenceCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSequenceCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['sequenceCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSequenceCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSequenceCode, self.setSequenceCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('fixedResonances')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['fixedResonances'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['fixedResonances'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setSingleAtomItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.singleAtomItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setSingleAtomItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, SingleAtomItem)):
        raise ApiError("""%s.setSingleAtomItems:
         value is not of class ccp.nmr.NmrConstraint.SingleAtomItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('singleAtomItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSingleAtomItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSingleAtomItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setSingleAtomItems:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setSingleAtomItems:
           locard resonance: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setSingleAtomItems:
           Link singleAtomItems between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['resonance'] = self

    dataDict['singleAtomItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSingleAtomItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSingleAtomItems, self.setSingleAtomItems,
                      undoArgs=(currentValues,), redoArgs=(values,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedAtomPairItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.atomPairItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('atomPairItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedChemicalShiftConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftConstraints
    """
    dataDict = self.__dict__
    ll = dataDict.get('chemicalShiftConstraints')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedChemicalShiftItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.chemicalShiftItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('chemicalShiftItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedCovalentlyBound(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.covalentlyBound
    """
    dataDict = self.__dict__
    ll = dataDict.get('covalentlyBound')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedCsaConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    ll = dataDict.get('csaConstraints')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedCsaItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.csaItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('csaItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedDihedralConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    ll = dataDict.get('dihedralConstraints')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedDihedralItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.dihedralItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('dihedralItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedDistanceItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.distanceItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('distanceItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedFourAtomItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.fourAtomItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('fourAtomItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedHBondItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.hBondItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('hBondItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedPairwiseConstraintItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('pairwiseConstraintItems')
    ll = [(repr(x),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedRdcItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.rdcItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('rdcItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedSingleAtomItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.singleAtomItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('singleAtomItems')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData
  
  chainCode = property(getChainCode, setChainCode, None,
  r"""chainCode for equivalent chain
  """)

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  isotopeCode = property(getIsotopeCode, setIsotopeCode, None,
  r"""Isotope code of corresponding isotope. E.g. 1H, 2H, 3He, 13C, ..
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""atomName of equivalent Atom or resonance
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  residueType = property(getResidueType, setResidueType, None,
  r"""code3Letter for equivalent residue
  """)
  
  resonanceSerial = property(getResonanceSerial, setResonanceSerial, None,
  r"""Serial of corresponding Nmr.Resonance
  """)
  
  sequenceCode = property(getSequenceCode, setSequenceCode, None,
  r"""sequenceCode (seqCode + seqINsertCode) for equivalet residue
  """)
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  atom = property(getAtom, None, None,
  r"""Atom matching FixedResonance
  """)
  
  atomPairItems = property(getAtomPairItems, setAtomPairItems, None,
  r"""AtomPairItems involving FixedResonance
  """)
  
  chemicalShiftConstraints = property(getChemicalShiftConstraints, setChemicalShiftConstraints, None,
  r"""Chemical shift constraints involving FIxedResonance
  """)
  
  chemicalShiftItems = property(getChemicalShiftItems, setChemicalShiftItems, None,
  r"""ChemShiftItems corresponding to FixedResonance
  """)
  
  covalentlyBound = property(getCovalentlyBound, setCovalentlyBound, None,
  r"""Resonances on both ends stand for atoms that are covalently linked.
  """)
  
  csaConstraints = property(getCsaConstraints, setCsaConstraints, None,
  r"""Chemical shift anisotropy constraints involving FIxedResonance
  """)
  
  csaItems = property(getCsaItems, setCsaItems, None,
  r"""Chemical Shift Anisotrppy constraint items corresponding to 
  FIxedResonance
  """)
  
  dihedralConstraints = property(getDihedralConstraints, setDihedralConstraints, None,
  r"""Dihedral angle constraints involving FixedResonance.
  """)
  
  dihedralItems = property(getDihedralItems, setDihedralItems, None,
  r"""DihedralItems involving FIxedResonance
  """)
  
  distanceItems = property(getDistanceItems, setDistanceItems, None,
  r"""DistanceItems involving FIxedResonance
  """)
  
  fourAtomItems = property(getFourAtomItems, setFourAtomItems, None,
  r"""
  """)
  
  hBondItems = property(getHBondItems, setHBondItems, None,
  r"""HBondItems connected to FIxedResonance
  """)
  
  isotope = property(getIsotope, None, None,
  r"""Isotope corresponding to FixedResonance
  """)
  
  jCouplingItem = property(getJCouplingItem, setJCouplingItem, None,
  r"""
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  pairwiseConstraintItems = property(getPairwiseConstraintItems, setPairwiseConstraintItems, None,
  r"""PairWiseConstraintItems that involve FixedResonance
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)
  
  rdcItems = property(getRdcItems, setRdcItems, None,
  r"""RdcItems involving FixedResonance
  """)
  
  resonanceSet = property(getResonanceSet, setResonanceSet, None,
  r"""FixedResonanceSet (part of assignment for Constraint Lists) involving 
  Resonance.
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  singleAtomItems = property(getSingleAtomItems, setSingleAtomItems, None,
  r"""SingleAtomItems defined by FixedResonance
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.FixedResonance', FixedResonance)

###############################################################################
class FixedResonanceSet(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Fixed version of ResonanceSet. When a Structure Generation run is 
started, AtomSets and ResonanceSets are copied to FixedAtomSets and 
FixedResonanceSets in order to preserve the Resonance-Atom assignment 
valid for a StructureGeneration and the associated ConstraintLists.
  """
  #   from data model element ccp.nmr.NmrConstraint.FixedResonanceSet
  _metaclass = metaPackage.getElement('FixedResonanceSet')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'atomSets', 'nmrConstraintStore', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['serial'] = None
      dataDict['atomSets'] = set()
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.FixedResonanceSet', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.FixedResonanceSet.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.FixedResonanceSet')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('fixedResonanceSets')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.FixedResonanceSet:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.FixedResonanceSet:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for atomSet in dataDict.get('atomSets'):
      if (not (atomSet in objsToBeDeleted)):
        resonanceSets = atomSet.__dict__.get('resonanceSets')
        resonanceSets.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        resonance.__dict__['resonanceSet'] = None

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('fixedResonanceSets')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.FixedResonanceSet:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('fixedResonanceSets')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for atomSet in dataDict.get('atomSets'):
      if (not (atomSet in objsToBeUnDeleted)):
        resonanceSets = atomSet.__dict__.get('resonanceSets')
        resonanceSets.add(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        if (resonance.__dict__.get('resonanceSet') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of FixedResonanceSet object resonances link - backLink FixedResonance.resonanceSet is not None""" % self.qualifiedName
          )

        resonance.__dict__['resonanceSet'] = self

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addAtomSet(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedAtomSet)):
      raise ApiError("""%s.addAtomSet:
       value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atomSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAtomSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAtomSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addAtomSet:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addAtomSet:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addAtomSet:
           Link atomSets between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('resonanceSets')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAtomSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAtomSets, self.addAtomSet,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addResonance(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.addResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.resonanceSet}

    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addResonance:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      oldSelf = value.__dict__.get('resonanceSet')
      if (oldSelf is not None):
        siblingValues = oldSelf.__dict__.get('resonances')
        if (len(siblingValues) < (1 + 1)):
          raise ApiError("""%s.addResonance:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addResonance:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('resonanceSet')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('resonances')
      siblingValues.remove(value)

    value.__dict__['resonanceSet'] = self
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addResonance, undoArgs=(undoValueDict, 'resonanceSet'),  redoArgs=(value,))

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('fixedResonanceSets')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('atomSets')
      for value in values:
        if (not isinstance(value, FixedAtomSet)):
          raise ApiError("""%s.checkValid: atomSets:
           value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonanceSets')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: atomSets:
           non-reciprocal link atomSets from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: atomSets:
           Link atomSets between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonanceSet')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: resonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    values = dataDict.get('atomSets')
    if (len(values) < 1):
      raise ApiError("""%s.checkValid: atomSets:
       locard: values must be of length >= 1""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (len(values) < 1):
      raise ApiError("""%s.checkValid: resonances:
       locard: values must be of length >= 1""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllAtomSets(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atomSets')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('atomSets')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAtomSet(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atomSets')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('atomSets')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAtomSets(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('atomSets')
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.FixedResonanceSet
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedResonanceSet'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedResonanceSet'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('fixedResonanceSets').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeAtomSet(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedAtomSet)):
      raise ApiError("""%s.removeAtomSet:
       value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atomSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAtomSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAtomSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeAtomSet:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAtomSet:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (1 + 1)):
        raise ApiError("""%s.removeAtomSet:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('resonanceSets')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAtomSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAtomSets, self.removeAtomSet,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeResonance(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.removeResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeResonance:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (1 + 1)):
        raise ApiError("""%s.removeResonance:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    undoValues = set(currentValues)
    value.__dict__['resonanceSet'] = None
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonances, self.removeResonance,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAtomSets(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAtomSets:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedAtomSet)):
        raise ApiError("""%s.setAtomSets:
         value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atomSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAtomSets:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAtomSets:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAtomSets:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (len(values) < 1):
        raise ApiError("""%s.setAtomSets:
         locard: values must be of length >= 1""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAtomSets:
           Link atomSets between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonanceSets')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonanceSets')
        oldSelves.add(self)

    dataDict['atomSets'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAtomSets')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAtomSets, self.setAtomSets,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.resonanceSet) for y in (currentValues, values) for x in y)

    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonances:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (len(values) < 1):
        raise ApiError("""%s.setResonances:
         locard: values must be of length >= 1""" % self.qualifiedName
         + ": %s" % (self,)
        )

      oldSelves = {}
      for cv in values:
        if (not (cv in currentValues)):
          oldSelf = cv.__dict__.get('resonanceSet')
          if (oldSelf is not None):
            knt = oldSelves.get(oldSelf)
            if (knt is None):
              knt = 1
            else:
              knt = knt + 1

            oldSelves[oldSelf] = knt

      for osv in oldSelves.keys():
        siblingValues = osv.__dict__.get('resonances')
        knt = oldSelves.get(osv)
        if (len(siblingValues) < (1 + knt)):
          raise ApiError("""%s.setResonances:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['resonanceSet'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('resonanceSet')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('resonances')
          vv.remove(cv)

      cv.__dict__['resonanceSet'] = self

    dataDict['resonances'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonances')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setResonances, undoArgs=(undoValueDict, 'resonanceSet'),  redoArgs=(values,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonanceSet.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('fixedResonanceSets')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['fixedResonanceSets'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['fixedResonanceSets'] = value

    dataDict['serial'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedAtomSets(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    ll = dataDict.get('atomSets')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  atomSets = property(getAtomSets, setAtomSets, None,
  r"""FixedAtomSets making up FixedResonanceSet
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""FixedResonances making up FixedResonanceSet
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.FixedResonanceSet', FixedResonanceSet)

###############################################################################
class NmrConstraintStore(ccpnmodel.ccpncore.api.memops.Implementation.TopObject):
  r"""Collection of Nmr constraints used together, and associated information. 
This class serves as as general DataSet class in V3 (but we kept the old 
name to avoid trouble). 
  """
  #   from data model element ccp.nmr.NmrConstraint.NmrConstraintStore
  _metaclass = metaPackage.getElement('NmrConstraintStore')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', '_lastId', 'applicationData', 'ccpnInternalData', 'className', 'createdBy', 'creationDate', 'dataPath', 'details', 'fieldNames', 'guid', 'inConstructor', 'isDeleted', 'isLoaded', 'isModifiable', 'isModified', 'isReading', 'lastUnlockedBy', 'metaclass', 'name', 'packageName', 'packageShortName', 'programName', 'programVersion', 'qualifiedName', 'serial', 'uuid', 'activeRepositories', 'additionalStructureAnalyses', 'calculationSteps', 'chains', 'conditionStates', 'constraintGroups', 'constraintLists', 'dangleChains', 'data', 'dataSources', 'fixedAtomSets', 'fixedResonanceSets', 'fixedResonances', 'memopsRoot', 'nmrChains', 'nmrProject', 'notes', 'packageLocator', 'parent', 'peakLists', 'primaryStructureEnsemble', 'root', 'sampleComponents', 'samples', 'shiftLists', 'spectrumGroups', 'structureAnalyses', 'structureEnsembles', 'structureGenerations', 'topObject', 'validationStores', 'violationLists',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    dataDict['memopsRoot'] = parent
    from ccpnmodel.ccpncore.api.memops.Implementation import MemopsRoot as importedType
    if (not isinstance(parent, importedType)):
      raise ApiError("""%s.__init__:
       value is not of class memops.Implementation.MemopsRoot""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = self
    dataDict['topObject'] = topObject
    if (attrlinks.get('isReading', False)):
      del attrlinks['isReading']
      dataDict['isLoaded'] = False
      dataDict['isModified'] = False
      dataDict['isReading'] = True
    elif (parent.__dict__.get('isReading')):
      dataDict['isLoaded'] = False
      dataDict['isModified'] = False
      dataDict['isReading'] = True
    else:
      dataDict['isLoaded'] = True
      dataDict['isModified'] = True
      dataDict['isReading'] = False

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    try:
      if (not (dataDict.get('isReading'))):
        parent.refreshTopObjects('ccp.nmr.NmrConstraint')

      dataDict['_ID'] = None
      dataDict['_lastId'] = 0
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['createdBy'] = None
      dataDict['creationDate'] = None
      dataDict['dataPath'] = None
      dataDict['details'] = None
      dataDict['guid'] = None
      dataDict['isModifiable'] = True
      dataDict['lastUnlockedBy'] = None
      dataDict['name'] = None
      dataDict['programName'] = None
      dataDict['programVersion'] = None
      dataDict['serial'] = None
      dataDict['uuid'] = None
      dataDict['additionalStructureAnalyses'] = set()
      dataDict['calculationSteps'] = {}
      dataDict['chains'] = set()
      dataDict['conditionStates'] = {}
      dataDict['constraintGroups'] = {}
      dataDict['constraintLists'] = {}
      dataDict['dangleChains'] = set()
      dataDict['data'] = {}
      dataDict['dataSources'] = set()
      dataDict['fixedAtomSets'] = {}
      dataDict['fixedResonanceSets'] = {}
      dataDict['fixedResonances'] = {}
      dataDict['nmrChains'] = set()
      dataDict['nmrProject'] = None
      dataDict['notes'] = set()
      dataDict['peakLists'] = set()
      dataDict['primaryStructureEnsemble'] = None
      dataDict['sampleComponents'] = set()
      dataDict['samples'] = set()
      dataDict['shiftLists'] = set()
      dataDict['spectrumGroups'] = set()
      dataDict['structureAnalyses'] = set()
      dataDict['structureEnsembles'] = set()
      dataDict['structureGenerations'] = set()
      dataDict['validationStores'] = set()
      dataDict['violationLists'] = {}
      dataDict['activeRepositories'] = list()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.NmrConstraintStore', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.NmrConstraintStore.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.NmrConstraintStore')
          )

      serialDict = {}
      serialDict['calculationSteps'] = 0
      serialDict['conditionStates'] = 0
      serialDict['constraintGroups'] = 0
      serialDict['constraintLists'] = 0
      serialDict['fixedAtomSets'] = 0
      serialDict['fixedResonanceSets'] = 0
      serialDict['fixedResonances'] = 0
      serialDict['violationLists'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('nmrConstraintStores')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        guid = dataDict.get('guid')
        if (guid is None):
          guid = root.newGuid()
          dataDict['guid'] = guid

        dd = root.__dict__.get('topObjects')
        if (dd.get(guid) is None):
          dd[guid] = self
        else:
          raise ApiError("""%s.__init__:
           Creating TopObject with preexisting guid""" % self.qualifiedName
           + ": %s" % (self,)
          )

        dataDict['createdBy'] = root.__dict__.get('currentUserId')

      if (notOverride):
        self.checkValid()

      if ((notIsReading or root.__dict__.get('currentNmrConstraintStore') is None)):
        root.__dict__['currentNmrConstraintStore'] = self

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.NmrConstraintStore:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    objsToBeDeleted.add(self)
    additionalStructureAnalyses = dataDict.get('additionalStructureAnalyses')
    pass
    for additionalStructureAnalysis in additionalStructureAnalyses:
      topObject = additionalStructureAnalysis.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    calculationSteps = dataDict.get('calculationSteps').values()
    for calculationStep in calculationSteps:
      if (not (calculationStep in objsToBeDeleted)):
        objsToBeDeleted.add(calculationStep)
        objsToBeChecked.append(calculationStep)

    chains = dataDict.get('chains')
    pass
    for chain in chains:
      topObject = chain.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    conditionStates = dataDict.get('conditionStates').values()
    for conditionState in conditionStates:
      if (not (conditionState in objsToBeDeleted)):
        objsToBeDeleted.add(conditionState)
        objsToBeChecked.append(conditionState)

    constraintGroups = dataDict.get('constraintGroups').values()
    for constraintGroup in constraintGroups:
      if (not (constraintGroup in objsToBeDeleted)):
        objsToBeDeleted.add(constraintGroup)
        objsToBeChecked.append(constraintGroup)

    constraintLists = dataDict.get('constraintLists').values()
    for constraintList in constraintLists:
      if (not (constraintList in objsToBeDeleted)):
        objsToBeDeleted.add(constraintList)
        objsToBeChecked.append(constraintList)

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('cambridge.Dangle')
    tobjList = root.__dict__.get('dangleStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    dangleChains = dataDict.get('dangleChains')
    pass
    for dangleChain in dangleChains:
      topObject = dangleChain.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    data_s = dataDict.get('data').values()
    for data in data_s:
      if (not (data in objsToBeDeleted)):
        objsToBeDeleted.add(data)
        objsToBeChecked.append(data)

    dataSources = dataDict.get('dataSources')
    pass
    for dataSource in dataSources:
      topObject = dataSource.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    fixedAtomSets = dataDict.get('fixedAtomSets').values()
    for fixedAtomSet in fixedAtomSets:
      if (not (fixedAtomSet in objsToBeDeleted)):
        objsToBeDeleted.add(fixedAtomSet)
        objsToBeChecked.append(fixedAtomSet)

    fixedResonanceSets = dataDict.get('fixedResonanceSets').values()
    for fixedResonanceSet in fixedResonanceSets:
      if (not (fixedResonanceSet in objsToBeDeleted)):
        objsToBeDeleted.add(fixedResonanceSet)
        objsToBeChecked.append(fixedResonanceSet)

    fixedResonances = dataDict.get('fixedResonances').values()
    for fixedResonance in fixedResonances:
      if (not (fixedResonance in objsToBeDeleted)):
        objsToBeDeleted.add(fixedResonance)
        objsToBeChecked.append(fixedResonance)

    memopsRoot = dataDict.get('memopsRoot')
    if (memopsRoot is not None):
      topObject = memopsRoot.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrChains = dataDict.get('nmrChains')
    pass
    for nmrChain in nmrChains:
      topObject = nmrChain.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrProject = dataDict.get('nmrProject')
    if (nmrProject is not None):
      topObject = nmrProject.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    notes = dataDict.get('notes')
    pass
    for note in notes:
      topObject = note.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakLists = dataDict.get('peakLists')
    pass
    for peakList in peakLists:
      topObject = peakList.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    primaryStructureEnsemble = dataDict.get('primaryStructureEnsemble')
    if (primaryStructureEnsemble is not None):
      topObject = primaryStructureEnsemble.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    sampleComponents = dataDict.get('sampleComponents')
    pass
    for sampleComponent in sampleComponents:
      topObject = sampleComponent.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    samples = dataDict.get('samples')
    pass
    for sample in samples:
      topObject = sample.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    shiftLists = dataDict.get('shiftLists')
    pass
    for shiftList in shiftLists:
      topObject = shiftList.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    spectrumGroups = dataDict.get('spectrumGroups')
    pass
    for spectrumGroup in spectrumGroups:
      topObject = spectrumGroup.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    structureAnalyses = dataDict.get('structureAnalyses')
    pass
    for structureAnalysis in structureAnalyses:
      topObject = structureAnalysis.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    structureEnsembles = dataDict.get('structureEnsembles')
    pass
    for structureEnsemble in structureEnsembles:
      topObject = structureEnsemble.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    structureGenerations = dataDict.get('structureGenerations')
    pass
    for structureGeneration in structureGenerations:
      topObject = structureGeneration.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    validationStores = dataDict.get('validationStores')
    pass
    for validationStore in validationStores:
      topObject = validationStore.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    violationLists = dataDict.get('violationLists').values()
    for violationList in violationLists:
      if (not (violationList in objsToBeDeleted)):
        objsToBeDeleted.add(violationList)
        objsToBeChecked.append(violationList)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.NmrConstraintStore:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    memopsRoot = dataDict.get('memopsRoot')
    if (self is memopsRoot.__dict__.get('currentNmrConstraintStore')):
      memopsRoot.__dict__['currentNmrConstraintStore'] = None

    for additionalStructureAnalysis in dataDict.get('additionalStructureAnalyses'):
      if (not (additionalStructureAnalysis in objsToBeDeleted)):
        additionalConstraintStores = additionalStructureAnalysis.__dict__.get('additionalConstraintStores')
        additionalConstraintStores.remove(self)

    for chain in dataDict.get('chains'):
      if (not (chain in objsToBeDeleted)):
        chain.__dict__['nmrConstraintStore'] = None

    for dangleChain in dataDict.get('dangleChains'):
      if (not (dangleChain in objsToBeDeleted)):
        dangleChain.__dict__['nmrConstraintStore'] = None

    for dataSource in dataDict.get('dataSources'):
      if (not (dataSource in objsToBeDeleted)):
        dataSource.__dict__['nmrConstraintStore'] = None

    for nmrChain in dataDict.get('nmrChains'):
      if (not (nmrChain in objsToBeDeleted)):
        nmrChain.__dict__['nmrConstraintStore'] = None

    nmrProject = dataDict.get('nmrProject')
    if ((nmrProject is not None and not (nmrProject in objsToBeDeleted))):
      nmrConstraintStores = nmrProject.__dict__.get('nmrConstraintStores')
      nmrConstraintStores.remove(self)

    for note in dataDict.get('notes'):
      if (not (note in objsToBeDeleted)):
        note.__dict__['nmrConstraintStore'] = None

    for peakList in dataDict.get('peakLists'):
      if (not (peakList in objsToBeDeleted)):
        peakList.__dict__['nmrConstraintStore'] = None

    primaryStructureEnsemble = dataDict.get('primaryStructureEnsemble')
    if ((primaryStructureEnsemble is not None and not (primaryStructureEnsemble in objsToBeDeleted))):
      primaryStructureEnsemble.__dict__['primaryNmrConstraintStore'] = None

    for sampleComponent in dataDict.get('sampleComponents'):
      if (not (sampleComponent in objsToBeDeleted)):
        sampleComponent.__dict__['nmrConstraintStore'] = None

    for sample in dataDict.get('samples'):
      if (not (sample in objsToBeDeleted)):
        sample.__dict__['nmrConstraintStore'] = None

    for shiftList in dataDict.get('shiftLists'):
      if (not (shiftList in objsToBeDeleted)):
        shiftList.__dict__['nmrConstraintStore'] = None

    for spectrumGroup in dataDict.get('spectrumGroups'):
      if (not (spectrumGroup in objsToBeDeleted)):
        spectrumGroup.__dict__['nmrConstraintStore'] = None

    for structureAnalysis in dataDict.get('structureAnalyses'):
      if (not (structureAnalysis in objsToBeDeleted)):
        structureAnalysis.__dict__['nmrConstraintStore'] = None

    for structureEnsemble in dataDict.get('structureEnsembles'):
      if (not (structureEnsemble in objsToBeDeleted)):
        structureEnsemble.__dict__['nmrConstraintStore'] = None

    for structureGeneration in dataDict.get('structureGenerations'):
      if (not (structureGeneration in objsToBeDeleted)):
        structureGeneration.__dict__['nmrConstraintStore'] = None

    for validationStore in dataDict.get('validationStores'):
      if (not (validationStore in objsToBeDeleted)):
        validationStore.__dict__['nmrConstraintStore'] = None

    memopsRoot = dataDict.get('memopsRoot')
    if (not (memopsRoot in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = memopsRoot.__dict__.get('nmrConstraintStores')
        if (self is dd.get(objKey)):
          del dd[objKey]

    dataDict['calculationSteps'] = {}
    dataDict['conditionStates'] = {}
    dataDict['constraintGroups'] = {}
    dataDict['constraintLists'] = {}
    dataDict['data'] = {}
    dataDict['fixedAtomSets'] = {}
    dataDict['fixedResonanceSets'] = {}
    dataDict['fixedResonances'] = {}
    dataDict['violationLists'] = {}
  
  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.NmrConstraintStore:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    memopsRoot = dataDict.get('memopsRoot')

    childrenDict = memopsRoot.__dict__.get('nmrConstraintStores')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for additionalStructureAnalysis in dataDict.get('additionalStructureAnalyses'):
      if (not (additionalStructureAnalysis in objsToBeUnDeleted)):
        additionalConstraintStores = additionalStructureAnalysis.__dict__.get('additionalConstraintStores')
        additionalConstraintStores.add(self)

    for chain in dataDict.get('chains'):
      if (not (chain in objsToBeUnDeleted)):
        if (chain.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object chains link - backLink Chain.nmrConstraintStore is not None""" % self.qualifiedName
          )

        chain.__dict__['nmrConstraintStore'] = self

    for dangleChain in dataDict.get('dangleChains'):
      if (not (dangleChain in objsToBeUnDeleted)):
        if (dangleChain.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object dangleChains link - backLink DangleChain.nmrConstraintStore is not None""" % self.qualifiedName
          )

        dangleChain.__dict__['nmrConstraintStore'] = self

    for dataSource in dataDict.get('dataSources'):
      if (not (dataSource in objsToBeUnDeleted)):
        if (dataSource.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object dataSources link - backLink DataSource.nmrConstraintStore is not None""" % self.qualifiedName
          )

        dataSource.__dict__['nmrConstraintStore'] = self

    for nmrChain in dataDict.get('nmrChains'):
      if (not (nmrChain in objsToBeUnDeleted)):
        if (nmrChain.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object nmrChains link - backLink NmrChain.nmrConstraintStore is not None""" % self.qualifiedName
          )

        nmrChain.__dict__['nmrConstraintStore'] = self

    nmrProject = dataDict.get('nmrProject')
    if ((nmrProject is not None and not (nmrProject in objsToBeUnDeleted))):
      nmrConstraintStores = nmrProject.__dict__.get('nmrConstraintStores')
      nmrConstraintStores.add(self)

    for note in dataDict.get('notes'):
      if (not (note in objsToBeUnDeleted)):
        if (note.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object notes link - backLink Note.nmrConstraintStore is not None""" % self.qualifiedName
          )

        note.__dict__['nmrConstraintStore'] = self

    for peakList in dataDict.get('peakLists'):
      if (not (peakList in objsToBeUnDeleted)):
        if (peakList.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object peakLists link - backLink PeakList.nmrConstraintStore is not None""" % self.qualifiedName
          )

        peakList.__dict__['nmrConstraintStore'] = self

    primaryStructureEnsemble = dataDict.get('primaryStructureEnsemble')
    if ((primaryStructureEnsemble is not None and not (primaryStructureEnsemble in objsToBeUnDeleted))):
      if (primaryStructureEnsemble.__dict__.get('primaryNmrConstraintStore') is not None):
        raise ApiError("""%s._singleUnDelete:
         Error undoing delete of NmrConstraintStore object primaryStructureEnsemble link - backLink StructureEnsemble.primaryNmrConstraintStore is not None""" % self.qualifiedName
        )

      primaryStructureEnsemble.__dict__['primaryNmrConstraintStore'] = self

    for sampleComponent in dataDict.get('sampleComponents'):
      if (not (sampleComponent in objsToBeUnDeleted)):
        if (sampleComponent.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object sampleComponents link - backLink AbstractComponent.nmrConstraintStore is not None""" % self.qualifiedName
          )

        sampleComponent.__dict__['nmrConstraintStore'] = self

    for sample in dataDict.get('samples'):
      if (not (sample in objsToBeUnDeleted)):
        if (sample.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object samples link - backLink Sample.nmrConstraintStore is not None""" % self.qualifiedName
          )

        sample.__dict__['nmrConstraintStore'] = self

    for shiftList in dataDict.get('shiftLists'):
      if (not (shiftList in objsToBeUnDeleted)):
        if (shiftList.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object shiftLists link - backLink ShiftList.nmrConstraintStore is not None""" % self.qualifiedName
          )

        shiftList.__dict__['nmrConstraintStore'] = self

    for spectrumGroup in dataDict.get('spectrumGroups'):
      if (not (spectrumGroup in objsToBeUnDeleted)):
        if (spectrumGroup.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object spectrumGroups link - backLink SpectrumGroup.nmrConstraintStore is not None""" % self.qualifiedName
          )

        spectrumGroup.__dict__['nmrConstraintStore'] = self

    for structureAnalysis in dataDict.get('structureAnalyses'):
      if (not (structureAnalysis in objsToBeUnDeleted)):
        if (structureAnalysis.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object structureAnalyses link - backLink StructureAnalysis.nmrConstraintStore is not None""" % self.qualifiedName
          )

        structureAnalysis.__dict__['nmrConstraintStore'] = self

    for structureEnsemble in dataDict.get('structureEnsembles'):
      if (not (structureEnsemble in objsToBeUnDeleted)):
        if (structureEnsemble.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object structureEnsembles link - backLink StructureEnsemble.nmrConstraintStore is not None""" % self.qualifiedName
          )

        structureEnsemble.__dict__['nmrConstraintStore'] = self

    for structureGeneration in dataDict.get('structureGenerations'):
      if (not (structureGeneration in objsToBeUnDeleted)):
        if (structureGeneration.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object structureGenerations link - backLink StructureGeneration.nmrConstraintStore is not None""" % self.qualifiedName
          )

        structureGeneration.__dict__['nmrConstraintStore'] = self

    for validationStore in dataDict.get('validationStores'):
      if (not (validationStore in objsToBeUnDeleted)):
        if (validationStore.__dict__.get('nmrConstraintStore') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of NmrConstraintStore object validationStores link - backLink ValidationStore.nmrConstraintStore is not None""" % self.qualifiedName
          )

        validationStore.__dict__['nmrConstraintStore'] = self

    memopsRoot.__dict__['topObjects'][self.guid] = self
  
  def addAdditionalStructureAnalysis(self, value):
    """
    Add for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureAnalysis as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addAdditionalStructureAnalysis:
       value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('additionalStructureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAdditionalStructureAnalysis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAdditionalStructureAnalysis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addAdditionalStructureAnalysis:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addAdditionalStructureAnalysis:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addAdditionalStructureAnalysis:
           Link additionalStructureAnalyses between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('additionalConstraintStores')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAdditionalStructureAnalysis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAdditionalStructureAnalyses, self.addAdditionalStructureAnalysis,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addChain(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.chains
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Chain as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addChain:
       value is not of class ccp.molecule.MolSystem.Chain""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('chains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addChain:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addChain:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addChain:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addChain:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addChain:
           Link chains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('chains')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addChain')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addChain, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addDangleChain(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.cambridge.Dangle import DangleChain as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addDangleChain:
       value is not of class cambridge.Dangle.DangleChain""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dangleChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addDangleChain:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addDangleChain:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addDangleChain:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addDangleChain:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addDangleChain:
           Link dangleChains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      siblingValues = oldSelf.__dict__.get('dangleChains')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addDangleChain')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addDangleChain, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addDataSource(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.dataSources
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import DataSource as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addDataSource:
       value is not of class ccp.nmr.Nmr.DataSource""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dataSources')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addDataSource:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addDataSource:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addDataSource:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addDataSource:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addDataSource:
           Link dataSources between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('dataSources')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addDataSource')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addDataSource, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addNmrChain(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrChains
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrChain as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addNmrChain:
       value is not of class ccp.nmr.Nmr.NmrChain""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('nmrChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addNmrChain:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addNmrChain:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addNmrChain:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addNmrChain:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addNmrChain:
           Link nmrChains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('nmrChains')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addNmrChain')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addNmrChain, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addNote(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.notes
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Note as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addNote:
       value is not of class ccp.nmr.Nmr.Note""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('notes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addNote:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addNote:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addNote:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addNote:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addNote:
           Link notes between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('notes')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addNote')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addNote, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addPeakList(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.peakLists
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import PeakList as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addPeakList:
       value is not of class ccp.nmr.Nmr.PeakList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('peakLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addPeakList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addPeakList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addPeakList:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addPeakList:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addPeakList:
           Link peakLists between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('peakLists')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addPeakList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addPeakList, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addSample(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.samples
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.lims.Sample import Sample as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addSample:
       value is not of class ccp.lims.Sample.Sample""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('samples')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addSample:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addSample:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addSample:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addSample:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addSample:
           Link samples between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('samples')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addSample')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addSample, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addSampleComponent(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.sampleComponents
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.lims.RefSampleComponent import AbstractComponent as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addSampleComponent:
       value is not of class ccp.lims.RefSampleComponent.AbstractComponent""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('sampleComponents')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addSampleComponent:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addSampleComponent:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addSampleComponent:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addSampleComponent:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addSampleComponent:
           Link sampleComponents between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('sampleComponents')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addSampleComponent')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addSampleComponent, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addShiftList(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.shiftLists
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import ShiftList as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addShiftList:
       value is not of class ccp.nmr.Nmr.ShiftList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('shiftLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addShiftList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addShiftList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addShiftList:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addShiftList:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addShiftList:
           Link shiftLists between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('shiftLists')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addShiftList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addShiftList, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addSpectrumGroup(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.spectrumGroups
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import SpectrumGroup as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addSpectrumGroup:
       value is not of class ccp.nmr.Nmr.SpectrumGroup""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('spectrumGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addSpectrumGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addSpectrumGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addSpectrumGroup:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addSpectrumGroup:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addSpectrumGroup:
           Link spectrumGroups between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('spectrumGroups')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addSpectrumGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addSpectrumGroup, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addStructureAnalysis(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureAnalysis as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addStructureAnalysis:
       value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addStructureAnalysis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addStructureAnalysis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addStructureAnalysis:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addStructureAnalysis:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addStructureAnalysis:
           Link structureAnalyses between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('structureAnalyses')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addStructureAnalysis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addStructureAnalysis, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addStructureEnsemble(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.structureEnsembles
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import StructureEnsemble as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addStructureEnsemble:
       value is not of class ccp.molecule.MolStructure.StructureEnsemble""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureEnsembles')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addStructureEnsemble:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addStructureEnsemble:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addStructureEnsemble:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addStructureEnsemble:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addStructureEnsemble:
           Link structureEnsembles between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('structureEnsembles')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addStructureEnsemble')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addStructureEnsemble, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addStructureGeneration(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureGeneration as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addStructureGeneration:
       value is not of class ccp.nmr.Nmr.StructureGeneration""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureGenerations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addStructureGeneration:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addStructureGeneration:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addStructureGeneration:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addStructureGeneration:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addStructureGeneration:
           Link structureGenerations between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('structureGenerations')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addStructureGeneration')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addStructureGeneration, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  def addValidationStore(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.Validation import ValidationStore as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addValidationStore:
       value is not of class ccp.molecule.Validation.ValidationStore""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('validationStores')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.nmrConstraintStore}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addValidationStore:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addValidationStore:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addValidationStore:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addValidationStore:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addValidationStore:
           Link validationStores between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          if (not (self.nmrProject is value.nmrProject)):
            raise ApiError("""%s.addValidationStore:
             validationStores constraint self_nmrProject_is_value_nmrProject violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('validationStores')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addValidationStore')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addValidationStore, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(value,))

  backup = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.backup
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    self.checkValid(complete)
    values = dataDict.get('calculationSteps').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('conditionStates').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('constraintGroups').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('constraintLists').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('data').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('fixedAtomSets').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('fixedResonanceSets').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('fixedResonances').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('violationLists').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('memopsRoot')
        dd = value.__dict__.get('nmrConstraintStores')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'memopsRoot' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('_lastId')
      if (value is None):
        raise ApiError("""%s.checkValid: _lastId:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _lastId:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('createdBy')
      if (value is None):
        raise ApiError("""%s.checkValid: createdBy:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: createdBy:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('creationDate')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.DateTime.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.DateTime.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.DateTime.create(value)
        else:
          raise ApiError("""%s.checkValid: creationDate:
           memops.Implementation.DateTime input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('dataPath')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: dataPath:
           memops.Implementation.PathString input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value.find(chr(92)) == -1)):
          raise ApiError("""%s.checkValid: dataPath:
           PathString constraint contains_no_backslash violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: dataPath:
           PathString constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Page input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 4000):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Page maximum length is 4000 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Page: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('guid')
      if (value is None):
        raise ApiError("""%s.checkValid: guid:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: guid:
         GuidString constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      isValid = frozenset('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789-').issuperset(value)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: guid:
         GuidString constraint value_is_url_safe violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('isModifiable')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: isModifiable:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('lastUnlockedBy')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: name:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('programName')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: programName:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: programName:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: programName:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: programName:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('programVersion')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: programVersion:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: programVersion:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: programVersion:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: programVersion:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('uuid')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: uuid:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: uuid:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: uuid:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: uuid:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      values = dataDict.get('additionalStructureAnalyses')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureAnalysis as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: additionalStructureAnalyses:
           value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('additionalConstraintStores')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: additionalStructureAnalyses:
           non-reciprocal link additionalStructureAnalyses from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('calculationSteps').values()
      for value in values:
        if (not isinstance(value, CalculationStep)):
          raise ApiError("""%s.checkValid: calculationSteps:
           value is not of class ccp.nmr.NmrConstraint.CalculationStep""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: calculationSteps:
           non-reciprocal link calculationSteps from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('chains')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Chain as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: chains:
           value is not of class ccp.molecule.MolSystem.Chain""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: chains:
           non-reciprocal link chains from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: chains:
           Link chains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('conditionStates').values()
      for value in values:
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionStates:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: conditionStates:
           non-reciprocal link conditionStates from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups').values()
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintLists').values()
      for value in values:
        if (not isinstance(value, AbstractConstraintList)):
          raise ApiError("""%s.checkValid: constraintLists:
           value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraintLists:
           non-reciprocal link constraintLists from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('dangleChains')
      for value in values:
        from ccpnmodel.ccpncore.api.cambridge.Dangle import DangleChain as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: dangleChains:
           value is not of class cambridge.Dangle.DangleChain""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: dangleChains:
           non-reciprocal link dangleChains from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: dangleChains:
           Link dangleChains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('data').values()
      for value in values:
        if (not isinstance(value, Data)):
          raise ApiError("""%s.checkValid: data:
           value is not of class ccp.nmr.NmrConstraint.Data""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: data:
           non-reciprocal link data from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('dataSources')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import DataSource as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: dataSources:
           value is not of class ccp.nmr.Nmr.DataSource""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: dataSources:
           non-reciprocal link dataSources from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: dataSources:
           Link dataSources between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('fixedAtomSets').values()
      for value in values:
        if (not isinstance(value, FixedAtomSet)):
          raise ApiError("""%s.checkValid: fixedAtomSets:
           value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: fixedAtomSets:
           non-reciprocal link fixedAtomSets from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('fixedResonanceSets').values()
      for value in values:
        if (not isinstance(value, FixedResonanceSet)):
          raise ApiError("""%s.checkValid: fixedResonanceSets:
           value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: fixedResonanceSets:
           non-reciprocal link fixedResonanceSets from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('fixedResonances').values()
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: fixedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: fixedResonances:
           non-reciprocal link fixedResonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('memopsRoot')
      from ccpnmodel.ccpncore.api.memops.Implementation import MemopsRoot as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: memopsRoot:
         value is not of class memops.Implementation.MemopsRoot""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('nmrChains')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrChain as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrChains:
           value is not of class ccp.nmr.Nmr.NmrChain""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: nmrChains:
           non-reciprocal link nmrChains from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: nmrChains:
           Link nmrChains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrProject')
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrProject as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: nmrProject:
         value is not of class ccp.nmr.Nmr.NmrProject""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('nmrConstraintStores')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: nmrProject:
         non-reciprocal link nmrProject from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('notes')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Note as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: notes:
           value is not of class ccp.nmr.Nmr.Note""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: notes:
           non-reciprocal link notes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: notes:
           Link notes between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = self.getPackageLocator()
      if (value is None):
        raise ApiError("""%s.checkValid: packageLocator:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      from ccpnmodel.ccpncore.api.memops.Implementation import PackageLocator as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: packageLocator:
         value is not of class memops.Implementation.PackageLocator""" % self.qualifiedName
         + ": %s" % (value,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.checkValid: packageLocator:
         Link packageLocator between objects from separate partitions
          - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      values = dataDict.get('peakLists')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import PeakList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peakLists:
           value is not of class ccp.nmr.Nmr.PeakList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakLists:
           non-reciprocal link peakLists from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: peakLists:
           Link peakLists between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('primaryStructureEnsemble')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import StructureEnsemble as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: primaryStructureEnsemble:
           value is not of class ccp.molecule.MolStructure.StructureEnsemble""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('primaryNmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: primaryStructureEnsemble:
           non-reciprocal link primaryStructureEnsemble from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('sampleComponents')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.lims.RefSampleComponent import AbstractComponent as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: sampleComponents:
           value is not of class ccp.lims.RefSampleComponent.AbstractComponent""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: sampleComponents:
           non-reciprocal link sampleComponents from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: sampleComponents:
           Link sampleComponents between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('samples')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.lims.Sample import Sample as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: samples:
           value is not of class ccp.lims.Sample.Sample""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: samples:
           non-reciprocal link samples from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: samples:
           Link samples between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('shiftLists')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import ShiftList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: shiftLists:
           value is not of class ccp.nmr.Nmr.ShiftList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: shiftLists:
           non-reciprocal link shiftLists from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: shiftLists:
           Link shiftLists between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('spectrumGroups')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import SpectrumGroup as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: spectrumGroups:
           value is not of class ccp.nmr.Nmr.SpectrumGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: spectrumGroups:
           non-reciprocal link spectrumGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: spectrumGroups:
           Link spectrumGroups between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('structureAnalyses')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureAnalysis as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: structureAnalyses:
           value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: structureAnalyses:
           non-reciprocal link structureAnalyses from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: structureAnalyses:
           Link structureAnalyses between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('structureEnsembles')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import StructureEnsemble as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: structureEnsembles:
           value is not of class ccp.molecule.MolStructure.StructureEnsemble""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: structureEnsembles:
           non-reciprocal link structureEnsembles from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: structureEnsembles:
           Link structureEnsembles between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('structureGenerations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureGeneration as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: structureGenerations:
           value is not of class ccp.nmr.Nmr.StructureGeneration""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: structureGenerations:
           non-reciprocal link structureGenerations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: structureGenerations:
           Link structureGenerations between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('validationStores')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import ValidationStore as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: validationStores:
           value is not of class ccp.molecule.Validation.ValidationStore""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: validationStores:
           non-reciprocal link validationStores from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: validationStores:
           Link validationStores between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violationLists').values()
      for value in values:
        if (not isinstance(value, ViolationList)):
          raise ApiError("""%s.checkValid: violationLists:
           value is not of class ccp.nmr.NmrConstraint.ViolationList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violationLists:
           non-reciprocal link violationLists from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    if (dataDict.get('isLoaded')):
      # check explicit class constraints
      # check attributes
      values = dataDict.get('applicationData')
      for value in values:
        value.checkAllValid(complete)

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (not (value is None or isinstance(value, dict))):
          raise ApiError("""%s.checkValid: ccpnInternalData:
           ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('creationDate')
      value = dataDict.get('dataPath')
      value = dataDict.get('details')
      value = dataDict.get('isModifiable')
      if (value is None):
        raise ApiError("""%s.checkValid: isModifiable:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('name')
      value = dataDict.get('programName')
      value = dataDict.get('programVersion')
      value = dataDict.get('uuid')
      # check roles
      values = dataDict.get('additionalStructureAnalyses')
      values = dataDict.get('calculationSteps').values()
      values = dataDict.get('chains')
      values = dataDict.get('conditionStates').values()
      values = dataDict.get('constraintGroups').values()
      values = dataDict.get('constraintLists').values()
      values = dataDict.get('dangleChains')
      values = dataDict.get('data').values()
      values = dataDict.get('dataSources')
      values = dataDict.get('fixedAtomSets').values()
      values = dataDict.get('fixedResonanceSets').values()
      values = dataDict.get('fixedResonances').values()
      value = dataDict.get('memopsRoot')
      if (value is None):
        raise ApiError("""%s.checkValid: memopsRoot:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('nmrChains')
      value = dataDict.get('nmrProject')
      if (value is None):
        raise ApiError("""%s.checkValid: nmrProject:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('notes')
      values = dataDict.get('peakLists')
      value = dataDict.get('primaryStructureEnsemble')
      values = dataDict.get('sampleComponents')
      values = dataDict.get('samples')
      values = dataDict.get('shiftLists')
      values = dataDict.get('spectrumGroups')
      values = dataDict.get('structureAnalyses')
      values = dataDict.get('structureEnsembles')
      values = dataDict.get('structureGenerations')
      values = dataDict.get('validationStores')
      for value in values:
        if (not (self.nmrProject is value.nmrProject)):
          raise ApiError("""%s.checkValid: validationStores:
           validationStores constraint self_nmrProject_is_value_nmrProject violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('violationLists').values()
    else:
      # check unloaded TopObject
      value = dataDict.get('guid')
      if (value is None):
        raise ApiError("""%s.checkValid: guid:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllActiveRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.findAllActiveRepositories
  
  def findAllAdditionalStructureAnalyses(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('additionalStructureAnalyses')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('additionalStructureAnalyses')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'serial', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllCalculationSteps(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.calculationSteps
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('calculationSteps').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('calculationSteps').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'inputDataUuid', 'outputDataUuid', 'programName', 'programVersion', 'script', 'scriptName', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllChains(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.chains
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('chains')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('chains')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chemExchangeState', 'code', 'conformationalIsomer', 'details', 'magnEquivalenceCode', 'pdbOneLetterCode', 'physicalState', 'role', 'molSystem', 'molecule', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllConditionStates(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.conditionStates
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('conditionStates').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('conditionStates').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'dynamicAlignment', 'name', 'serial', 'staticAlignment', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllConstraintGroups(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintGroups').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintGroups').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllConstraintLists(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintLists').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintLists').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'origin', 'potentialType', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'method', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllDangleChains(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('dangleChains')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('dangleChains')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chain', 'dangleStore', 'nmrConstraintStore', 'shiftList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllData(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.data
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('data').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('data').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'attachedObjectPid', 'ccpnInternalData', 'name', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllDataSources(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.dataSources
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('dataSources')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('dataSources')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'dataType', 'details', 'isNormalStorage', 'isSimulated', 'name', 'negativeContourBase', 'negativeContourColour', 'negativeContourCount', 'negativeContourFactor', 'noiseLevel', 'numDim', 'numShapes', 'numSparsePoints', 'positiveContourBase', 'positiveContourColour', 'positiveContourCount', 'positiveContourFactor', 'recordNumber', 'scale', 'serial', 'signalLevel', 'sliceColour', 'storageDetails', 'activePeakList', 'compressMethod', 'dataStore', 'experiment', 'nmrConstraintStore', 'processMethod', 'processedFrom', 'snMethod',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllFixedAtomSets(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedAtomSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedAtomSets').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedAtomSets').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllFixedResonanceSets(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonanceSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonanceSets').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonanceSets').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllFixedResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonances').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonances').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllNmrChains(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrChains
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('nmrChains')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('nmrChains')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'implCode', 'isConnected', 'label', 'serial', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllNotes(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.notes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('notes')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('notes')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'created', 'implText', 'lastModified', 'name', 'serial', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllPeakLists(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.peakLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('peakLists')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('peakLists')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'dataType', 'details', 'isSimulated', 'name', 'serial', 'symbolColour', 'symbolStyle', 'textColour', 'dataSource', 'fitMethod', 'intensMethod', 'nmrConstraintStore', 'specificShiftList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllSampleComponents(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.sampleComponents
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('sampleComponents')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('sampleComponents')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'labeling', 'name', 'userCode', 'naturalSource', 'nmrConstraintStore', 'refSampleComponentStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllSamples(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.samples
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('samples')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('samples')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'amount', 'amountUnit', 'batchIdentifier', 'ccpnInternalData', 'colPosition', 'creationDate', 'details', 'ionicStrength', 'isHazardous', 'isVirtual', 'name', 'ph', 'plateIdentifier', 'rowPosition', 'serial', 'subPosition', 'nmrConstraintStore', 'sampleStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllShiftLists(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.shiftLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('shiftLists')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('shiftLists')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'autoUpdate', 'ccpnInternalData', 'details', 'isSimulated', 'name', 'serial', 'unit', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllSpectrumGroups(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.spectrumGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('spectrumGroups')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('spectrumGroups')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'serial', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStructureAnalyses(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureAnalyses')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureAnalyses')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'serial', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStructureEnsembles(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.structureEnsembles
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('structureEnsembles')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('structureEnsembles')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', '_lastId', 'atomNamingSystem', 'ccpnInternalData', 'createdBy', 'data', 'dataPath', 'details', 'ensembleId', 'guid', 'isModifiable', 'lastUnlockedBy', 'name', 'resNamingSystem', 'softwareName', 'memopsRoot', 'molSystem', 'nmrConstraintStore', 'primaryNmrConstraintStore', 'structureGeneration',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStructureGenerations(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureGenerations')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureGenerations')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'generationType', 'name', 'serial', 'method', 'nmrConstraintStore', 'nmrProject', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllValidationStores(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('validationStores')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('validationStores')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', '_lastId', 'ccpnInternalData', 'createdBy', 'guid', 'isModifiable', 'lastUnlockedBy', 'name', 'memopsRoot', 'nmrConstraintStore', 'nmrProject', 'software', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllViolationLists(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.violationLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('violationLists').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('violationLists').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstActiveRepository = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.findFirstActiveRepository
  
  def findFirstAdditionalStructureAnalysis(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('additionalStructureAnalyses')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('additionalStructureAnalyses')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'serial', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstCalculationStep(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.calculationSteps
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('calculationSteps').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('calculationSteps').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('calculationSteps').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'inputDataUuid', 'outputDataUuid', 'programName', 'programVersion', 'script', 'scriptName', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstChain(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.chains
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('chains')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('chains')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chemExchangeState', 'code', 'conformationalIsomer', 'details', 'magnEquivalenceCode', 'pdbOneLetterCode', 'physicalState', 'role', 'molSystem', 'molecule', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstConditionState(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.conditionStates
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('conditionStates').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('conditionStates').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('conditionStates').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'dynamicAlignment', 'name', 'serial', 'staticAlignment', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstConstraintGroup(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintGroups').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('constraintGroups').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('constraintGroups').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstConstraintList(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintLists').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('constraintLists').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('constraintLists').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'origin', 'potentialType', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'method', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstDangleChain(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('dangleChains')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('dangleChains')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chain', 'dangleStore', 'nmrConstraintStore', 'shiftList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstData(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.data
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('data').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('name')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('data').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('data').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'attachedObjectPid', 'ccpnInternalData', 'name', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstDataSource(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.dataSources
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('dataSources')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('dataSources')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'dataType', 'details', 'isNormalStorage', 'isSimulated', 'name', 'negativeContourBase', 'negativeContourColour', 'negativeContourCount', 'negativeContourFactor', 'noiseLevel', 'numDim', 'numShapes', 'numSparsePoints', 'positiveContourBase', 'positiveContourColour', 'positiveContourCount', 'positiveContourFactor', 'recordNumber', 'scale', 'serial', 'signalLevel', 'sliceColour', 'storageDetails', 'activePeakList', 'compressMethod', 'dataStore', 'experiment', 'nmrConstraintStore', 'processMethod', 'processedFrom', 'snMethod',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstFixedAtomSet(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedAtomSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedAtomSets').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('fixedAtomSets').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('fixedAtomSets').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstFixedResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonances').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('fixedResonances').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('fixedResonances').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstFixedResonanceSet(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonanceSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonanceSets').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('fixedResonanceSets').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('fixedResonanceSets').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstNmrChain(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrChains
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('nmrChains')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('nmrChains')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'implCode', 'isConnected', 'label', 'serial', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstNote(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.notes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('notes')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('notes')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'created', 'implText', 'lastModified', 'name', 'serial', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstPeakList(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.peakLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('peakLists')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('peakLists')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'dataType', 'details', 'isSimulated', 'name', 'serial', 'symbolColour', 'symbolStyle', 'textColour', 'dataSource', 'fitMethod', 'intensMethod', 'nmrConstraintStore', 'specificShiftList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstSample(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.samples
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('samples')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('samples')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'amount', 'amountUnit', 'batchIdentifier', 'ccpnInternalData', 'colPosition', 'creationDate', 'details', 'ionicStrength', 'isHazardous', 'isVirtual', 'name', 'ph', 'plateIdentifier', 'rowPosition', 'serial', 'subPosition', 'nmrConstraintStore', 'sampleStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstSampleComponent(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.sampleComponents
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('sampleComponents')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('sampleComponents')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'labeling', 'name', 'userCode', 'naturalSource', 'nmrConstraintStore', 'refSampleComponentStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstShiftList(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.shiftLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('shiftLists')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('shiftLists')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'autoUpdate', 'ccpnInternalData', 'details', 'isSimulated', 'name', 'serial', 'unit', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstSpectrumGroup(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.spectrumGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('spectrumGroups')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('spectrumGroups')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'serial', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStructureAnalysis(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureAnalyses')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureAnalyses')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'serial', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStructureEnsemble(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.NmrConstraintStore.structureEnsembles
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('structureEnsembles')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('structureEnsembles')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', '_lastId', 'atomNamingSystem', 'ccpnInternalData', 'createdBy', 'data', 'dataPath', 'details', 'ensembleId', 'guid', 'isModifiable', 'lastUnlockedBy', 'name', 'resNamingSystem', 'softwareName', 'memopsRoot', 'molSystem', 'nmrConstraintStore', 'primaryNmrConstraintStore', 'structureGeneration',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStructureGeneration(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureGenerations')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureGenerations')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'generationType', 'name', 'serial', 'method', 'nmrConstraintStore', 'nmrProject', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstValidationStore(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('validationStores')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('validationStores')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', '_lastId', 'ccpnInternalData', 'createdBy', 'guid', 'isModifiable', 'lastUnlockedBy', 'name', 'memopsRoot', 'nmrConstraintStore', 'nmrProject', 'software', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstViolationList(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.violationLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('violationLists').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('violationLists').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('violationLists').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'serial', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getActiveRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getActiveRepositories
  
  def getAdditionalStructureAnalyses(self):
    """
    Get for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('additionalStructureAnalyses')
    result = frozenset(tempVar)
    return result

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.NmrConstraintStore
    """

    result = None
    if (1 != len(fullKey)):
      raise ApiError("""'ccp.nmr.NmrConstraint.NmrConstraintStore'.getByKey:
       getByKey called with fullKey of wrong length. Parameters:"""
       + ": %s:%s" % (startObj, fullKey)
      )

    objKey = fullKey[0]
    obj1 = startObj.__dict__.get('nmrConstraintStores').get(objKey)
    if (obj1 is None):
      startObj.refreshTopObjects('ccp.nmr.NmrConstraint')
      obj1 = startObj.__dict__.get('nmrConstraintStores').get(objKey)

    result = obj1
    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation
  
  def getCalculationSteps(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.calculationSteps
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('calculationSteps').values()
    result = frozenset(tempVar)
    return result

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData
  
  def getChains(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.chains
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('chains')
    result = frozenset(tempVar)
    return result

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConditionStates(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.conditionStates
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('conditionStates').values()
    result = frozenset(tempVar)
    return result
  
  def getConstraintGroups(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('constraintGroups').values()
    result = frozenset(tempVar)
    return result
  
  def getConstraintLists(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('constraintLists').values()
    result = frozenset(tempVar)
    return result

  getCreatedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getCreatedBy
  
  def getCreationDate(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.creationDate
    """
    dataDict = self.__dict__
    result = dataDict.get('creationDate')
    return result
  
  def getDangleChains(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('cambridge.Dangle')
    tobjList = root.__dict__.get('dangleStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    tempVar = dataDict.get('dangleChains')
    result = frozenset(tempVar)
    return result
  
  def getData(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.data
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('data').values()
    result = frozenset(tempVar)
    return result
  
  def getDataPath(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.dataPath
    """
    dataDict = self.__dict__
    result = dataDict.get('dataPath')
    return result
  
  def getDataSources(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.dataSources
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('dataSources')
    result = frozenset(tempVar)
    return result
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFixedAtomSets(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedAtomSets
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('fixedAtomSets').values()
    result = frozenset(tempVar)
    return result
  
  def getFixedResonanceSets(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonanceSets
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('fixedResonanceSets').values()
    result = frozenset(tempVar)
    return result
  
  def getFixedResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonances
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('fixedResonances').values()
    result = frozenset(tempVar)
    return result
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    result = list()

    if (useGuid):
      result.append(dataDict.get('guid'))
    else:
      result.append(dataDict.get('serial'))

    return result

  getGuid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getGuid

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getIsLoaded = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsLoaded

  getIsModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsModifiable

  getIsModified = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsModified

  getIsReading = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsReading

  getLastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getLastUnlockedBy
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getMemopsRoot(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.memopsRoot
    """
    dataDict = self.__dict__
    result = dataDict.get('memopsRoot')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrChains(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrChains
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('nmrChains')
    result = frozenset(tempVar)
    return result
  
  def getNmrProject(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrProject')
    return result
  
  def getNotes(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.notes
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('notes')
    result = frozenset(tempVar)
    return result

  getPackageLocator = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getPackageLocator

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('memopsRoot')
    return result
  
  def getPeakLists(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.peakLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('peakLists')
    result = frozenset(tempVar)
    return result
  
  def getPrimaryStructureEnsemble(self):
    """
    Get for
    ccp.nmr.NmrConstraint.NmrConstraintStore.primaryStructureEnsemble
    """
    dataDict = self.__dict__
    result = dataDict.get('primaryStructureEnsemble')
    return result
  
  def getProgramName(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.programName
    """
    dataDict = self.__dict__
    result = dataDict.get('programName')
    return result
  
  def getProgramVersion(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.programVersion
    """
    dataDict = self.__dict__
    result = dataDict.get('programVersion')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSampleComponents(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.sampleComponents
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('sampleComponents')
    result = frozenset(tempVar)
    return result
  
  def getSamples(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.samples
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('samples')
    result = frozenset(tempVar)
    return result
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getShiftLists(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.shiftLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('shiftLists')
    result = frozenset(tempVar)
    return result
  
  def getSpectrumGroups(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.spectrumGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('spectrumGroups')
    result = frozenset(tempVar)
    return result
  
  def getStructureAnalyses(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('structureAnalyses')
    result = frozenset(tempVar)
    return result
  
  def getStructureEnsembles(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.structureEnsembles
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('structureEnsembles')
    result = frozenset(tempVar)
    return result
  
  def getStructureGenerations(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('structureGenerations')
    result = frozenset(tempVar)
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUuid(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.uuid
    """
    dataDict = self.__dict__
    result = dataDict.get('uuid')
    return result
  
  def getValidationStores(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('validationStores')
    result = frozenset(tempVar)
    return result
  
  def getViolationLists(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.violationLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('violationLists').values()
    result = frozenset(tempVar)
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  get_lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.get_lastId

  load = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.load

  loadFrom = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.loadFrom
  
  def newCalculationStep(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.CalculationStep
    """
    return CalculationStep(self, **attrlinks)
  
  def newChemicalShiftConstraintList(self, **attrlinks):
    """
    Factory function to create
    ccp.nmr.NmrConstraint.ChemicalShiftConstraintList
    """
    return ChemicalShiftConstraintList(self, **attrlinks)
  
  def newConditionState(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ConditionState
    """
    return ConditionState(self, **attrlinks)
  
  def newConstraintGroup(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ConstraintGroup
    """
    return ConstraintGroup(self, **attrlinks)
  
  def newCsaConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.CsaConstraintList
    """
    return CsaConstraintList(self, **attrlinks)
  
  def newData(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.Data
    """
    return Data(self, **attrlinks)
  
  def newDihedralConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    return DihedralConstraintList(self, **attrlinks)
  
  def newDistanceConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    return DistanceConstraintList(self, **attrlinks)
  
  def newFixedAtomSet(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.FixedAtomSet
    """
    return FixedAtomSet(self, **attrlinks)
  
  def newFixedResonance(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.FixedResonance
    """
    return FixedResonance(self, **attrlinks)
  
  def newFixedResonanceSet(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    return FixedResonanceSet(self, **attrlinks)
  
  def newGenericConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.GenericConstraintList
    """
    return GenericConstraintList(self, **attrlinks)
  
  def newHBondConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.HBondConstraintList
    """
    return HBondConstraintList(self, **attrlinks)
  
  def newJCouplingConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    return JCouplingConstraintList(self, **attrlinks)
  
  def newRdcConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.RdcConstraintList
    """
    return RdcConstraintList(self, **attrlinks)
  
  def newViolationList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ViolationList
    """
    return ViolationList(self, **attrlinks)
  
  def removeAdditionalStructureAnalysis(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureAnalysis as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeAdditionalStructureAnalysis:
       value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('additionalStructureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAdditionalStructureAnalysis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAdditionalStructureAnalysis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeAdditionalStructureAnalysis:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAdditionalStructureAnalysis:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('additionalConstraintStores')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAdditionalStructureAnalysis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAdditionalStructureAnalyses, self.removeAdditionalStructureAnalysis,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeChain(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.chains
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Chain as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeChain:
       value is not of class ccp.molecule.MolSystem.Chain""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('chains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeChain:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeChain:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeChain:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeChain:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeChain')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setChains, self.removeChain,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeDangleChain(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.cambridge.Dangle import DangleChain as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeDangleChain:
       value is not of class cambridge.Dangle.DangleChain""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dangleChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeDangleChain:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeDangleChain:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeDangleChain:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeDangleChain:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeDangleChain')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDangleChains, self.removeDangleChain,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeDataSource(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.dataSources
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import DataSource as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeDataSource:
       value is not of class ccp.nmr.Nmr.DataSource""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dataSources')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeDataSource:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeDataSource:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeDataSource:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeDataSource:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeDataSource')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDataSources, self.removeDataSource,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  removeFrom = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.removeFrom
  
  def removeNmrChain(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrChains
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrChain as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeNmrChain:
       value is not of class ccp.nmr.Nmr.NmrChain""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('nmrChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeNmrChain:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeNmrChain:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeNmrChain:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeNmrChain:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeNmrChain')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNmrChains, self.removeNmrChain,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeNote(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.notes
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Note as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeNote:
       value is not of class ccp.nmr.Nmr.Note""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('notes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeNote:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeNote:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeNote:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeNote:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeNote')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNotes, self.removeNote,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removePeakList(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.peakLists
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import PeakList as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removePeakList:
       value is not of class ccp.nmr.Nmr.PeakList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('peakLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removePeakList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removePeakList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removePeakList:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removePeakList:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removePeakList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPeakLists, self.removePeakList,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeSample(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.samples
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.lims.Sample import Sample as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeSample:
       value is not of class ccp.lims.Sample.Sample""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('samples')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeSample:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeSample:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeSample:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeSample:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeSample')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSamples, self.removeSample,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeSampleComponent(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.sampleComponents
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.lims.RefSampleComponent import AbstractComponent as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeSampleComponent:
       value is not of class ccp.lims.RefSampleComponent.AbstractComponent""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('sampleComponents')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeSampleComponent:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeSampleComponent:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeSampleComponent:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeSampleComponent:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeSampleComponent')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSampleComponents, self.removeSampleComponent,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeShiftList(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.shiftLists
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import ShiftList as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeShiftList:
       value is not of class ccp.nmr.Nmr.ShiftList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('shiftLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeShiftList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeShiftList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeShiftList:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeShiftList:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeShiftList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setShiftLists, self.removeShiftList,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeSpectrumGroup(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.spectrumGroups
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import SpectrumGroup as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeSpectrumGroup:
       value is not of class ccp.nmr.Nmr.SpectrumGroup""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('spectrumGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeSpectrumGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeSpectrumGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeSpectrumGroup:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeSpectrumGroup:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeSpectrumGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSpectrumGroups, self.removeSpectrumGroup,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeStructureAnalysis(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureAnalysis as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeStructureAnalysis:
       value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeStructureAnalysis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeStructureAnalysis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeStructureAnalysis:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeStructureAnalysis:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeStructureAnalysis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setStructureAnalyses, self.removeStructureAnalysis,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeStructureEnsemble(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.structureEnsembles
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import StructureEnsemble as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeStructureEnsemble:
       value is not of class ccp.molecule.MolStructure.StructureEnsemble""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureEnsembles')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeStructureEnsemble:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeStructureEnsemble:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeStructureEnsemble:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeStructureEnsemble:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeStructureEnsemble')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setStructureEnsembles, self.removeStructureEnsemble,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeStructureGeneration(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureGeneration as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeStructureGeneration:
       value is not of class ccp.nmr.Nmr.StructureGeneration""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureGenerations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeStructureGeneration:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeStructureGeneration:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeStructureGeneration:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeStructureGeneration:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeStructureGeneration')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setStructureGenerations, self.removeStructureGeneration,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeValidationStore(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.Validation import ValidationStore as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeValidationStore:
       value is not of class ccp.molecule.Validation.ValidationStore""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('validationStores')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeValidationStore:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeValidationStore:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeValidationStore:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeValidationStore:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeValidationStore')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setValidationStores, self.removeValidationStore,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  restore = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.restore

  save = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.save

  saveTo = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.saveTo
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    setattr(self, name, value)
  
  def setAdditionalStructureAnalyses(self, values):
    """
    Set for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAdditionalStructureAnalyses:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureAnalysis as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setAdditionalStructureAnalyses:
         value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('additionalStructureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAdditionalStructureAnalyses:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAdditionalStructureAnalyses:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAdditionalStructureAnalyses:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAdditionalStructureAnalyses:
           Link additionalStructureAnalyses between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('additionalConstraintStores')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('additionalConstraintStores')
        oldSelves.add(self)

    dataDict['additionalStructureAnalyses'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAdditionalStructureAnalyses')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAdditionalStructureAnalyses, self.setAdditionalStructureAnalyses,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setChains(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.chains
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setChains:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.molecule.MolSystem import Chain as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setChains:
         value is not of class ccp.molecule.MolSystem.Chain""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('chains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setChains:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setChains:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChains:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setChains:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setChains:
           Link chains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('chains')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['chains'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setChains')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setChains, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  setCreatedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setCreatedBy
  
  def setCreationDate(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.creationDate
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.DateTime.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.DateTime.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.DateTime.create(value)
      else:
        raise ApiError("""%s.setCreationDate:
         memops.Implementation.DateTime input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('creationDate')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCreationDate:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCreationDate:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['creationDate'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCreationDate')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCreationDate, self.setCreationDate,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setDangleChains(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setDangleChains:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.cambridge.Dangle import DangleChain as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setDangleChains:
         value is not of class cambridge.Dangle.DangleChain""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dangleChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setDangleChains:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDangleChains:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDangleChains:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setDangleChains:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setDangleChains:
           Link dangleChains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('dangleChains')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['dangleChains'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDangleChains')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setDangleChains, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setDataPath(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.dataPath
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDataPath:
         memops.Implementation.PathString input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value.find(chr(92)) == -1)):
        raise ApiError("""%s.setDataPath:
         PathString constraint contains_no_backslash violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setDataPath:
         PathString constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('dataPath')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDataPath:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDataPath:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['dataPath'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDataPath')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDataPath, self.setDataPath,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setDataSources(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.dataSources
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setDataSources:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import DataSource as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setDataSources:
         value is not of class ccp.nmr.Nmr.DataSource""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dataSources')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setDataSources:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDataSources:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDataSources:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setDataSources:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setDataSources:
           Link dataSources between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('dataSources')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['dataSources'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDataSources')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setDataSources, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.Page input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 4000):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Page maximum length is 4000 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Page: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setGuid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setGuid

  setIsModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setIsModifiable

  setLastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setLastUnlockedBy
  
  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setName:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setName:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setName, self.setName,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setNmrChains(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrChains
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setNmrChains:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrChain as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setNmrChains:
         value is not of class ccp.nmr.Nmr.NmrChain""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('nmrChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setNmrChains:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNmrChains:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrChains:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrChains:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setNmrChains:
           Link nmrChains between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('nmrChains')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['nmrChains'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNmrChains')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setNmrChains, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setNmrProject(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrProject as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.setNmrProject:
       value is not of class ccp.nmr.Nmr.NmrProject""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('nmrProject')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrProject:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrProject:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setNmrProject:
         cannot set nmrProject, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setNmrProject:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setNmrProject:
         Link nmrProject between objects from separate partitions
          - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('nmrConstraintStores')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setNmrProject:
         Read link 'nmrProject' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('nmrConstraintStores')
      newSelves.add(self)

    dataDict['nmrProject'] = value

    # doNotifies
  
  def setNotes(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.notes
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setNotes:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Note as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setNotes:
         value is not of class ccp.nmr.Nmr.Note""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('notes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setNotes:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNotes:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNotes:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNotes:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setNotes:
           Link notes between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('notes')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['notes'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNotes')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setNotes, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setPeakLists(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.peakLists
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setPeakLists:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import PeakList as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setPeakLists:
         value is not of class ccp.nmr.Nmr.PeakList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('peakLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setPeakLists:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPeakLists:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakLists:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPeakLists:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setPeakLists:
           Link peakLists between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('peakLists')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['peakLists'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPeakLists')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setPeakLists, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setPrimaryStructureEnsemble(self, value):
    """
    Set for
    ccp.nmr.NmrConstraint.NmrConstraintStore.primaryStructureEnsemble
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import StructureEnsemble as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setPrimaryStructureEnsemble:
         value is not of class ccp.molecule.MolStructure.StructureEnsemble""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('primaryStructureEnsemble')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      if (value is not None):
        topObject = value.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)
        oldSelf = value.__dict__.get('primaryNmrConstraintStore')
        if (oldSelf is not None):
          if (notIsReading):
            topObject = oldSelf.__dict__.get('topObject')
            topObjectsToCheck.add(topObject)
          else:
            raise ApiError("""%s.setPrimaryStructureEnsemble:
             Read link incompatible with pre-existing link""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (currentValue is not None):
        topObject = currentValue.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPrimaryStructureEnsemble:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPrimaryStructureEnsemble:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPrimaryStructureEnsemble:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setPrimaryStructureEnsemble:
           Link primaryStructureEnsemble between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      currentValue.__dict__['primaryNmrConstraintStore'] = None

    if (value is not None):
      oldSelf = value.__dict__.get('primaryNmrConstraintStore')
      if (oldSelf is not None):
        oldSelf.__dict__['primaryStructureEnsemble'] = None

      value.__dict__['primaryNmrConstraintStore'] = self

    dataDict['primaryStructureEnsemble'] = value
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPrimaryStructureEnsemble')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPrimaryStructureEnsemble, self.setPrimaryStructureEnsemble,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setProgramName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.programName
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setProgramName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setProgramName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setProgramName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setProgramName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('programName')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setProgramName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setProgramName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['programName'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setProgramName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setProgramName, self.setProgramName,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setProgramVersion(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.programVersion
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setProgramVersion:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setProgramVersion:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setProgramVersion:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setProgramVersion:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('programVersion')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setProgramVersion:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setProgramVersion:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['programVersion'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setProgramVersion')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setProgramVersion, self.setProgramVersion,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSampleComponents(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.sampleComponents
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setSampleComponents:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.lims.RefSampleComponent import AbstractComponent as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setSampleComponents:
         value is not of class ccp.lims.RefSampleComponent.AbstractComponent""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('sampleComponents')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setSampleComponents:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSampleComponents:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSampleComponents:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setSampleComponents:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setSampleComponents:
           Link sampleComponents between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('sampleComponents')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['sampleComponents'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSampleComponents')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setSampleComponents, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setSamples(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.samples
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setSamples:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.lims.Sample import Sample as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setSamples:
         value is not of class ccp.lims.Sample.Sample""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('samples')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setSamples:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSamples:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSamples:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setSamples:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setSamples:
           Link samples between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('samples')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['samples'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSamples')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setSamples, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('memopsRoot')
    oldSerial = parent.__dict__.get('_serialDict').get('nmrConstraintStores')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['nmrConstraintStores'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['nmrConstraintStores'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setShiftLists(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.shiftLists
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setShiftLists:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import ShiftList as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setShiftLists:
         value is not of class ccp.nmr.Nmr.ShiftList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('shiftLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setShiftLists:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setShiftLists:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setShiftLists:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setShiftLists:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setShiftLists:
           Link shiftLists between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('shiftLists')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['shiftLists'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setShiftLists')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setShiftLists, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setSpectrumGroups(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.spectrumGroups
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setSpectrumGroups:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import SpectrumGroup as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setSpectrumGroups:
         value is not of class ccp.nmr.Nmr.SpectrumGroup""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('spectrumGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setSpectrumGroups:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSpectrumGroups:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSpectrumGroups:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setSpectrumGroups:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setSpectrumGroups:
           Link spectrumGroups between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('spectrumGroups')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['spectrumGroups'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSpectrumGroups')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setSpectrumGroups, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setStructureAnalyses(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setStructureAnalyses:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureAnalysis as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setStructureAnalyses:
         value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setStructureAnalyses:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStructureAnalyses:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStructureAnalyses:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setStructureAnalyses:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setStructureAnalyses:
           Link structureAnalyses between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('structureAnalyses')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['structureAnalyses'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStructureAnalyses')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setStructureAnalyses, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setStructureEnsembles(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.structureEnsembles
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setStructureEnsembles:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import StructureEnsemble as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setStructureEnsembles:
         value is not of class ccp.molecule.MolStructure.StructureEnsemble""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureEnsembles')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setStructureEnsembles:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStructureEnsembles:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStructureEnsembles:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setStructureEnsembles:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setStructureEnsembles:
           Link structureEnsembles between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('structureEnsembles')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['structureEnsembles'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStructureEnsembles')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setStructureEnsembles, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setStructureGenerations(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setStructureGenerations:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import StructureGeneration as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setStructureGenerations:
         value is not of class ccp.nmr.Nmr.StructureGeneration""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureGenerations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setStructureGenerations:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStructureGenerations:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStructureGenerations:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setStructureGenerations:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setStructureGenerations:
           Link structureGenerations between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('structureGenerations')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['structureGenerations'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStructureGenerations')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setStructureGenerations, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  def setUuid(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.uuid
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setUuid:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setUuid:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setUuid:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setUuid:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('uuid')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUuid:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUuid:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['uuid'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUuid')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUuid, self.setUuid,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setValidationStores(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setValidationStores:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.molecule.Validation import ValidationStore as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setValidationStores:
         value is not of class ccp.molecule.Validation.ValidationStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('validationStores')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.nmrConstraintStore) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setValidationStores:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setValidationStores:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setValidationStores:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setValidationStores:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setValidationStores:
           Link validationStores between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          if (not (self.nmrProject is value.nmrProject)):
            raise ApiError("""%s.setValidationStores:
             validationStores constraint self_nmrProject_is_value_nmrProject violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('validationStores')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['validationStores'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setValidationStores')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setValidationStores, undoArgs=(undoValueDict, 'nmrConstraintStore'),  redoArgs=(values,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  set_lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.set_lastId
  
  def sortedAdditionalStructureAnalyses(self):
    """
    Sorted for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('additionalStructureAnalyses')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedCalculationSteps(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.calculationSteps
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('calculationSteps')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedChains(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.chains
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('chains')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedConditionStates(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.conditionStates
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('conditionStates')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedConstraintGroups(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('constraintGroups')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedConstraintLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('constraintLists')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedDangleChains(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('cambridge.Dangle')
    tobjList = root.__dict__.get('dangleStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    ll = dataDict.get('dangleChains')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedData(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.data
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('data')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedDataSources(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.dataSources
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('dataSources')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedFixedAtomSets(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedAtomSets
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('fixedAtomSets')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedFixedResonanceSets(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonanceSets
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('fixedResonanceSets')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedFixedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonances
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('fixedResonances')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedNmrChains(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrChains
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('nmrChains')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedNotes(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.notes
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('notes')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedPeakLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.peakLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('peakLists')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedSampleComponents(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.sampleComponents
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('sampleComponents')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedSamples(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.samples
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('samples')
    ll = [(repr(x),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedShiftLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.shiftLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('shiftLists')
    ll = [(repr(x),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedSpectrumGroups(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.spectrumGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('spectrumGroups')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedStructureAnalyses(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('structureAnalyses')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedStructureEnsembles(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.structureEnsembles
    """
    dataDict = self.__dict__
    ll = dataDict.get('structureEnsembles')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedStructureGenerations(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('structureGenerations')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedValidationStores(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    ll = dataDict.get('validationStores')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedViolationLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.violationLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('violationLists')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  touch = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.touch

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  _lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject._lastId

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  createdBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.createdBy
  
  creationDate = property(getCreationDate, setCreationDate, None,
  r"""Time for DataSet export - set when the finished data set is exported, 
  not when the object is first created.
  """)
  
  dataPath = property(getDataPath, setDataPath, None,
  r"""Path to DataSet file. If relative is taken relative to the project rot 
  directory (projName.ccpn)
  """)
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  guid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.guid

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  isLoaded = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isLoaded

  isModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isModifiable

  isModified = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isModified

  isReading = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isReading

  lastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.lastUnlockedBy

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""DataSet name.
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  programName = property(getProgramName, setProgramName, None,
  r"""Name of originating program
  """)
  
  programVersion = property(getProgramVersion, setProgramVersion, None,
  r"""Version of originating program
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  uuid = property(getUuid, setUuid, None,
  r"""UNiversal identifier for DataSet - set when the finished data set is 
  exported, not when the object is first created.
  """)

  activeRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.activeRepositories
  
  additionalStructureAnalyses = property(getAdditionalStructureAnalyses, setAdditionalStructureAnalyses, None,
  r"""STructureAnaylsis that use the NmrConstraintStore for additional data
  """)
  
  calculationSteps = property(getCalculationSteps,  None, None,
  r"""child link to class CalculationStep
  """)
  
  chains = property(getChains, setChains, None,
  r"""chains attached to DataSet
  """)
  
  conditionStates = property(getConditionStates,  None, None,
  r"""child link to class ConditionState
  """)
  
  constraintGroups = property(getConstraintGroups,  None, None,
  r"""child link to class ConstraintGroup
  """)
  
  constraintLists = property(getConstraintLists,  None, None,
  r"""child link to class AbstractConstraintList
  """)
  
  dangleChains = property(getDangleChains, setDangleChains, None,
  r"""Dangle predictions that have exported constraints to the ConstaintSet
  """)
  
  data = property(getData,  None, None,
  r"""child link to class Data
  """)
  
  dataSources = property(getDataSources, setDataSources, None,
  r"""DataSources attached to DataSet
  """)
  
  fixedAtomSets = property(getFixedAtomSets,  None, None,
  r"""child link to class FixedAtomSet
  """)
  
  fixedResonanceSets = property(getFixedResonanceSets,  None, None,
  r"""child link to class FixedResonanceSet
  """)
  
  fixedResonances = property(getFixedResonances,  None, None,
  r"""child link to class FixedResonance
  """)
  
  memopsRoot = property(getMemopsRoot,  None, None,
  r"""parent link
  """)
  
  nmrChains = property(getNmrChains, setNmrChains, None,
  r"""NmrChains attached to DataSet
  """)
  
  nmrProject = property(getNmrProject, setNmrProject, None,
  r"""NmrProject to which the NmrConstraintStore refers
  """)
  
  notes = property(getNotes, setNotes, None,
  r"""notes attached to DataSet
  """)

  packageLocator = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.packageLocator
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for memopsRoot
  """)
  
  peakLists = property(getPeakLists, setPeakLists, None,
  r"""PeakLists attached to DataSet
  """)
  
  primaryStructureEnsemble = property(getPrimaryStructureEnsemble, setPrimaryStructureEnsemble, None,
  r"""Primary StructureEnsemble for DataSet - matching the coordinateDataPath 
  in a NEF file. NB the primary StructureEnsemble may or may not be in the 
  structureEnsembles link
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  sampleComponents = property(getSampleComponents, setSampleComponents, None,
  r"""SampleComponents attached to DataSet
  """)
  
  samples = property(getSamples, setSamples, None,
  r"""Samples attached to DataSet
  """)
  
  shiftLists = property(getShiftLists, setShiftLists, None,
  r"""ShiftLists attached to DataSet
  """)
  
  spectrumGroups = property(getSpectrumGroups, setSpectrumGroups, None,
  r"""SpectrumGroups attached to DataSet
  """)
  
  structureAnalyses = property(getStructureAnalyses, setStructureAnalyses, None,
  r"""StructureAnalyses that user NmrConstraintStore as proimary set of 
  restraints
  """)
  
  structureEnsembles = property(getStructureEnsembles, setStructureEnsembles, None,
  r"""
  """)
  
  structureGenerations = property(getStructureGenerations, setStructureGenerations, None,
  r"""StructureGenerations run with constraints held by NmrConstraintStore
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject
  
  validationStores = property(getValidationStores, setValidationStores, None,
  r"""NmrConstraintStores relevant to NmrProject
  """)
  
  violationLists = property(getViolationLists,  None, None,
  r"""child link to class ViolationList
  """)

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.NmrConstraintStore', NmrConstraintStore)

###############################################################################
class PairwiseConstraintItem(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""ConstraintItem that takes an unordered pair of FixedResonances as its 
key
  """
  #   from data model element ccp.nmr.NmrConstraint.PairwiseConstraintItem
  _metaclass = metaPackage.getElement('PairwiseConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'firstResonance', 'orderedResonances', 'resonances', 'root', 'topObject',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addOrderedResonance(self, value):
    """
    Add for ccp.nmr.NmrConstraint.PairwiseConstraintItem.orderedResonances
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.addOrderedResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedResonances()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addOrderedResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addOrderedResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addOrderedResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addOrderedResonance:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setOrderedResonances(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addOrderedResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedResonances, self.addOrderedResonance,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllOrderedResonances(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.PairwiseConstraintItem.orderedResonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedResonances()
      result = list(currentValues)

    else:
      currentValues = self.getOrderedResonances()
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstOrderedResonance(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.PairwiseConstraintItem.orderedResonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedResonances()
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = self.getOrderedResonances()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFirstResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.PairwiseConstraintItem.firstResonance
    """
    dataDict = self.__dict__
    result = dataDict.get('firstResonance')
    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getOrderedResonances(self):
    """
    getter for derived link orderedResonances
    """
    dataDict = self.__dict__
    first = self.firstResonance
    if first:
      result = tuple(self.resonances)
      if first is result[1]:
        result = (result[1], result[0])
    else:
      result = ()
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeOrderedResonance(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.PairwiseConstraintItem.orderedResonances
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.removeOrderedResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedResonances()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeOrderedResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeOrderedResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeOrderedResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeOrderedResonance:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setOrderedResonances(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeOrderedResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedResonances, self.removeOrderedResonance,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setFirstResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.PairwiseConstraintItem.firstResonance
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setFirstResonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('firstResonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setFirstResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setFirstResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setFirstResonance:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setFirstResonance:
           Link firstResonance between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          if (not (value in self.resonances)):
            raise ApiError("""%s.setFirstResonance:
             firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['firstResonance'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setFirstResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setFirstResonance, self.setFirstResonance,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setOrderedResonances(self, values):
    """
    getter for derived link orderedResonances
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setOrderedResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setOrderedResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedResonances()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOrderedResonances:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOrderedResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setOrderedResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.resonances = values
      for val in values:
        break
      self.firstResonance = val
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOrderedResonances')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedResonances, self.setOrderedResonances,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 2)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('pairwiseConstraintItems')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('pairwiseConstraintItems')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  firstResonance = property(getFirstResonance, setFirstResonance, None,
  r"""First resonance of the two in 'resonances'. Used to define ordering of 
  resonances. 
  """)
  
  orderedResonances = property(getOrderedResonances, setOrderedResonances, None,
  r"""Resonance pair in order. Optional, as order may not be defined.
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""Pair of resonances constrained in the PairWiseConstraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.PairwiseConstraintItem', PairwiseConstraintItem)

###############################################################################
class Parameter(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""
  """
  #   from data model element ccp.nmr.NmrConstraint.Parameter
  _metaclass = metaPackage.getElement('Parameter')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'value', 'data', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.Parameter
    """
    dataDict = self.__dict__
    dataDict['data'] = parent
    if (not isinstance(parent, Data)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.Data""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['name'] = None
      dataDict['value'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.Parameter', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.Parameter.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('parameters')
        objKey = dataDict.get('name')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['name'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.Parameter:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.Parameter:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    data = dataDict.get('data')
    if (not (data in objsToBeDeleted)):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = data.__dict__.get('parameters')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.Parameter:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    data = dataDict.get('data')
    if (not (data in objsToBeUnDeleted)):

      childrenDict = data.__dict__.get('parameters')
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['name'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.Parameter
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.Parameter
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('data')
        dd = value.__dict__.get('parameters')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'data' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: name:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('value')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: value:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      value = dataDict.get('data')
      if (not isinstance(value, Data)):
        raise ApiError("""%s.checkValid: data:
         value is not of class ccp.nmr.NmrConstraint.Data""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('name')
    if (value is None):
      raise ApiError("""%s.checkValid: name:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('value')
    # check roles
    value = dataDict.get('data')
    if (value is None):
      raise ApiError("""%s.checkValid: data:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.Parameter
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.Parameter
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.Parameter'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.Parameter'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('data').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('parameters').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getData(self):
    """
    Get for ccp.nmr.NmrConstraint.Parameter.data
    """
    dataDict = self.__dict__
    result = dataDict.get('data')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.Parameter
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('data')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('name'))
    result.append(dataDict.get('name'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.Parameter
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.Parameter.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.Parameter.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('data')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getValue(self):
    """
    Get for ccp.nmr.NmrConstraint.Parameter.value
    """
    dataDict = self.__dict__
    result = dataDict.get('value')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.Parameter
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Parameter.name
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setName:
       memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 80):
      raise ApiError("""%s.setName:
       memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setName:
       memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.splitlines()) <= 1)):
      raise ApiError("""%s.setName:
       Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setName:
         cannot set name, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['name'] = value

    # doNotifies
  
  def setValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Parameter.value
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
        pass
      else:
        raise ApiError("""%s.setValue:
         memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('value')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setValue:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['value'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setValue, self.setValue,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of parameter - key for object.
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  value = property(getValue, setValue, None,
  r"""Parameter value - can be of any of the several types supported by the 
  Multiple data type
  """)
  
  data = property(getData,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for data
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.Parameter', Parameter)

###############################################################################
class Violation(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Violation of linked-to constraint, calculated over structures defined in 
ViolationList.
  """
  #   from data model element ccp.nmr.NmrConstraint.Violation
  _metaclass = metaPackage.getElement('Violation')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'calcValue', 'calcValueError', 'ccpnInternalData', 'className', 'fieldNames', 'fractionViolated', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'violation', 'constraint', 'method', 'parent', 'root', 'topObject', 'violationList',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    dataDict['violationList'] = parent
    if (not isinstance(parent, ViolationList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.ViolationList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['calcValue'] = None
      dataDict['calcValueError'] = None
      dataDict['ccpnInternalData'] = None
      dataDict['fractionViolated'] = None
      dataDict['violation'] = None
      dataDict['constraint'] = None
      dataDict['method'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.Violation', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.Violation.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('violations')
        objKey = dataDict.get('constraint')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['constraint'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.Violation:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.Violation:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if ((constraint is not None and not (constraint in objsToBeDeleted))):
      violations = constraint.__dict__.get('violations')
      violations.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      violations = method.__dict__.get('violations')
      violations.remove(self)

    violationList = dataDict.get('violationList')
    if (not (violationList in objsToBeDeleted)):
      objKey = dataDict.get('constraint')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = violationList.__dict__.get('violations')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.Violation:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    violationList = dataDict.get('violationList')
    if (not (violationList in objsToBeUnDeleted)):

      childrenDict = violationList.__dict__.get('violations')
      objKey = dataDict.get('constraint')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['constraint'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    constraint = dataDict.get('constraint')
    if ((constraint is not None and not (constraint in objsToBeUnDeleted))):
      violations = constraint.__dict__.get('violations')
      violations.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      violations = method.__dict__.get('violations')
      violations.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('constraint')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('violationList')
        dd = value.__dict__.get('violations')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'violationList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('calcValue')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: calcValue:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: calcValue:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('calcValueError')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: calcValueError:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: calcValueError:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('fractionViolated')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: fractionViolated:
         memops.Implementation.FloatRatio input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: fractionViolated:
         FloatRatio constraint value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: fractionViolated:
         FloatRatio constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value <= 1.0)):
        raise ApiError("""%s.checkValid: fractionViolated:
         FloatRatio constraint value_le_1 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('violation')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: violation:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: violation:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: violation:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, AbstractConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('violations')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: constraint:
         non-reciprocal link constraint from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('violations')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('violationList')
      if (not isinstance(value, ViolationList)):
        raise ApiError("""%s.checkValid: violationList:
         value is not of class ccp.nmr.NmrConstraint.ViolationList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('calcValue')
    if (value is None):
      raise ApiError("""%s.checkValid: calcValue:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('calcValueError')
    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('fractionViolated')
    if (value is None):
      raise ApiError("""%s.checkValid: fractionViolated:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('violation')
    if (value is None):
      raise ApiError("""%s.checkValid: violation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('method')
    value = dataDict.get('violationList')
    if (value is None):
      raise ApiError("""%s.checkValid: violationList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.Violation
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.Violation'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.Violation'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('violationLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('violations').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation
  
  def getCalcValue(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.calcValue
    """
    dataDict = self.__dict__
    result = dataDict.get('calcValue')
    return result
  
  def getCalcValueError(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.calcValueError
    """
    dataDict = self.__dict__
    result = dataDict.get('calcValueError')
    return result

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFractionViolated(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.fractionViolated
    """
    dataDict = self.__dict__
    result = dataDict.get('fractionViolated')
    return result
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('violationList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('constraint'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getMethod(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.method
    """
    dataDict = self.__dict__
    result = dataDict.get('method')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('violationList')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getViolation(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.violation
    """
    dataDict = self.__dict__
    result = dataDict.get('violation')
    return result
  
  def getViolationList(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.violationList
    """
    dataDict = self.__dict__
    result = dataDict.get('violationList')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setCalcValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.calcValue
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setCalcValue:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setCalcValue:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('calcValue')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCalcValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCalcValue:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setCalcValue:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['calcValue'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCalcValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCalcValue, self.setCalcValue,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setCalcValueError(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.calcValueError
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setCalcValueError:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setCalcValueError:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('calcValueError')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCalcValueError:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCalcValueError:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['calcValueError'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCalcValueError')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setCalcValueError, self.setCalcValueError,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setConstraint(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.constraint
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraint)):
      raise ApiError("""%s.setConstraint:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('constraint')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraint:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConstraint:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setConstraint:
         cannot set constraint, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setConstraint:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setConstraint:
         Link constraint between objects from separate partitions
          - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('violations')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setConstraint:
         Read link 'constraint' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('violations')
      newSelves.add(self)

    dataDict['constraint'] = value

    # doNotifies
  
  def setFractionViolated(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.fractionViolated
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setFractionViolated:
       memops.Implementation.FloatRatio input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (0.0 <= value)):
      raise ApiError("""%s.setFractionViolated:
       FloatRatio constraint value_ge_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setFractionViolated:
       FloatRatio constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value <= 1.0)):
      raise ApiError("""%s.setFractionViolated:
       FloatRatio constraint value_le_1 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('fractionViolated')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setFractionViolated:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setFractionViolated:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setFractionViolated:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['fractionViolated'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setFractionViolated')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setFractionViolated, self.setFractionViolated,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setMethod(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.method
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMethod:
         value is not of class ccp.general.Method.Method""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('method')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMethod:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMethod:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setMethod:
         cannot set method, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setMethod:
           Link method between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('violations')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setMethod:
         Read link 'method' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('violations')
      newSelves.add(self)

    dataDict['method'] = value

    # doNotifies
  
  def setViolation(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.violation
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setViolation:
       memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (0.0 <= value)):
      raise ApiError("""%s.setViolation:
       NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setViolation:
       NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('violation')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setViolation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setViolation:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setViolation:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['violation'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setViolation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setViolation, self.setViolation,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData
  
  calcValue = property(getCalcValue, setCalcValue, None,
  r"""The value calculated for the quantity being constrained.
  """)
  
  calcValueError = property(getCalcValueError, setCalcValueError, None,
  r"""Error (standard deviation) in the calculated value
  """)

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames
  
  fractionViolated = property(getFractionViolated, setFractionViolated, None,
  r"""Fraction of structures in which the constraint was violated
  """)

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  violation = property(getViolation, setViolation, None,
  r"""Value of the violation - the amount by which the calcValue exceeds the 
  limit given in the Constraint. The violation is always given as 
  positive. The unit is given by the ConstraintList containing the 
  violated Constraint
  """)
  
  constraint = property(getConstraint, setConstraint, None,
  r"""Constraint being violated
  """)
  
  method = property(getMethod, setMethod, None,
  r"""Method used for calculating violation
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for violationList
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject
  
  violationList = property(getViolationList,  None, None,
  r"""parent link
  """)

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.Violation', Violation)

###############################################################################
class ViolationList(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""List of constraint violations, calculated over the structures linked to 
(if set). The violations may refer to constraints from different 
ConstraintLists.
  """
  #   from data model element ccp.nmr.NmrConstraint.ViolationList
  _metaclass = metaPackage.getElement('ViolationList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'molStructures', 'nmrConstraintStore', 'parent', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['serial'] = None
      dataDict['molStructures'] = set()
      dataDict['violations'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ViolationList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ViolationList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ViolationList')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('violationLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ViolationList:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    molStructures = dataDict.get('molStructures')
    pass
    for molStructure in molStructures:
      topObject = molStructure.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    violations = dataDict.get('violations').values()
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ViolationList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for molStructure in dataDict.get('molStructures'):
      if (not (molStructure in objsToBeDeleted)):
        violationLists = molStructure.__dict__.get('violationLists')
        violationLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('violationLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ViolationList:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('violationLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for molStructure in dataDict.get('molStructures'):
      if (not (molStructure in objsToBeUnDeleted)):
        violationLists = molStructure.__dict__.get('violationLists')
        violationLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addMolStructure(self, value):
    """
    Add for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import Model as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addMolStructure:
       value is not of class ccp.molecule.MolStructure.Model""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('molStructures')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addMolStructure:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addMolStructure:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addMolStructure:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addMolStructure:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addMolStructure:
           Link molStructures between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('violationLists')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addMolStructure')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMolStructures, self.addMolStructure,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('violations').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('violationLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('molStructures')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import Model as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: molStructures:
           value is not of class ccp.molecule.MolStructure.Model""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('violationLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: molStructures:
           non-reciprocal link molStructures from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: molStructures:
           Link molStructures between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('violations').values()
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('violationList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    # check roles
    values = dataDict.get('molStructures')
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('violations').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllMolStructures(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('molStructures')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('molStructures')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'index', 'name', 'serial', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllViolations(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ViolationList.violations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('violations').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('violations').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'calcValue', 'calcValueError', 'ccpnInternalData', 'fractionViolated', 'violation', 'constraint', 'method', 'violationList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstMolStructure(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('molStructures')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('molStructures')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'index', 'name', 'serial', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstViolation(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ViolationList.violations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('violations').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('constraint')
      if (objKey is not None):
        result = dataDict.get('violations').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('violations').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'calcValue', 'calcValueError', 'ccpnInternalData', 'fractionViolated', 'violation', 'constraint', 'method', 'violationList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ViolationList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ViolationList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ViolationList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('violationLists').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getMolStructures(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('molStructures')
    result = frozenset(tempVar)
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getViolations(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.violations
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('violations').values()
    result = frozenset(tempVar)
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newViolation(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.Violation
    """
    return Violation(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeMolStructure(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import Model as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeMolStructure:
       value is not of class ccp.molecule.MolStructure.Model""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('molStructures')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeMolStructure:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeMolStructure:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeMolStructure:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeMolStructure:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('violationLists')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeMolStructure')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMolStructures, self.removeMolStructure,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ViolationList.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setMolStructures(self, values):
    """
    Set for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setMolStructures:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.molecule.MolStructure import Model as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMolStructures:
         value is not of class ccp.molecule.MolStructure.Model""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('molStructures')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setMolStructures:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMolStructures:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMolStructures:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setMolStructures:
           Link molStructures between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('violationLists')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('violationLists')
        oldSelves.add(self)

    dataDict['molStructures'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setMolStructures')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMolStructures, self.setMolStructures,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ViolationList.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('violationLists')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['violationLists'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['violationLists'] = value

    dataDict['serial'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedMolStructures(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    ll = dataDict.get('molStructures')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedViolations(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ViolationList.violations
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('violations')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  molStructures = property(getMolStructures, setMolStructures, None,
  r"""MolStructure.Models used for calculating ViolationList
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject
  
  violations = property(getViolations,  None, None,
  r"""child link to class Violation
  """)

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ViolationList', ViolationList)

###############################################################################
class GenericConstraint(AbstractConstraint):
  r"""Constraint for multiple types - the type is determined by the parent 
Constraint list
  """
  #   from data model element ccp.nmr.NmrConstraint.GenericConstraint
  _metaclass = metaPackage.getElement('GenericConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'figureOfMerit', 'inConstructor', 'isDeleted', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'vectorLength', 'weight', 'constraintGroups', 'contributions', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.GenericConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, GenericConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.GenericConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['figureOfMerit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['vectorLength'] = None
      dataDict['weight'] = 1.0
      dataDict['constraintGroups'] = set()
      dataDict['contributions'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.GenericConstraint', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.GenericConstraint.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.GenericConstraint')
          )

      serialDict = {}
      serialDict['contributions'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.GenericConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    contributions = dataDict.get('contributions').values()
    for contribution in contributions:
      if (not (contribution in objsToBeDeleted)):
        objsToBeDeleted.add(contribution)
        objsToBeChecked.append(contribution)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.GenericConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.GenericConstraint:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeUnDeleted)):

      childrenDict = parentList.__dict__.get('constraints')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeUnDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.add(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeUnDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.GenericConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('contributions').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.GenericConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('figureOfMerit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: figureOfMerit:
           memops.Implementation.FloatRatio input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (0.0 <= value)):
          raise ApiError("""%s.checkValid: figureOfMerit:
           FloatRatio constraint value_ge_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: figureOfMerit:
           FloatRatio constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value <= 1.0)):
          raise ApiError("""%s.checkValid: figureOfMerit:
           FloatRatio constraint value_le_1 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('vectorLength')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: vectorLength:
           memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: vectorLength:
           PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: vectorLength:
           PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('contributions').values()
      for value in values:
        if (not isinstance(value, GenericContribution)):
          raise ApiError("""%s.checkValid: contributions:
           value is not of class ccp.nmr.NmrConstraint.GenericContribution""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: contributions:
           non-reciprocal link contributions from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link nmrConstraintValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, GenericConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.GenericConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link peakContribs from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('figureOfMerit')
    value = dataDict.get('origData')
    value = dataDict.get('vectorLength')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    values = dataDict.get('constraintGroups')
    values = dataDict.get('contributions').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.GenericConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('contributions').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'isDistanceDependent', 'lowerLimit', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.GenericConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('contributions').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('contributions').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'isDistanceDependent', 'lowerLimit', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.GenericConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.GenericConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.GenericConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.GenericConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraint.contributions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('contributions').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraint.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFigureOfMerit(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraint.figureOfMerit
    """
    dataDict = self.__dict__
    result = dataDict.get('figureOfMerit')
    return result
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.GenericConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.GenericConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getVectorLength(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraint.vectorLength
    """
    dataDict = self.__dict__
    result = dataDict.get('vectorLength')
    return result

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newAtomPairContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.AtomPairContribution
    """
    return AtomPairContribution(self, **attrlinks)

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newFourAtomContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.FourAtomContribution
    """
    return FourAtomContribution(self, **attrlinks)
  
  def newSingleAtomContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.SingleAtomContribution
    """
    return SingleAtomContribution(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.GenericConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails
  
  def setFigureOfMerit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraint.figureOfMerit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setFigureOfMerit:
         memops.Implementation.FloatRatio input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.setFigureOfMerit:
         FloatRatio constraint value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setFigureOfMerit:
         FloatRatio constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value <= 1.0)):
        raise ApiError("""%s.setFigureOfMerit:
         FloatRatio constraint value_le_1 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('figureOfMerit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setFigureOfMerit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setFigureOfMerit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['figureOfMerit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setFigureOfMerit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setFigureOfMerit, self.setFigureOfMerit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial
  
  def setVectorLength(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraint.vectorLength
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setVectorLength:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setVectorLength:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setVectorLength:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('vectorLength')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setVectorLength:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setVectorLength:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['vectorLength'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setVectorLength')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setVectorLength, self.setVectorLength,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.GenericConstraint.contributions
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('contributions')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames
  
  figureOfMerit = property(getFigureOfMerit, setFigureOfMerit, None,
  r"""Figure of merit for deriavation of restraint value
  """)

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial
  
  vectorLength = property(getVectorLength, setVectorLength, None,
  r"""Reference interatomic vector length, in Angstrom
  """)

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups
  
  contributions = property(getContributions,  None, None,
  r"""child link to class GenericContribution
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.GenericConstraint', GenericConstraint)

###############################################################################
class DihedralConstraint(AbstractConstraint):
  r"""Dihedral angle constraint. Not ambiguous, must be assigned to a specific 
quartet of Resonances. The different Dihedral Constraint Items represent 
alternative possibilities for dihedral angle values, rather than 
alternative assignemnts.
  """
  #   from data model element ccp.nmr.NmrConstraint.DihedralConstraint
  _metaclass = metaPackage.getElement('DihedralConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'weight', 'constraintGroups', 'contributions', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'resonances', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, DihedralConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DihedralConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['weight'] = 1.0
      dataDict['constraintGroups'] = set()
      dataDict['contributions'] = {}
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['resonances'] = list()
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DihedralConstraint', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DihedralConstraint.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DihedralConstraint')
          )

      serialDict = {}
      serialDict['contributions'] = 0
      serialDict['items'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DihedralConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    contributions = dataDict.get('contributions').values()
    for contribution in contributions:
      if (not (contribution in objsToBeDeleted)):
        objsToBeDeleted.add(contribution)
        objsToBeChecked.append(contribution)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DihedralConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        dihedralConstraints = resonance.__dict__.get('dihedralConstraints')
        dihedralConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DihedralConstraint:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeUnDeleted)):

      childrenDict = parentList.__dict__.get('constraints')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeUnDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.add(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeUnDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.add(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        dihedralConstraints = resonance.__dict__.get('dihedralConstraints')
        dihedralConstraints.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('contributions').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('contributions').values()
      for value in values:
        if (not isinstance(value, DihedralContribution)):
          raise ApiError("""%s.checkValid: contributions:
           value is not of class ccp.nmr.NmrConstraint.DihedralContribution""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: contributions:
           non-reciprocal link contributions from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, DihedralConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.DihedralConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link nmrConstraintValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, DihedralConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.DihedralConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link peakContribs from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dihedralConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('origData')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    values = dataDict.get('constraintGroups')
    values = dataDict.get('contributions').values()
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('resonances')
    if (not (len(values) == 4)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 4""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('violations')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('contributions').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralConstraint.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = list(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('contributions').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('contributions').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralConstraint.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DihedralConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.contributions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('contributions').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraint.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = tuple(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newDihedralConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    return DihedralConstraintItem(self, **attrlinks)
  
  def newDihedralContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DihedralContribution
    """
    return DihedralContribution(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraint.resonances
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 4)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 4""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('dihedralConstraints')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('dihedralConstraints')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  setSerial = AbstractConstraint.setSerial

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DihedralConstraint.contributions
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('contributions')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DihedralConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups
  
  contributions = property(getContributions,  None, None,
  r"""child link to class DihedralContribution
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class DihedralConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks
  
  resonances = property(getResonances, setResonances, None,
  r"""Resonances (in order from one end to the other) defining the dihedral 
  angle being constrained
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DihedralConstraint', DihedralConstraint)

###############################################################################
class SingleConstraint(AbstractConstraint):
  r"""Constraint with a single interval for the constrained value. May be used 
to constraint to a specific value (targetValue) to constrain to within 
an interval, or both.
  """
  #   from data model element ccp.nmr.NmrConstraint.SingleConstraint
  _metaclass = metaPackage.getElement('SingleConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraintGroups', 'contributions', 'method', 'nmrConstraintValidations', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak

  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups

  findAllContributions = AbstractConstraint.findAllContributions

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup

  findFirstContribution = AbstractConstraint.findFirstContribution

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.SingleConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.SingleConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.SingleConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        if (isinstance(obj3, SingleConstraint)):
          result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getContributions = AbstractConstraint.getContributions

  getDetails = AbstractConstraint.getDetails
  
  def getError(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleConstraint.error
    """
    dataDict = self.__dict__
    result = dataDict.get('error')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraint.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraint.getLocalKey
  
  def getLowerLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleConstraint.lowerLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('lowerLimit')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParentList = AbstractConstraint.getParentList

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial
  
  def getTargetValue(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleConstraint.targetValue
    """
    dataDict = self.__dict__
    result = dataDict.get('targetValue')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUpperLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleConstraint.upperLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('upperLimit')
    return result

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails
  
  def setError(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleConstraint.error
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setError:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setError:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('error')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setError:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setError:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['error'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setError')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setError, self.setError,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setLowerLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleConstraint.lowerLimit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setLowerLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setLowerLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('lowerLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setLowerLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setLowerLimit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['lowerLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setLowerLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setLowerLimit, self.setLowerLimit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial
  
  def setTargetValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleConstraint.targetValue
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setTargetValue:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setTargetValue:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('targetValue')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTargetValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTargetValue:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['targetValue'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTargetValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTargetValue, self.setTargetValue,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setUpperLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleConstraint.upperLimit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setUpperLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setUpperLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('upperLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUpperLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUpperLimit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['upperLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUpperLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUpperLimit, self.setUpperLimit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups

  sortedContributions = AbstractConstraint.sortedContributions

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details
  
  error = property(getError, setError, None,
  r"""Uncertainty (standard deviation) of targetValue.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  lowerLimit = property(getLowerLimit, setLowerLimit, None,
  r"""Minimum allowed value of constrained parameter. If set, energy penalty 
  is zero for values above lowerLimit.
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial
  
  targetValue = property(getTargetValue, setTargetValue, None,
  r"""Desired value of constrained parameter
  """)
  
  upperLimit = property(getUpperLimit, setUpperLimit, None,
  r"""Maximum allowed value of constrained parameter
  """)

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups

  contributions = AbstractConstraint.contributions

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations

  parentList = AbstractConstraint.parentList

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.SingleConstraint', SingleConstraint)

###############################################################################
class HBondConstraintList(AbstractConstraintList):
  r"""List of hydrogen bond constraints.
  """
  #   from data model element ccp.nmr.NmrConstraint.HBondConstraintList
  _metaclass = metaPackage.getElement('HBondConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['origin'] = None
      dataDict['potentialType'] = 'unknown'
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.HBondConstraintList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.HBondConstraintList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.HBondConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.HBondConstraintList:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.HBondConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.HBondConstraintList:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeUnDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.add(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeUnDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origin')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: origin:
           ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('potentialType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: potentialType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link conditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, HBondConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.HBondConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link nmrConstraintListValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('origin')
    value = dataDict.get('potentialType')
    if (value is None):
      raise ApiError("""%s.checkValid: potentialType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.HBondConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.HBondConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.HBondConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, HBondConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getOrigin = AbstractConstraintList.getOrigin

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getPotentialType = AbstractConstraintList.getPotentialType

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newHBondConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.HBondConstraint
    """
    return HBondConstraint(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setOrigin = AbstractConstraintList.setOrigin

  setPotentialType = AbstractConstraintList.setPotentialType

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.HBondConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  origin = AbstractConstraintList.origin

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  potentialType = AbstractConstraintList.potentialType

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class HBondConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  parent = AbstractConstraintList.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.HBondConstraintList', HBondConstraintList)

###############################################################################
class RdcConstraintList(AbstractConstraintList):
  r"""List of reduced dipolar coupling constraints, in the form of RDC values 
that should be reproduced by the structure.
  """
  #   from data model element ccp.nmr.NmrConstraint.RdcConstraintList
  _metaclass = metaPackage.getElement('RdcConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'tensorChainCode', 'tensorMagnitude', 'tensorResidueType', 'tensorRhombicity', 'tensorSequenceCode', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['origin'] = None
      dataDict['potentialType'] = 'unknown'
      dataDict['serial'] = None
      dataDict['tensorChainCode'] = None
      dataDict['tensorMagnitude'] = None
      dataDict['tensorResidueType'] = None
      dataDict['tensorRhombicity'] = None
      dataDict['tensorSequenceCode'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.RdcConstraintList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.RdcConstraintList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.RdcConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.RdcConstraintList:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.RdcConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.RdcConstraintList:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeUnDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.add(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeUnDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origin')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: origin:
           ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('potentialType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: potentialType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('tensorChainCode')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: tensorChainCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: tensorChainCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: tensorChainCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: tensorChainCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('tensorMagnitude')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: tensorMagnitude:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: tensorMagnitude:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('tensorResidueType')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: tensorResidueType:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: tensorResidueType:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: tensorResidueType:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: tensorResidueType:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('tensorRhombicity')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: tensorRhombicity:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: tensorRhombicity:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('tensorSequenceCode')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: tensorSequenceCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: tensorSequenceCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: tensorSequenceCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: tensorSequenceCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link conditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, RdcConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.RdcConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link nmrConstraintListValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('origin')
    value = dataDict.get('potentialType')
    if (value is None):
      raise ApiError("""%s.checkValid: potentialType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('tensorChainCode')
    value = dataDict.get('tensorMagnitude')
    value = dataDict.get('tensorResidueType')
    value = dataDict.get('tensorRhombicity')
    value = dataDict.get('tensorSequenceCode')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.RdcConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'vectorLength', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.RdcConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'vectorLength', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.RdcConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, RdcConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getOrigin = AbstractConstraintList.getOrigin

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getPotentialType = AbstractConstraintList.getPotentialType

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial
  
  def getTensorChainCode(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintList.tensorChainCode
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorChainCode')
    return result
  
  def getTensorMagnitude(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintList.tensorMagnitude
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorMagnitude')
    return result
  
  def getTensorResidueType(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintList.tensorResidueType
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorResidueType')
    return result
  
  def getTensorRhombicity(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintList.tensorRhombicity
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorRhombicity')
    return result
  
  def getTensorSequenceCode(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintList.tensorSequenceCode
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorSequenceCode')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newRdcConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.RdcConstraint
    """
    return RdcConstraint(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setOrigin = AbstractConstraintList.setOrigin

  setPotentialType = AbstractConstraintList.setPotentialType

  setSerial = AbstractConstraintList.setSerial
  
  def setTensorChainCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcConstraintList.tensorChainCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setTensorChainCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setTensorChainCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setTensorChainCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setTensorChainCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorChainCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorChainCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorChainCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['tensorChainCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorChainCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorChainCode, self.setTensorChainCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorMagnitude(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcConstraintList.tensorMagnitude
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setTensorMagnitude:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setTensorMagnitude:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorMagnitude')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorMagnitude:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorMagnitude:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['tensorMagnitude'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorMagnitude')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorMagnitude, self.setTensorMagnitude,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorResidueType(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcConstraintList.tensorResidueType
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setTensorResidueType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setTensorResidueType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setTensorResidueType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setTensorResidueType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorResidueType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorResidueType:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorResidueType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['tensorResidueType'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorResidueType')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorResidueType, self.setTensorResidueType,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorRhombicity(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcConstraintList.tensorRhombicity
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setTensorRhombicity:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setTensorRhombicity:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorRhombicity')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorRhombicity:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorRhombicity:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['tensorRhombicity'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorRhombicity')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorRhombicity, self.setTensorRhombicity,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorSequenceCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcConstraintList.tensorSequenceCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setTensorSequenceCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setTensorSequenceCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setTensorSequenceCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setTensorSequenceCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorSequenceCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorSequenceCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorSequenceCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['tensorSequenceCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorSequenceCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorSequenceCode, self.setTensorSequenceCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.RdcConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  origin = AbstractConstraintList.origin

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  potentialType = AbstractConstraintList.potentialType

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial
  
  tensorChainCode = property(getTensorChainCode, setTensorChainCode, None,
  r"""Chain code of residue anchoring orientation tensor
  """)
  
  tensorMagnitude = property(getTensorMagnitude, setTensorMagnitude, None,
  r"""Orientation tensor magnitude
  """)
  
  tensorResidueType = property(getTensorResidueType, setTensorResidueType, None,
  r"""Residue type of residue anchoring orientation tensor
  """)
  
  tensorRhombicity = property(getTensorRhombicity, setTensorRhombicity, None,
  r"""Rhombicity of orientation tensor
  """)
  
  tensorSequenceCode = property(getTensorSequenceCode, setTensorSequenceCode, None,
  r"""Sequence code of residue anchoring orientation tensor
  """)

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class RdcConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  parent = AbstractConstraintList.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.RdcConstraintList', RdcConstraintList)

###############################################################################
class JCouplingConstraintList(AbstractConstraintList):
  r"""Lis of J coupling constraints, in the form of J coupling values that 
should be reproduced by the structure.
  """
  #   from data model element ccp.nmr.NmrConstraint.JCouplingConstraintList
  _metaclass = metaPackage.getElement('JCouplingConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['origin'] = None
      dataDict['potentialType'] = 'unknown'
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.JCouplingConstraintList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.JCouplingConstraintList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.JCouplingConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.JCouplingConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.JCouplingConstraintList:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.JCouplingConstraintList:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeUnDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.add(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeUnDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origin')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: origin:
           ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('potentialType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: potentialType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link conditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, JCouplingConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.JCouplingConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link nmrConstraintListValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('origin')
    value = dataDict.get('potentialType')
    if (value is None):
      raise ApiError("""%s.checkValid: potentialType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.JCouplingConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.JCouplingConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, JCouplingConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getOrigin = AbstractConstraintList.getOrigin

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getPotentialType = AbstractConstraintList.getPotentialType

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newJCouplingConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    return JCouplingConstraint(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setOrigin = AbstractConstraintList.setOrigin

  setPotentialType = AbstractConstraintList.setPotentialType

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.JCouplingConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  origin = AbstractConstraintList.origin

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  potentialType = AbstractConstraintList.potentialType

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class JCouplingConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  parent = AbstractConstraintList.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.JCouplingConstraintList', JCouplingConstraintList)

###############################################################################
class ChemicalShiftConstraintList(AbstractConstraintList):
  r"""List of chemical shift constraints
  """
  #   from data model element ccp.nmr.NmrConstraint.ChemicalShiftConstraintList
  _metaclass = metaPackage.getElement('ChemicalShiftConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'isotopeCode', 'measureListSerials', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'isotope', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['isotopeCode'] = None
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['origin'] = None
      dataDict['potentialType'] = 'unknown'
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ChemicalShiftConstraintList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ChemicalShiftConstraintList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ChemicalShiftConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeUnDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.add(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeUnDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isotopeCode')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: isotopeCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origin')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: origin:
           ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('potentialType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: potentialType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link conditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, ChemicalShiftConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.ChemicalShiftConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = self.getIsotope()
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.molecule.ChemElement import Isotope as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: isotope:
           value is not of class ccp.molecule.ChemElement.Isotope""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: isotope:
           Link isotope between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link nmrConstraintListValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    value = dataDict.get('isotopeCode')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('origin')
    value = dataDict.get('potentialType')
    if (value is None):
      raise ApiError("""%s.checkValid: potentialType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.ChemicalShiftConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.ChemicalShiftConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemicalShiftConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemicalShiftConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, ChemicalShiftConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getIsotope(self):
    """
    getfunction for derived link Isotope
    """
    dataDict = self.__dict__
    ss = self.isotopeCode
    if ss is None:
      result = None
    else:
      if ss[-2] in '0123456789':
        firstLetter = -1
      else:
        firstLetter = -2
      atomSymbol = ss[firstLetter:].capitalize()
      massNumber = int(ss[:firstLetter])
    
      result = ccpnmodel.ccpncore.api.ccp.molecule.ChemElement.Isotope.getByKey(self.root.currentChemElementStore, (atomSymbol, massNumber))
    return result
  
  def getIsotopeCode(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList.isotopeCode
    """
    dataDict = self.__dict__
    result = dataDict.get('isotopeCode')
    return result

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getOrigin = AbstractConstraintList.getOrigin

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getPotentialType = AbstractConstraintList.getPotentialType

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newChemicalShiftConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """
    return ChemicalShiftConstraint(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments
  
  def setIsotopeCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList.isotopeCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setIsotopeCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isotopeCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsotopeCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsotopeCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['isotopeCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsotopeCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setIsotopeCode, self.setIsotopeCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setOrigin = AbstractConstraintList.setOrigin

  setPotentialType = AbstractConstraintList.setPotentialType

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ChemicalShiftConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  isotopeCode = property(getIsotopeCode, setIsotopeCode, None,
  r"""String indicating Isotope (e.g. 13C, 3He, 2H, 235U  ...) to which all 
  chemical shifts in list should belong
  """)

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  origin = AbstractConstraintList.origin

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  potentialType = AbstractConstraintList.potentialType

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class ChemicalShiftConstraint
  """)

  experiments = AbstractConstraintList.experiments
  
  isotope = property(getIsotope, None, None,
  r"""Isotope for Constraints in Chemical Shift Constraint List
  """)

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  parent = AbstractConstraintList.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ChemicalShiftConstraintList', ChemicalShiftConstraintList)

###############################################################################
class GenericConstraintList(AbstractConstraintList):
  r"""Constraint list for multiple types - the type is determined by the 
ConstraintType and itemLength fields.
NB this class is also used for T1, 
T2, ChemicalShift and all kinds of measurements..
  """
  #   from data model element ccp.nmr.NmrConstraint.GenericConstraintList
  _metaclass = metaPackage.getElement('GenericConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'constraintType', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'itemLength', 'measureListSerials', 'measurementType', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'spectrometerFrequency', 'tensorChainCode', 'tensorIsotropicValue', 'tensorMagnitude', 'tensorResidueType', 'tensorRhombicity', 'tensorSequenceCode', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parameters', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.GenericConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['constraintType'] = None
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['itemLength'] = 2
      dataDict['measureListSerials'] = set()
      dataDict['measurementType'] = None
      dataDict['name'] = None
      dataDict['origin'] = None
      dataDict['potentialType'] = 'unknown'
      dataDict['serial'] = None
      dataDict['spectrometerFrequency'] = None
      dataDict['tensorChainCode'] = None
      dataDict['tensorIsotropicValue'] = 0.0
      dataDict['tensorMagnitude'] = 0.0
      dataDict['tensorResidueType'] = None
      dataDict['tensorRhombicity'] = 0.0
      dataDict['tensorSequenceCode'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()
      dataDict['parameters'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.GenericConstraintList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.GenericConstraintList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.GenericConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.GenericConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    parameters = dataDict.get('parameters').values()
    for parameter in parameters:
      if (not (parameter in objsToBeDeleted)):
        objsToBeDeleted.add(parameter)
        objsToBeChecked.append(parameter)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.GenericConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.GenericConstraintList:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeUnDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.add(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeUnDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.GenericConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('parameters').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.GenericConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('constraintType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: constraintType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: constraintType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: constraintType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: constraintType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('itemLength')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: itemLength:
         memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.checkValid: itemLength:
         PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('measurementType')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measurementType:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: measurementType:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: measurementType:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: measurementType:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origin')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: origin:
           ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('potentialType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: potentialType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('spectrometerFrequency')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: spectrometerFrequency:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: spectrometerFrequency:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('tensorChainCode')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: tensorChainCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: tensorChainCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: tensorChainCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: tensorChainCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('tensorIsotropicValue')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: tensorIsotropicValue:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: tensorIsotropicValue:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('tensorMagnitude')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: tensorMagnitude:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: tensorMagnitude:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('tensorResidueType')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: tensorResidueType:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: tensorResidueType:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: tensorResidueType:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: tensorResidueType:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('tensorRhombicity')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: tensorRhombicity:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: tensorRhombicity:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('tensorSequenceCode')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: tensorSequenceCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: tensorSequenceCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: tensorSequenceCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: tensorSequenceCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link conditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, GenericConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.GenericConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link nmrConstraintListValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('parameters').values()
      for value in values:
        if (not isinstance(value, ConstraintListParameter)):
          raise ApiError("""%s.checkValid: parameters:
           value is not of class ccp.nmr.NmrConstraint.ConstraintListParameter""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('genericConstraintList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: parameters:
           non-reciprocal link parameters from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    if (not (self.nmrConstraintStore.findAllConstraintLists(name=self.name) in (set(), set((self,))))):
      raise ApiError("""%s.checkValid:
       constraint name_uniquely_identifies_constraintList violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('constraintType')
    if (value is None):
      raise ApiError("""%s.checkValid: constraintType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    from ccpnmodel.ccpncore.lib.Constants import constraintListType2ItemLength
    isValid = value in constraintListType2ItemLength
    if (not (isValid)):
      raise ApiError("""%s.checkValid: constraintType:
       constraintType constraint allowed_constraint_types_only violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    value = dataDict.get('itemLength')
    if (value is None):
      raise ApiError("""%s.checkValid: itemLength:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (constraintListType2ItemLength.get(self.constraintType) in (value, None))):
      raise ApiError("""%s.checkValid: itemLength:
       itemLength constraint itemLength_must_match_constraintType violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    values = dataDict.get('measureListSerials')
    value = dataDict.get('measurementType')
    value = dataDict.get('name')
    value = dataDict.get('origin')
    value = dataDict.get('potentialType')
    if (value is None):
      raise ApiError("""%s.checkValid: potentialType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('spectrometerFrequency')
    value = dataDict.get('tensorChainCode')
    value = dataDict.get('tensorIsotropicValue')
    if (value is None):
      raise ApiError("""%s.checkValid: tensorIsotropicValue:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('tensorMagnitude')
    if (value is None):
      raise ApiError("""%s.checkValid: tensorMagnitude:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('tensorResidueType')
    value = dataDict.get('tensorRhombicity')
    if (value is None):
      raise ApiError("""%s.checkValid: tensorRhombicity:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('tensorSequenceCode')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('parameters').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.GenericConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'figureOfMerit', 'origData', 'serial', 'vectorLength', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations
  
  def findAllParameters(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.GenericConstraintList.parameters
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('parameters').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('parameters').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'value', 'genericConstraintList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.GenericConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'figureOfMerit', 'origData', 'serial', 'vectorLength', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation
  
  def findFirstParameter(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.GenericConstraintList.parameters
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('parameters').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('name')
      if (objKey is not None):
        result = dataDict.get('parameters').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('parameters').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'value', 'genericConstraintList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.GenericConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.GenericConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.GenericConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.GenericConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, GenericConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraintType(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.constraintType
    """
    dataDict = self.__dict__
    result = dataDict.get('constraintType')
    return result
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItemLength(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.itemLength
    """
    dataDict = self.__dict__
    result = dataDict.get('itemLength')
    return result

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists
  
  def getMeasurementType(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.measurementType
    """
    dataDict = self.__dict__
    result = dataDict.get('measurementType')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getOrigin = AbstractConstraintList.getOrigin

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParameters(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.parameters
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('parameters').values()
    result = frozenset(tempVar)
    return result

  getParent = AbstractConstraintList.getParent

  getPotentialType = AbstractConstraintList.getPotentialType

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial
  
  def getSpectrometerFrequency(self):
    """
    Get for
    ccp.nmr.NmrConstraint.GenericConstraintList.spectrometerFrequency
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrometerFrequency')
    return result
  
  def getTensorChainCode(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.tensorChainCode
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorChainCode')
    return result
  
  def getTensorIsotropicValue(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.tensorIsotropicValue
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorIsotropicValue')
    return result
  
  def getTensorMagnitude(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.tensorMagnitude
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorMagnitude')
    return result
  
  def getTensorResidueType(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.tensorResidueType
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorResidueType')
    return result
  
  def getTensorRhombicity(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.tensorRhombicity
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorRhombicity')
    return result
  
  def getTensorSequenceCode(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericConstraintList.tensorSequenceCode
    """
    dataDict = self.__dict__
    result = dataDict.get('tensorSequenceCode')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newConstraintListParameter(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ConstraintListParameter
    """
    return ConstraintListParameter(self, **attrlinks)
  
  def newGenericConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.GenericConstraint
    """
    return GenericConstraint(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.GenericConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConditionState = AbstractConstraintList.setConditionState
  
  def setConstraintType(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.constraintType
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setConstraintType:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setConstraintType:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setConstraintType:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setConstraintType:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('constraintType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraintType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setConstraintType:
         cannot set constraintType, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setConstraintType:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          from ccpnmodel.ccpncore.lib.Constants import constraintListType2ItemLength
          isValid = value in constraintListType2ItemLength
          if (not (isValid)):
            raise ApiError("""%s.setConstraintType:
             constraintType constraint allowed_constraint_types_only violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['constraintType'] = value

    # doNotifies

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments
  
  def setItemLength(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.itemLength
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setItemLength:
       memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value > 0)):
      raise ApiError("""%s.setItemLength:
       PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('itemLength')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setItemLength:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setItemLength:
         cannot set itemLength, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setItemLength:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (constraintListType2ItemLength.get(self.constraintType) in (value, None))):
            raise ApiError("""%s.setItemLength:
             itemLength constraint itemLength_must_match_constraintType violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['itemLength'] = value

    # doNotifies

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists
  
  def setMeasurementType(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.measurementType
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setMeasurementType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setMeasurementType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setMeasurementType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setMeasurementType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('measurementType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setMeasurementType:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMeasurementType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['measurementType'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setMeasurementType')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setMeasurementType, self.setMeasurementType,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setOrigin = AbstractConstraintList.setOrigin

  setPotentialType = AbstractConstraintList.setPotentialType

  setSerial = AbstractConstraintList.setSerial
  
  def setSpectrometerFrequency(self, value):
    """
    Set for
    ccp.nmr.NmrConstraint.GenericConstraintList.spectrometerFrequency
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setSpectrometerFrequency:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setSpectrometerFrequency:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('spectrometerFrequency')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSpectrometerFrequency:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSpectrometerFrequency:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['spectrometerFrequency'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSpectrometerFrequency')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSpectrometerFrequency, self.setSpectrometerFrequency,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorChainCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.tensorChainCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setTensorChainCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setTensorChainCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setTensorChainCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setTensorChainCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorChainCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorChainCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorChainCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['tensorChainCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorChainCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorChainCode, self.setTensorChainCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorIsotropicValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.tensorIsotropicValue
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setTensorIsotropicValue:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setTensorIsotropicValue:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorIsotropicValue')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorIsotropicValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorIsotropicValue:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setTensorIsotropicValue:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['tensorIsotropicValue'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorIsotropicValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorIsotropicValue, self.setTensorIsotropicValue,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorMagnitude(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.tensorMagnitude
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setTensorMagnitude:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setTensorMagnitude:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorMagnitude')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorMagnitude:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorMagnitude:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setTensorMagnitude:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['tensorMagnitude'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorMagnitude')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorMagnitude, self.setTensorMagnitude,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorResidueType(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.tensorResidueType
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setTensorResidueType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setTensorResidueType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setTensorResidueType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setTensorResidueType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorResidueType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorResidueType:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorResidueType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['tensorResidueType'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorResidueType')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorResidueType, self.setTensorResidueType,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorRhombicity(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.tensorRhombicity
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setTensorRhombicity:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setTensorRhombicity:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorRhombicity')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorRhombicity:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorRhombicity:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setTensorRhombicity:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['tensorRhombicity'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorRhombicity')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorRhombicity, self.setTensorRhombicity,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTensorSequenceCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericConstraintList.tensorSequenceCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setTensorSequenceCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setTensorSequenceCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setTensorSequenceCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setTensorSequenceCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('tensorSequenceCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTensorSequenceCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTensorSequenceCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['tensorSequenceCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTensorSequenceCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTensorSequenceCode, self.setTensorSequenceCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.GenericConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations
  
  def sortedParameters(self):
    """
    Sorted for ccp.nmr.NmrConstraint.GenericConstraintList.parameters
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('parameters')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  constraintType = property(getConstraintType, setConstraintType, None,
  r"""Type of constraint in list. E.g. Distance, ChemicalShift, JCoupling, 
  Rdc, T1, ChemicalShift, ...
  """)

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  itemLength = property(getItemLength, setItemLength, None,
  r"""Number of Resonances (atoms) per Constraint Item. Supported values are 
  1, 2, and 4 (for dihedrals). Determines the type of ConstraintItem that 
  are allowed for the list.
  """)

  measureListSerials = AbstractConstraintList.measureListSerials
  
  measurementType = property(getMeasurementType, setMeasurementType, None,
  r"""Measurement type for measurement of constraints. Sensible values depend 
  on the type of constraint. 
  E.g. for T1 measurements it might be 'z' or 
  'zz', for T2 it might be SQ, or DQ, 
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  origin = AbstractConstraintList.origin

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  potentialType = AbstractConstraintList.potentialType

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial
  
  spectrometerFrequency = property(getSpectrometerFrequency, setSpectrometerFrequency, None,
  r"""Spectrometer frequency that applies fo calculation of constraints
  """)
  
  tensorChainCode = property(getTensorChainCode, setTensorChainCode, None,
  r"""Chain code of residue anchoring orientation tensor
  """)
  
  tensorIsotropicValue = property(getTensorIsotropicValue, setTensorIsotropicValue, None,
  r"""Isotropic value of associated tensor (defaults to 0.0)
  """)
  
  tensorMagnitude = property(getTensorMagnitude, setTensorMagnitude, None,
  r"""Magnitude value of associated tensor (defaults to 0.0)
  """)
  
  tensorResidueType = property(getTensorResidueType, setTensorResidueType, None,
  r"""Residue type of residue anchoring orientation tensor
  """)
  
  tensorRhombicity = property(getTensorRhombicity, setTensorRhombicity, None,
  r"""Rhombicity of associated tensor (defaults to 0.0)
  """)
  
  tensorSequenceCode = property(getTensorSequenceCode, setTensorSequenceCode, None,
  r"""Sequence code of residue anchoring orientation tensor
  """)

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class GenericConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore
  
  parameters = property(getParameters,  None, None,
  r"""child link to class ConstraintListParameter
  """)

  parent = AbstractConstraintList.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.GenericConstraintList', GenericConstraintList)

###############################################################################
class DistanceConstraintList(AbstractConstraintList):
  r"""List of Distance Constraints
  """
  #   from data model element ccp.nmr.NmrConstraint.DistanceConstraintList
  _metaclass = metaPackage.getElement('DistanceConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['origin'] = None
      dataDict['potentialType'] = 'unknown'
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DistanceConstraintList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DistanceConstraintList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DistanceConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DistanceConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DistanceConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DistanceConstraintList:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeUnDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.add(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeUnDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origin')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: origin:
           ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('potentialType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: potentialType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link conditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, DistanceConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.DistanceConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link nmrConstraintListValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('origin')
    value = dataDict.get('potentialType')
    if (value is None):
      raise ApiError("""%s.checkValid: potentialType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DistanceConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'backCalcVolume', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DistanceConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'backCalcVolume', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DistanceConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, DistanceConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getOrigin = AbstractConstraintList.getOrigin

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getPotentialType = AbstractConstraintList.getPotentialType

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newDistanceConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DistanceConstraint
    """
    return DistanceConstraint(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setOrigin = AbstractConstraintList.setOrigin

  setPotentialType = AbstractConstraintList.setPotentialType

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DistanceConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  origin = AbstractConstraintList.origin

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  potentialType = AbstractConstraintList.potentialType

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class DistanceConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  parent = AbstractConstraintList.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DistanceConstraintList', DistanceConstraintList)

###############################################################################
class DihedralConstraintList(AbstractConstraintList):
  r"""List of Dihedral angle restraints, including those that arise from J 
couplings.
  """
  #   from data model element ccp.nmr.NmrConstraint.DihedralConstraintList
  _metaclass = metaPackage.getElement('DihedralConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['origin'] = None
      dataDict['potentialType'] = 'unknown'
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DihedralConstraintList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DihedralConstraintList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DihedralConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DihedralConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DihedralConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DihedralConstraintList:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeUnDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.add(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeUnDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origin')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: origin:
           ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('potentialType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: potentialType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link conditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, DihedralConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link nmrConstraintListValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('origin')
    value = dataDict.get('potentialType')
    if (value is None):
      raise ApiError("""%s.checkValid: potentialType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'origData', 'serial', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'origData', 'serial', 'weight', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DihedralConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, DihedralConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getOrigin = AbstractConstraintList.getOrigin

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getPotentialType = AbstractConstraintList.getPotentialType

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newDihedralConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DihedralConstraint
    """
    return DihedralConstraint(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setOrigin = AbstractConstraintList.setOrigin

  setPotentialType = AbstractConstraintList.setPotentialType

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DihedralConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  origin = AbstractConstraintList.origin

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  potentialType = AbstractConstraintList.potentialType

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class DihedralConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  parent = AbstractConstraintList.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DihedralConstraintList', DihedralConstraintList)

###############################################################################
class CsaConstraintList(AbstractConstraintList):
  r"""List of chemical shift anisotropy constraints
  """
  #   from data model element ccp.nmr.NmrConstraint.CsaConstraintList
  _metaclass = metaPackage.getElement('CsaConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'isotopeCode', 'measureListSerials', 'metaclass', 'name', 'origin', 'packageName', 'packageShortName', 'potentialType', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'conditionState', 'constraints', 'experiments', 'isotope', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['isotopeCode'] = None
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['origin'] = None
      dataDict['potentialType'] = 'unknown'
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.CsaConstraintList', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.CsaConstraintList.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.CsaConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.CsaConstraintList:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.CsaConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.CsaConstraintList:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    nmrConstraintStore = dataDict.get('nmrConstraintStore')

    childrenDict = nmrConstraintStore.__dict__.get('constraintLists')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeUnDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.add(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeUnDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isotopeCode')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: isotopeCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origin')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: origin:
           ccp.nmr.NmrConstraint.ConstraintOrigin: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: origin:
           ConstraintOrigin constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('potentialType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: potentialType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: potentialType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link conditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, CsaConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.CsaConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link constraints from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = self.getIsotope()
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.molecule.ChemElement import Isotope as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: isotope:
           value is not of class ccp.molecule.ChemElement.Isotope""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: isotope:
           Link isotope between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link nmrConstraintListValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    value = dataDict.get('isotopeCode')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('origin')
    value = dataDict.get('potentialType')
    if (value is None):
      raise ApiError("""%s.checkValid: potentialType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.CsaConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.CsaConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.CsaConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, CsaConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getIsotope(self):
    """
    getter for derived link isotope
    """
    dataDict = self.__dict__
    ss = self.isotopeCode
    if ss is None:
      result = None
    else:
      if ss[-2] in '0123456789':
        firstLetter = -1
      else:
        firstLetter = -2
      atomSymbol = ss[firstLetter:].capitalize()
      massNumber = int(ss[:firstLetter])
    
      result = ccpnmodel.ccpncore.api.ccp.molecule.ChemElement.Isotope.getByKey(self.root.currentChemElementStore, (atomSymbol, massNumber))
    return result
  
  def getIsotopeCode(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraintList.isotopeCode
    """
    dataDict = self.__dict__
    result = dataDict.get('isotopeCode')
    return result

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getOrigin = AbstractConstraintList.getOrigin

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getPotentialType = AbstractConstraintList.getPotentialType

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newCsaConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.CsaConstraint
    """
    return CsaConstraint(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments
  
  def setIsotopeCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CsaConstraintList.isotopeCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setIsotopeCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isotopeCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsotopeCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsotopeCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['isotopeCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsotopeCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setIsotopeCode, self.setIsotopeCode,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setOrigin = AbstractConstraintList.setOrigin

  setPotentialType = AbstractConstraintList.setPotentialType

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.CsaConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  isotopeCode = property(getIsotopeCode, setIsotopeCode, None,
  r"""String indicating Isotope (e.g. 13C, 3He, 2H, 235U  ...) to which all 
  chemical shift anisotropies in list should belong
  """)

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  origin = AbstractConstraintList.origin

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  potentialType = AbstractConstraintList.potentialType

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class CsaConstraint
  """)

  experiments = AbstractConstraintList.experiments
  
  isotope = property(getIsotope, None, None,
  r"""Isotope for Constraints in Chemical Shift Anisotropy Constraint List
  """)

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  parent = AbstractConstraintList.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.CsaConstraintList', CsaConstraintList)

###############################################################################
class HBondContribution(ConstraintContribution):
  r"""Hydrogen bond constraint contribution
  """
  #   from data model element ccp.nmr.NmrConstraint.HBondContribution
  _metaclass = metaPackage.getElement('HBondContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.HBondContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, HBondConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.HBondConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.HBondContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.HBondContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.HBondContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.HBondContribution:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.HBondContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.HBondContribution:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.HBondContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.HBondContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, HBondConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.HBondConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, HBondItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.HBondItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.HBondContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.HBondContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.HBondContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.HBondContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondContribution.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.HBondContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.HBondContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondContribution.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newHBondItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.HBondItem
    """
    return HBondItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.HBondContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setLowerLimit = ConstraintContribution.setLowerLimit

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.HBondContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class HBondItem
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.HBondContribution', HBondContribution)

###############################################################################
class ChemicalShiftContribution(ConstraintContribution):
  r"""
  """
  #   from data model element ccp.nmr.NmrConstraint.ChemicalShiftContribution
  _metaclass = metaPackage.getElement('ChemicalShiftContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, ChemicalShiftConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.ChemicalShiftConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ChemicalShiftContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ChemicalShiftContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ChemicalShiftContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ChemicalShiftContribution:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ChemicalShiftContribution:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ChemicalShiftContribution:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, ChemicalShiftConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.ChemicalShiftConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, ChemicalShiftItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.ChemicalShiftItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ChemicalShiftContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ChemicalShiftContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonance')
      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemicalShiftContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemicalShiftContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftContribution.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftContribution.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newChemicalShiftItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ChemicalShiftItem
    """
    return ChemicalShiftItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setLowerLimit = ConstraintContribution.setLowerLimit

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ChemicalShiftContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class ChemicalShiftItem
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ChemicalShiftContribution', ChemicalShiftContribution)

###############################################################################
class DihedralContribution(ConstraintContribution):
  r"""Dihedral constraint contribution
  """
  #   from data model element ccp.nmr.NmrConstraint.DihedralContribution
  _metaclass = metaPackage.getElement('DihedralContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DihedralContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, DihedralConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DihedralContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DihedralContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DihedralContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DihedralContribution:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DihedralContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DihedralContribution:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DihedralContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DihedralContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, DihedralConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, DihedralItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.DihedralItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = tuple(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DihedralContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DihedralContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralContribution.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DihedralContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DihedralContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralContribution.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newDihedralItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DihedralItem
    """
    return DihedralItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DihedralContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setLowerLimit = ConstraintContribution.setLowerLimit

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DihedralContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class DihedralItem
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DihedralContribution', DihedralContribution)

###############################################################################
class CsaContribution(ConstraintContribution):
  r"""Cheical Shift Anisotropy constraint contribution
  """
  #   from data model element ccp.nmr.NmrConstraint.CsaContribution
  _metaclass = metaPackage.getElement('CsaContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.CsaContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, CsaConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.CsaConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.CsaContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.CsaContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.CsaContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.CsaContribution:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.CsaContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.CsaContribution:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.CsaContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.CsaContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, CsaConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.CsaConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, CsaItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.CsaItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.CsaContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.CsaContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonance')
      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.CsaContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.CsaContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaContribution.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.CsaContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.CsaContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaContribution.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newCsaItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.CsaItem
    """
    return CsaItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.CsaContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setLowerLimit = ConstraintContribution.setLowerLimit

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.CsaContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class CsaItem
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.CsaContribution', CsaContribution)

###############################################################################
class JCouplingContribution(ConstraintContribution):
  r""" J Coupling constraint contribution
  """
  #   from data model element ccp.nmr.NmrConstraint.JCouplingContribution
  _metaclass = metaPackage.getElement('JCouplingContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.JCouplingContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, JCouplingConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.JCouplingConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.JCouplingContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.JCouplingContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.JCouplingContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.JCouplingContribution:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.JCouplingContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.JCouplingContribution:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.JCouplingContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.JCouplingContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, JCouplingConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.JCouplingConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, JCouplingItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.JCouplingItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.JCouplingContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.JCouplingContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.JCouplingContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.JCouplingContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingContribution.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.JCouplingContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.JCouplingContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingContribution.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newJCouplingItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.JCouplingItem
    """
    return JCouplingItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.JCouplingContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setLowerLimit = ConstraintContribution.setLowerLimit

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.JCouplingContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class JCouplingItem
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.JCouplingContribution', JCouplingContribution)

###############################################################################
class RdcContribution(ConstraintContribution):
  r"""Rdc constraint contribution
  """
  #   from data model element ccp.nmr.NmrConstraint.RdcContribution
  _metaclass = metaPackage.getElement('RdcContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'isDistanceDependent', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.RdcContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, RdcConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.RdcConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['isDistanceDependent'] = False
      dataDict['lowerLimit'] = None
      dataDict['scale'] = 1.0
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.RdcContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.RdcContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.RdcContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.RdcContribution:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.RdcContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.RdcContribution:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.RdcContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.RdcContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isDistanceDependent')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: isDistanceDependent:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('scale')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: scale:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.checkValid: scale:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: scale:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, RdcConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.RdcConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, RdcItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.RdcItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('isDistanceDependent')
    if (value is None):
      raise ApiError("""%s.checkValid: isDistanceDependent:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('lowerLimit')
    value = dataDict.get('scale')
    if (value is None):
      raise ApiError("""%s.checkValid: scale:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.RdcContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.RdcContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.RdcContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.RdcContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcContribution.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.RdcContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getIsDistanceDependent(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcContribution.isDistanceDependent
    """
    dataDict = self.__dict__
    result = dataDict.get('isDistanceDependent')
    return result
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.RdcContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcContribution.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getScale(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcContribution.scale
    """
    dataDict = self.__dict__
    result = dataDict.get('scale')
    return result

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newRdcItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.RdcItem
    """
    return RdcItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.RdcContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError
  
  def setIsDistanceDependent(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcContribution.isDistanceDependent
    """
    dataDict = self.__dict__
    if (not (value in [True, False])):
      raise ApiError("""%s.setIsDistanceDependent:
       memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isDistanceDependent')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsDistanceDependent:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsDistanceDependent:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setIsDistanceDependent:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['isDistanceDependent'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsDistanceDependent')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setIsDistanceDependent, self.setIsDistanceDependent,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setLowerLimit = ConstraintContribution.setLowerLimit
  
  def setScale(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcContribution.scale
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setScale:
       memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value > 0)):
      raise ApiError("""%s.setScale:
       PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setScale:
       PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('scale')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setScale:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setScale:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setScale:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['scale'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setScale')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setScale, self.setScale,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.RdcContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  isDistanceDependent = property(getIsDistanceDependent, setIsDistanceDependent, None,
  r"""Is restraint value dependent on a variable interatomic distance?
  """)

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  scale = property(getScale, setScale, None,
  r"""scaling factor to be multiplied with the given value to give a value 
  that is comaprable with other restraint values
  """)

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class RdcItem
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.RdcContribution', RdcContribution)

###############################################################################
class DistanceContribution(ConstraintContribution):
  r"""Distance constraint contribution
  """
  #   from data model element ccp.nmr.NmrConstraint.DistanceContribution
  _metaclass = metaPackage.getElement('DistanceContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DistanceContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, DistanceConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DistanceConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DistanceContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DistanceContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DistanceContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DistanceContribution:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DistanceContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DistanceContribution:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DistanceContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DistanceContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, DistanceConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.DistanceConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, DistanceItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.DistanceItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DistanceContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DistanceContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DistanceContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DistanceContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceContribution.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DistanceContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DistanceContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceContribution.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newDistanceItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DistanceItem
    """
    return DistanceItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DistanceContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setLowerLimit = ConstraintContribution.setLowerLimit

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DistanceContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class DistanceItem
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DistanceContribution', DistanceContribution)

###############################################################################
class GenericContribution(ConstraintContribution):
  r"""
  """
  #   from data model element ccp.nmr.NmrConstraint.GenericContribution
  _metaclass = metaPackage.getElement('GenericContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'isDistanceDependent', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllItems = ConstraintContribution.findAllItems

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstItem = ConstraintContribution.findFirstItem

  findUnorderedItem = ConstraintContribution.findUnorderedItem

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.GenericContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.GenericContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.GenericContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericContribution.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.GenericContribution
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getIsDistanceDependent(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericContribution.isDistanceDependent
    """
    dataDict = self.__dict__
    result = dataDict.get('isDistanceDependent')
    return result

  getItems = ConstraintContribution.getItems
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.GenericContribution
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericContribution.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getScale(self):
    """
    Get for ccp.nmr.NmrConstraint.GenericContribution.scale
    """
    dataDict = self.__dict__
    result = dataDict.get('scale')
    return result

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError
  
  def setIsDistanceDependent(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericContribution.isDistanceDependent
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not (value in [True, False])):
        raise ApiError("""%s.setIsDistanceDependent:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isDistanceDependent')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsDistanceDependent:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsDistanceDependent:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['isDistanceDependent'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsDistanceDependent')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setIsDistanceDependent, self.setIsDistanceDependent,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setLowerLimit = ConstraintContribution.setLowerLimit
  
  def setScale(self, value):
    """
    Set for ccp.nmr.NmrConstraint.GenericContribution.scale
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setScale:
       memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value > 0)):
      raise ApiError("""%s.setScale:
       PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setScale:
       PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('scale')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setScale:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setScale:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setScale:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['scale'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setScale')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setScale, self.setScale,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedItems = ConstraintContribution.sortedItems

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  isDistanceDependent = property(getIsDistanceDependent, setIsDistanceDependent, None,
  r"""Is restraint value dependent on a variable interatomic distance? Used 
  for e.g. Rdc constraints. Set to None for restraint types wheree the 
  distinction is not relevant (e.g. for distance constraints). 
  """)

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  scale = property(getScale, setScale, None,
  r"""scaling factor to be multiplied with the given value to give a value 
  that is comparable with other restraint values
  """)

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  items = ConstraintContribution.items
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.GenericContribution', GenericContribution)

###############################################################################
class ChemicalShiftItem(ConstraintItem):
  r"""Item (resonance) for contribution. Item (resonance) for contribution. 
  """
  #   from data model element ccp.nmr.NmrConstraint.ChemicalShiftItem
  _metaclass = metaPackage.getElement('ChemicalShiftItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonance', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ChemicalShiftItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, ChemicalShiftContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.ChemicalShiftContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonance'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ChemicalShiftItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ChemicalShiftItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonance')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonance'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ChemicalShiftItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ChemicalShiftItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeDeleted))):
      chemicalShiftItems = resonance.__dict__.get('chemicalShiftItems')
      chemicalShiftItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ChemicalShiftItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonance'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeUnDeleted))):
      chemicalShiftItems = resonance.__dict__.get('chemicalShiftItems')
      chemicalShiftItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ChemicalShiftItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ChemicalShiftItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, ChemicalShiftContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.ChemicalShiftContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('resonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: resonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('chemicalShiftItems')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: resonance:
         non-reciprocal link resonance from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('resonance')
    if (value is None):
      raise ApiError("""%s.checkValid: resonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ChemicalShiftItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ChemicalShiftItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemicalShiftItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemicalShiftItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-2]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            objKey = fullKey[-1]
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ChemicalShiftItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    result.append(dataDict.get('resonance'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ChemicalShiftItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftItem.resonance
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ChemicalShiftItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ChemicalShiftItem.resonance
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.setResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonance:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonance:
         cannot set resonance, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setResonance:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setResonance:
         Link resonance between objects from separate partitions
          - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('chemicalShiftItems')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonance:
         Read link 'resonance' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('chemicalShiftItems')
      newSelves.add(self)

    dataDict['resonance'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonance = property(getResonance, setResonance, None,
  r"""FixedResonance efining ChemShiftItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ChemicalShiftItem', ChemicalShiftItem)

###############################################################################
class JCouplingItem(ConstraintItem):
  r"""Items (resonance pairs) for contribution. Resonance pairs are ordered, 
but a-b and b-a cannot appear simultaneously.
  """
  #   from data model element ccp.nmr.NmrConstraint.JCouplingItem
  _metaclass = metaPackage.getElement('JCouplingItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.JCouplingItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, JCouplingContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.JCouplingContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.JCouplingItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.JCouplingItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.JCouplingItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.JCouplingItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        resonance.__dict__['jCouplingItem'] = None

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.JCouplingItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        if (resonance.__dict__.get('jCouplingItem') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of JCouplingItem object resonances link - backLink FixedResonance.jCouplingItem is not None""" % self.qualifiedName
          )

        resonance.__dict__['jCouplingItem'] = self

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.JCouplingItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.JCouplingItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, JCouplingContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.JCouplingContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('jCouplingItem')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.JCouplingItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.JCouplingItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.JCouplingItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.JCouplingItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (6 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-5]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-4]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-3]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            tempList = list()
            tempList.append(fullKey[-2])
            tempList.append(fullKey[-1])
            objKey = frozenset(tempList)
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.JCouplingItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.JCouplingItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.JCouplingItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.JCouplingItem.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 2)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      oldSelves = {}
      for cv in values:
        if (not (cv in currentValues)):
          oldSelf = cv.__dict__.get('jCouplingItem')
          if (oldSelf is not None):
            knt = oldSelves.get(oldSelf)
            if (knt is None):
              knt = 1
            else:
              knt = knt + 1

            oldSelves[oldSelf] = knt

      for osv in oldSelves.keys():
        siblingValues = osv.__dict__.get('resonances')
        knt = oldSelves.get(osv)
        if (len(siblingValues) < (2 + knt)):
          raise ApiError("""%s.setResonances:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['jCouplingItem'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('jCouplingItem')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('resonances')
          vv.remove(cv)

      cv.__dict__['jCouplingItem'] = self

    dataDict['resonances'] = values

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.JCouplingItem.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""FixedResonance pair that identify JCouplingItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.JCouplingItem', JCouplingItem)

###############################################################################
class CsaItem(ConstraintItem):
  r"""Item (resonance) for contribution. 
  """
  #   from data model element ccp.nmr.NmrConstraint.CsaItem
  _metaclass = metaPackage.getElement('CsaItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonance', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.CsaItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, CsaContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.CsaContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonance'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.CsaItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.CsaItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonance')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonance'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.CsaItem:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.CsaItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeDeleted))):
      csaItems = resonance.__dict__.get('csaItems')
      csaItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.CsaItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonance'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeUnDeleted))):
      csaItems = resonance.__dict__.get('csaItems')
      csaItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.CsaItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.CsaItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, CsaContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.CsaContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('resonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: resonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('csaItems')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: resonance:
         non-reciprocal link resonance from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('resonance')
    if (value is None):
      raise ApiError("""%s.checkValid: resonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.CsaItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.CsaItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-2]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            objKey = fullKey[-1]
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.CsaItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    result.append(dataDict.get('resonance'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.CsaItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaItem.resonance
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.CsaItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CsaItem.resonance
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.setResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonance:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonance:
         cannot set resonance, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setResonance:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setResonance:
         Link resonance between objects from separate partitions
          - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('csaItems')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonance:
         Read link 'resonance' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('csaItems')
      newSelves.add(self)

    dataDict['resonance'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonance = property(getResonance, setResonance, None,
  r"""FixedResonance defining CsaItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.CsaItem', CsaItem)

###############################################################################
class DistanceItem(ConstraintItem):
  r"""Items (resonance pairs) for contribution. Resonance pairs are ordered, 
but a-b and b-a cannot appear simultaneously.
  """
  #   from data model element ccp.nmr.NmrConstraint.DistanceItem
  _metaclass = metaPackage.getElement('DistanceItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DistanceItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, DistanceContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DistanceContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DistanceItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DistanceItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DistanceItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DistanceItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        distanceItems = resonance.__dict__.get('distanceItems')
        distanceItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DistanceItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        distanceItems = resonance.__dict__.get('distanceItems')
        distanceItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DistanceItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DistanceItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, DistanceContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.DistanceContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('distanceItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DistanceItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DistanceItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DistanceItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DistanceItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (6 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-5]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-4]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-3]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            tempList = list()
            tempList.append(fullKey[-2])
            tempList.append(fullKey[-1])
            objKey = frozenset(tempList)
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DistanceItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DistanceItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DistanceItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.DistanceItem.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 2)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('distanceItems')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('distanceItems')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DistanceItem.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""FixedResonance pair that identify DistanceItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DistanceItem', DistanceItem)

###############################################################################
class SingleAtomItem(ConstraintItem):
  r"""ConstraintItem linked to single FIxedResonance (atom).
  """
  #   from data model element ccp.nmr.NmrConstraint.SingleAtomItem
  _metaclass = metaPackage.getElement('SingleAtomItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonance', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.SingleAtomItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, SingleAtomContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.SingleAtomContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonance'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.SingleAtomItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.SingleAtomItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonance')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonance'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.SingleAtomItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.SingleAtomItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeDeleted))):
      singleAtomItems = resonance.__dict__.get('singleAtomItems')
      singleAtomItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.SingleAtomItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonance'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeUnDeleted))):
      singleAtomItems = resonance.__dict__.get('singleAtomItems')
      singleAtomItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.SingleAtomItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.SingleAtomItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, SingleAtomContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.SingleAtomContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('resonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: resonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('singleAtomItems')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: resonance:
         non-reciprocal link resonance from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('resonance')
    if (value is None):
      raise ApiError("""%s.checkValid: resonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.SingleAtomItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.SingleAtomItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.SingleAtomItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.SingleAtomItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-2]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            objKey = fullKey[-1]
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleAtomItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.SingleAtomItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    result.append(dataDict.get('resonance'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.SingleAtomItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleAtomItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleAtomItem.resonance
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.SingleAtomItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleAtomItem.resonance
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.setResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonance:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonance:
         cannot set resonance, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setResonance:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setResonance:
         Link resonance between objects from separate partitions
          - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('singleAtomItems')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonance:
         Read link 'resonance' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('singleAtomItems')
      newSelves.add(self)

    dataDict['resonance'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonance = property(getResonance, setResonance, None,
  r"""Resonance defining SingleAtomItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.SingleAtomItem', SingleAtomItem)

###############################################################################
class AtomPairItem(ConstraintItem):
  r"""ConstraintItem linked to pair of FixedResonances (atoms)
  """
  #   from data model element ccp.nmr.NmrConstraint.AtomPairItem
  _metaclass = metaPackage.getElement('AtomPairItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.AtomPairItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, AtomPairContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.AtomPairContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.AtomPairItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.AtomPairItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.AtomPairItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.AtomPairItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        atomPairItems = resonance.__dict__.get('atomPairItems')
        atomPairItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.AtomPairItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        atomPairItems = resonance.__dict__.get('atomPairItems')
        atomPairItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.AtomPairItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.AtomPairItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, AtomPairContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.AtomPairContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('atomPairItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AtomPairItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AtomPairItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.AtomPairItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.AtomPairItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (6 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AtomPairItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AtomPairItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-5]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-4]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-3]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            tempList = list()
            tempList.append(fullKey[-2])
            tempList.append(fullKey[-1])
            objKey = frozenset(tempList)
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.AtomPairItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.AtomPairItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.AtomPairItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.AtomPairItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.AtomPairItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.AtomPairItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AtomPairItem.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 2)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('atomPairItems')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('atomPairItems')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AtomPairItem.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""Resonances pair defining AtomPairItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.AtomPairItem', AtomPairItem)

###############################################################################
class DihedralItem(ConstraintItem):
  r"""ConstraintItem linked to ordered quadruple of FicxedResonances(atoms) 
used for dihedral constraints. Resonance quadruples are ordered, but a-b 
-c-d and d-c-b-a cannot appear simultaneously.
  """
  #   from data model element ccp.nmr.NmrConstraint.DihedralItem
  _metaclass = metaPackage.getElement('DihedralItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DihedralItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, DihedralContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DihedralContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonances'] = list()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DihedralItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DihedralItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = tuple(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DihedralItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DihedralItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        dihedralItems = resonance.__dict__.get('dihedralItems')
        dihedralItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = tuple(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DihedralItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = tuple(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        dihedralItems = resonance.__dict__.get('dihedralItems')
        dihedralItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DihedralItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DihedralItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = tuple(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, DihedralContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.DihedralContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dihedralItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    if (not (self.parent.findFirstItem(resonances=reversed(self.resonances)) is None)):
      raise ApiError("""%s.checkValid:
       constraint no_Dihedral_item_with_resonances_in_opposite_order violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (not (len(values) == 4)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 4""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = list(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DihedralItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DihedralItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (8 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (7 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-7]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-6]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-5]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            tempList = list()
            tempList.append(fullKey[-4])
            tempList.append(fullKey[-3])
            tempList.append(fullKey[-2])
            tempList.append(fullKey[-1])
            objKey = tuple(tempList)
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DihedralItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DihedralItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = tuple(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = tuple(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DihedralItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.DihedralItem.resonances
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 4)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 4""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('dihedralItems')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('dihedralItems')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""FixedResonance quartet that identify DihedralItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DihedralItem', DihedralItem)

###############################################################################
class FourAtomItem(ConstraintItem):
  r"""ConstraintItem linked to four ordered FixedResonances (atoms)
  """
  #   from data model element ccp.nmr.NmrConstraint.FourAtomItem
  _metaclass = metaPackage.getElement('FourAtomItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.FourAtomItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, FourAtomContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.FourAtomContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonances'] = list()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.FourAtomItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.FourAtomItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = tuple(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.FourAtomItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.FourAtomItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        fourAtomItems = resonance.__dict__.get('fourAtomItems')
        fourAtomItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = tuple(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.FourAtomItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = tuple(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        fourAtomItems = resonance.__dict__.get('fourAtomItems')
        fourAtomItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.FourAtomItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.FourAtomItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = tuple(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, FourAtomContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.FourAtomContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('fourAtomItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    if (not (self.parent.findFirstItem(resonances=reversed(self.resonances)) is None)):
      raise ApiError("""%s.checkValid:
       constraint no_Dihedral_item_with_resonances_in_opposite_order violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (not (len(values) == 4)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 4""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FourAtomItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = list(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FourAtomItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.FourAtomItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.FourAtomItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (8 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FourAtomItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (7 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FourAtomItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-7]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-6]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-5]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            tempList = list()
            tempList.append(fullKey[-4])
            tempList.append(fullKey[-3])
            tempList.append(fullKey[-2])
            tempList.append(fullKey[-1])
            objKey = tuple(tempList)
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.FourAtomItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.FourAtomItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.FourAtomItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = tuple(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.FourAtomItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.FourAtomItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = tuple(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.FourAtomItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FourAtomItem.resonances
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 4)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 4""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('fourAtomItems')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('fourAtomItems')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.FourAtomItem', FourAtomItem)

###############################################################################
class HBondItem(ConstraintItem):
  r"""Items (resonance pairs) for contribution. Resonance pairs are ordered, 
but a-b and b-a cannot appear simultaneously.
  """
  #   from data model element ccp.nmr.NmrConstraint.HBondItem
  _metaclass = metaPackage.getElement('HBondItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.HBondItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, HBondContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.HBondContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.HBondItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.HBondItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.HBondItem:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.HBondItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        hBondItems = resonance.__dict__.get('hBondItems')
        hBondItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.HBondItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        hBondItems = resonance.__dict__.get('hBondItems')
        hBondItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.HBondItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.HBondItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, HBondContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.HBondContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('hBondItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.HBondItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.HBondItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.HBondItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.HBondItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (6 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-5]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-4]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-3]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            tempList = list()
            tempList.append(fullKey[-2])
            tempList.append(fullKey[-1])
            objKey = frozenset(tempList)
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.HBondItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.HBondItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.HBondItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.HBondItem.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 2)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('hBondItems')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('hBondItems')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.HBondItem.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""FixedResonance pair that identify HBondItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.HBondItem', HBondItem)

###############################################################################
class RdcItem(ConstraintItem):
  r"""Items (resonance pairs) for contribution. Resonance pairs are ordered, 
but a-b and b-a cannot appear simultaneously.
  """
  #   from data model element ccp.nmr.NmrConstraint.RdcItem
  _metaclass = metaPackage.getElement('RdcItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'contribution', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.RdcItem
    """
    dataDict = self.__dict__
    dataDict['contribution'] = parent
    if (not isinstance(parent, RdcContribution)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.RdcContribution""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.RdcItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.RdcItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.RdcItem:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.RdcItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        rdcItems = resonance.__dict__.get('rdcItems')
        rdcItems.remove(self)

    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = contribution.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.RdcItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    contribution = dataDict.get('contribution')
    if (not (contribution in objsToBeUnDeleted)):

      childrenDict = contribution.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        rdcItems = resonance.__dict__.get('rdcItems')
        rdcItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.RdcItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.RdcItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('contribution')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'contribution' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('contribution')
      if (not isinstance(value, RdcContribution)):
        raise ApiError("""%s.checkValid: contribution:
         value is not of class ccp.nmr.NmrConstraint.RdcContribution""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('rdcItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('contribution')
    if (value is None):
      raise ApiError("""%s.checkValid: contribution:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.RdcItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.RdcItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'chainCode', 'details', 'isotopeCode', 'name', 'residueType', 'resonanceSerial', 'sequenceCode', 'serial', 'jCouplingItem', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.RdcItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.RdcItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (6 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-5]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-4]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-3]
          obj4 = obj3.__dict__.get('contributions').get(objKey)

          if (obj4 is not None):
            tempList = list()
            tempList.append(fullKey[-2])
            tempList.append(fullKey[-1])
            objKey = frozenset(tempList)
            obj5 = obj4.__dict__.get('items').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getContribution(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcItem.contribution
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.RdcItem
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('contribution')
    obj3 = obj4.__dict__.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.RdcItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('contribution')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.RdcItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.RdcItem.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 2)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('rdcItems')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('rdcItems')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.RdcItem.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  contribution = property(getContribution,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for contribution
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""FixedResonance pair that identify RdcItem
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.RdcItem', RdcItem)

###############################################################################
class RdcConstraintItem(PairwiseConstraintItem):
  r"""Pair of Resonances involved in a reduced dipolarcoupling restraint
  """
  #   from data model element ccp.nmr.NmrConstraint.RdcConstraintItem
  _metaclass = metaPackage.getElement('RdcConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'constraint', 'firstResonance', 'orderedResonances', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, RdcConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.RdcConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['firstResonance'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.RdcConstraintItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.RdcConstraintItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.RdcConstraintItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.RdcConstraintItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.RdcConstraintItem:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addOrderedResonance = PairwiseConstraintItem.addOrderedResonance
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, RdcConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.RdcConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('firstResonance')
      if (value is not None):
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: firstResonance:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: firstResonance:
           Link firstResonance between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedResonances()
      if (len(values) > 2):
        raise ApiError("""%s.checkValid: orderedResonances:
         hicard: values must be of length <= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: orderedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedResonances:
           Link orderedResonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('pairwiseConstraintItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('firstResonance')
    if (value is not None):
      if (not (value in self.resonances)):
        raise ApiError("""%s.checkValid: firstResonance:
         firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllOrderedResonances = PairwiseConstraintItem.findAllOrderedResonances

  findAllResonances = PairwiseConstraintItem.findAllResonances

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedResonance = PairwiseConstraintItem.findFirstOrderedResonance

  findFirstResonance = PairwiseConstraintItem.findFirstResonance
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.RdcConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          tempList = list()
          tempList.append(fullKey[-2])
          tempList.append(fullKey[-1])
          objKey = frozenset(tempList)
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFirstResonance = PairwiseConstraintItem.getFirstResonance
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getOrderedResonances = PairwiseConstraintItem.getOrderedResonances

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getResonances = PairwiseConstraintItem.getResonances

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeOrderedResonance = PairwiseConstraintItem.removeOrderedResonance
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setFirstResonance = PairwiseConstraintItem.setFirstResonance

  setOrderedResonances = PairwiseConstraintItem.setOrderedResonances

  setResonances = PairwiseConstraintItem.setResonances

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedResonances = PairwiseConstraintItem.sortedResonances

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  firstResonance = PairwiseConstraintItem.firstResonance

  orderedResonances = PairwiseConstraintItem.orderedResonances
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  resonances = PairwiseConstraintItem.resonances

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.RdcConstraintItem', RdcConstraintItem)

###############################################################################
class HBondConstraintItem(PairwiseConstraintItem):
  r"""Pair of Resonances involved in a hydrogen bond restraint.
The two 
Resonances pointed to are given in the order 1) Hydrogen, 2) Hydrogen 
acceptor
  """
  #   from data model element ccp.nmr.NmrConstraint.HBondConstraintItem
  _metaclass = metaPackage.getElement('HBondConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'constraint', 'firstResonance', 'orderedResonances', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, HBondConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.HBondConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['firstResonance'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.HBondConstraintItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.HBondConstraintItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.HBondConstraintItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.HBondConstraintItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.HBondConstraintItem:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addOrderedResonance = PairwiseConstraintItem.addOrderedResonance
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, HBondConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.HBondConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('firstResonance')
      if (value is not None):
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: firstResonance:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: firstResonance:
           Link firstResonance between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedResonances()
      if (len(values) > 2):
        raise ApiError("""%s.checkValid: orderedResonances:
         hicard: values must be of length <= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: orderedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedResonances:
           Link orderedResonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('pairwiseConstraintItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('firstResonance')
    if (value is not None):
      if (not (value in self.resonances)):
        raise ApiError("""%s.checkValid: firstResonance:
         firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllOrderedResonances = PairwiseConstraintItem.findAllOrderedResonances

  findAllResonances = PairwiseConstraintItem.findAllResonances

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedResonance = PairwiseConstraintItem.findFirstOrderedResonance

  findFirstResonance = PairwiseConstraintItem.findFirstResonance
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.HBondConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          tempList = list()
          tempList.append(fullKey[-2])
          tempList.append(fullKey[-1])
          objKey = frozenset(tempList)
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFirstResonance = PairwiseConstraintItem.getFirstResonance
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getOrderedResonances = PairwiseConstraintItem.getOrderedResonances

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getResonances = PairwiseConstraintItem.getResonances

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeOrderedResonance = PairwiseConstraintItem.removeOrderedResonance
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setFirstResonance = PairwiseConstraintItem.setFirstResonance

  setOrderedResonances = PairwiseConstraintItem.setOrderedResonances

  setResonances = PairwiseConstraintItem.setResonances

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedResonances = PairwiseConstraintItem.sortedResonances

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  firstResonance = PairwiseConstraintItem.firstResonance

  orderedResonances = PairwiseConstraintItem.orderedResonances
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  resonances = PairwiseConstraintItem.resonances

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.HBondConstraintItem', HBondConstraintItem)

###############################################################################
class DistanceConstraintItem(PairwiseConstraintItem):
  r"""Pair of Resonances involved in a distance restraint
  """
  #   from data model element ccp.nmr.NmrConstraint.DistanceConstraintItem
  _metaclass = metaPackage.getElement('DistanceConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'constraint', 'firstResonance', 'orderedResonances', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, DistanceConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DistanceConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['firstResonance'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DistanceConstraintItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DistanceConstraintItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DistanceConstraintItem:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DistanceConstraintItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DistanceConstraintItem:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addOrderedResonance = PairwiseConstraintItem.addOrderedResonance
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, DistanceConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.DistanceConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('firstResonance')
      if (value is not None):
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: firstResonance:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: firstResonance:
           Link firstResonance between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedResonances()
      if (len(values) > 2):
        raise ApiError("""%s.checkValid: orderedResonances:
         hicard: values must be of length <= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: orderedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedResonances:
           Link orderedResonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('pairwiseConstraintItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('firstResonance')
    if (value is not None):
      if (not (value in self.resonances)):
        raise ApiError("""%s.checkValid: firstResonance:
         firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllOrderedResonances = PairwiseConstraintItem.findAllOrderedResonances

  findAllResonances = PairwiseConstraintItem.findAllResonances

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedResonance = PairwiseConstraintItem.findFirstOrderedResonance

  findFirstResonance = PairwiseConstraintItem.findFirstResonance
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          tempList = list()
          tempList.append(fullKey[-2])
          tempList.append(fullKey[-1])
          objKey = frozenset(tempList)
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFirstResonance = PairwiseConstraintItem.getFirstResonance
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getOrderedResonances = PairwiseConstraintItem.getOrderedResonances

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getResonances = PairwiseConstraintItem.getResonances

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeOrderedResonance = PairwiseConstraintItem.removeOrderedResonance
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setFirstResonance = PairwiseConstraintItem.setFirstResonance

  setOrderedResonances = PairwiseConstraintItem.setOrderedResonances

  setResonances = PairwiseConstraintItem.setResonances

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedResonances = PairwiseConstraintItem.sortedResonances

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  firstResonance = PairwiseConstraintItem.firstResonance

  orderedResonances = PairwiseConstraintItem.orderedResonances
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  resonances = PairwiseConstraintItem.resonances

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DistanceConstraintItem', DistanceConstraintItem)

###############################################################################
class JCouplingConstraintItem(PairwiseConstraintItem):
  r"""Pair of Resonances involved in a J coupling restraint
  """
  #   from data model element ccp.nmr.NmrConstraint.JCouplingConstraintItem
  _metaclass = metaPackage.getElement('JCouplingConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'constraint', 'firstResonance', 'orderedResonances', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, JCouplingConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.JCouplingConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['firstResonance'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.JCouplingConstraintItem', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.JCouplingConstraintItem.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.JCouplingConstraintItem:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.JCouplingConstraintItem:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.JCouplingConstraintItem:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('items')
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addOrderedResonance = PairwiseConstraintItem.addOrderedResonance
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, JCouplingConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.JCouplingConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('firstResonance')
      if (value is not None):
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: firstResonance:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: firstResonance:
           Link firstResonance between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedResonances()
      if (len(values) > 2):
        raise ApiError("""%s.checkValid: orderedResonances:
         hicard: values must be of length <= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: orderedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedResonances:
           Link orderedResonances between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('pairwiseConstraintItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('firstResonance')
    if (value is not None):
      if (not (value in self.resonances)):
        raise ApiError("""%s.checkValid: firstResonance:
         firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllOrderedResonances = PairwiseConstraintItem.findAllOrderedResonances

  findAllResonances = PairwiseConstraintItem.findAllResonances

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedResonance = PairwiseConstraintItem.findFirstOrderedResonance

  findFirstResonance = PairwiseConstraintItem.findFirstResonance
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          tempList = list()
          tempList.append(fullKey[-2])
          tempList.append(fullKey[-1])
          objKey = frozenset(tempList)
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFirstResonance = PairwiseConstraintItem.getFirstResonance
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getOrderedResonances = PairwiseConstraintItem.getOrderedResonances

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getResonances = PairwiseConstraintItem.getResonances

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeOrderedResonance = PairwiseConstraintItem.removeOrderedResonance
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setFirstResonance = PairwiseConstraintItem.setFirstResonance

  setOrderedResonances = PairwiseConstraintItem.setOrderedResonances

  setResonances = PairwiseConstraintItem.setResonances

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedResonances = PairwiseConstraintItem.sortedResonances

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  firstResonance = PairwiseConstraintItem.firstResonance

  orderedResonances = PairwiseConstraintItem.orderedResonances
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  resonances = PairwiseConstraintItem.resonances

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.JCouplingConstraintItem', JCouplingConstraintItem)

###############################################################################
class DistanceConstraint(SingleConstraint):
  r"""Distance Constraint. Ambiguous, may contain several 
HBondConstraintItems, each with a different assignment, describing 
alternative assignment possibilities.
  """
  #   from data model element ccp.nmr.NmrConstraint.DistanceConstraint
  _metaclass = metaPackage.getElement('DistanceConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'backCalcVolume', 'ccpnInternalData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraintGroups', 'contributions', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, DistanceConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DistanceConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['backCalcVolume'] = None
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['constraintGroups'] = set()
      dataDict['contributions'] = {}
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.DistanceConstraint', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.DistanceConstraint.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DistanceConstraint')
          )

      serialDict = {}
      serialDict['contributions'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DistanceConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    contributions = dataDict.get('contributions').values()
    for contribution in contributions:
      if (not (contribution in objsToBeDeleted)):
        objsToBeDeleted.add(contribution)
        objsToBeChecked.append(contribution)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DistanceConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.DistanceConstraint:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeUnDeleted)):

      childrenDict = parentList.__dict__.get('constraints')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeUnDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.add(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeUnDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('contributions').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('backCalcVolume')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: backCalcVolume:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: backCalcVolume:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('contributions').values()
      for value in values:
        if (not isinstance(value, DistanceContribution)):
          raise ApiError("""%s.checkValid: contributions:
           value is not of class ccp.nmr.NmrConstraint.DistanceContribution""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: contributions:
           non-reciprocal link contributions from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, DistanceConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.DistanceConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link nmrConstraintValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, DistanceConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.DistanceConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link peakContribs from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('backCalcVolume')
    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    values = dataDict.get('constraintGroups')
    values = dataDict.get('contributions').values()
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DistanceConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('contributions').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DistanceConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DistanceConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('contributions').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('contributions').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DistanceConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getBackCalcVolume(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.backCalcVolume
    """
    dataDict = self.__dict__
    result = dataDict.get('backCalcVolume')
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DistanceConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.contributions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('contributions').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newDistanceConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    return DistanceConstraintItem(self, **attrlinks)
  
  def newDistanceContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DistanceContribution
    """
    return DistanceContribution(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setBackCalcVolume(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DistanceConstraint.backCalcVolume
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setBackCalcVolume:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setBackCalcVolume:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('backCalcVolume')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setBackCalcVolume:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setBackCalcVolume:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['backCalcVolume'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setBackCalcVolume')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setBackCalcVolume, self.setBackCalcVolume,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DistanceConstraint.contributions
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('contributions')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DistanceConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData
  
  backCalcVolume = property(getBackCalcVolume, setBackCalcVolume, None,
  r"""Backcalculated volume.
  """)

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups
  
  contributions = property(getContributions,  None, None,
  r"""child link to class DistanceContribution
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class DistanceConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.DistanceConstraint', DistanceConstraint)

###############################################################################
class HBondConstraint(SingleConstraint):
  r"""Constraint (distance constraint) describing a hydrogen bond.  Ambiguous, 
may contain several HBondConstraintItems, each with a different 
assignment, describing alternative assignment possibilities.
  """
  #   from data model element ccp.nmr.NmrConstraint.HBondConstraint
  _metaclass = metaPackage.getElement('HBondConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraintGroups', 'contributions', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, HBondConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.HBondConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['constraintGroups'] = set()
      dataDict['contributions'] = {}
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.HBondConstraint', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.HBondConstraint.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.HBondConstraint')
          )

      serialDict = {}
      serialDict['contributions'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.HBondConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    contributions = dataDict.get('contributions').values()
    for contribution in contributions:
      if (not (contribution in objsToBeDeleted)):
        objsToBeDeleted.add(contribution)
        objsToBeChecked.append(contribution)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.HBondConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.HBondConstraint:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeUnDeleted)):

      childrenDict = parentList.__dict__.get('constraints')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeUnDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.add(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeUnDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('contributions').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('contributions').values()
      for value in values:
        if (not isinstance(value, HBondContribution)):
          raise ApiError("""%s.checkValid: contributions:
           value is not of class ccp.nmr.NmrConstraint.HBondContribution""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: contributions:
           non-reciprocal link contributions from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, HBondConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.HBondConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link nmrConstraintValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, HBondConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.HBondConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link peakContribs from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    values = dataDict.get('constraintGroups')
    values = dataDict.get('contributions').values()
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.HBondConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('contributions').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.HBondConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.HBondConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('contributions').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('contributions').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.HBondConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.HBondConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraint.contributions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('contributions').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newHBondConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    return HBondConstraintItem(self, **attrlinks)
  
  def newHBondContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.HBondContribution
    """
    return HBondContribution(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.HBondConstraint.contributions
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('contributions')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.HBondConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups
  
  contributions = property(getContributions,  None, None,
  r"""child link to class HBondContribution
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class HBondConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.HBondConstraint', HBondConstraint)

###############################################################################
class JCouplingConstraint(SingleConstraint):
  r"""J coupling constraint. Ambiguous, may contain several 
JCouplingConstraintItems, each with a different assignment, describing 
alternative assignment possibilities.
  """
  #   from data model element ccp.nmr.NmrConstraint.JCouplingConstraint
  _metaclass = metaPackage.getElement('JCouplingConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraintGroups', 'contributions', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, JCouplingConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.JCouplingConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['constraintGroups'] = set()
      dataDict['contributions'] = {}
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.JCouplingConstraint', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.JCouplingConstraint.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.JCouplingConstraint')
          )

      serialDict = {}
      serialDict['contributions'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.JCouplingConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    contributions = dataDict.get('contributions').values()
    for contribution in contributions:
      if (not (contribution in objsToBeDeleted)):
        objsToBeDeleted.add(contribution)
        objsToBeChecked.append(contribution)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.JCouplingConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.JCouplingConstraint:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeUnDeleted)):

      childrenDict = parentList.__dict__.get('constraints')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeUnDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.add(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeUnDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('contributions').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('contributions').values()
      for value in values:
        if (not isinstance(value, JCouplingContribution)):
          raise ApiError("""%s.checkValid: contributions:
           value is not of class ccp.nmr.NmrConstraint.JCouplingContribution""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: contributions:
           non-reciprocal link contributions from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, JCouplingConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.JCouplingConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link nmrConstraintValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, JCouplingConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.JCouplingConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link peakContribs from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    values = dataDict.get('constraintGroups')
    values = dataDict.get('contributions').values()
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.JCouplingConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('contributions').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.JCouplingConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.JCouplingConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('contributions').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('contributions').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.JCouplingConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.JCouplingConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraint.contributions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('contributions').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newJCouplingConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    return JCouplingConstraintItem(self, **attrlinks)
  
  def newJCouplingContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.JCouplingContribution
    """
    return JCouplingContribution(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.JCouplingConstraint.contributions
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('contributions')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.JCouplingConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups
  
  contributions = property(getContributions,  None, None,
  r"""child link to class JCouplingContribution
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class JCouplingConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.JCouplingConstraint', JCouplingConstraint)

###############################################################################
class CsaConstraint(SingleConstraint):
  r"""Chemical shift anisotropy constraint (anisotropy value that must be 
reproduced by the structure).
  """
  #   from data model element ccp.nmr.NmrConstraint.CsaConstraint
  _metaclass = metaPackage.getElement('CsaConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraintGroups', 'contributions', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'resonance', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, CsaConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.CsaConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['constraintGroups'] = set()
      dataDict['contributions'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['resonance'] = None
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.CsaConstraint', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.CsaConstraint.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.CsaConstraint')
          )

      serialDict = {}
      serialDict['contributions'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.CsaConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    contributions = dataDict.get('contributions').values()
    for contribution in contributions:
      if (not (contribution in objsToBeDeleted)):
        objsToBeDeleted.add(contribution)
        objsToBeChecked.append(contribution)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.CsaConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeDeleted))):
      csaConstraints = resonance.__dict__.get('csaConstraints')
      csaConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.CsaConstraint:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeUnDeleted)):

      childrenDict = parentList.__dict__.get('constraints')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeUnDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.add(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeUnDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.add(self)

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeUnDeleted))):
      csaConstraints = resonance.__dict__.get('csaConstraints')
      csaConstraints.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('contributions').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('contributions').values()
      for value in values:
        if (not isinstance(value, CsaContribution)):
          raise ApiError("""%s.checkValid: contributions:
           value is not of class ccp.nmr.NmrConstraint.CsaContribution""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: contributions:
           non-reciprocal link contributions from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link nmrConstraintValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, CsaConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.CsaConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link peakContribs from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('resonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: resonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('csaConstraints')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: resonance:
         non-reciprocal link resonance from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    values = dataDict.get('constraintGroups')
    values = dataDict.get('contributions').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    value = dataDict.get('resonance')
    if (value is None):
      raise ApiError("""%s.checkValid: resonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (self.parentList.isotopeCode in (None, value.isotopeCode))):
      raise ApiError("""%s.checkValid: resonance:
       resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    values = dataDict.get('violations')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.CsaConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('contributions').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.CsaConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('contributions').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('contributions').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.CsaConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraint.contributions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('contributions').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraint.resonance
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newCsaContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.CsaContribution
    """
    return CsaContribution(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks
  
  def setResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CsaConstraint.resonance
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.setResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonance:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonance:
         cannot set resonance, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setResonance:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setResonance:
         Link resonance between objects from separate partitions
          - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (self.parentList.isotopeCode in (None, value.isotopeCode))):
            raise ApiError("""%s.setResonance:
             resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('csaConstraints')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonance:
         Read link 'resonance' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('csaConstraints')
      newSelves.add(self)

    dataDict['resonance'] = value

    # doNotifies

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.CsaConstraint.contributions
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('contributions')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups
  
  contributions = property(getContributions,  None, None,
  r"""child link to class CsaContribution
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks
  
  resonance = property(getResonance, setResonance, None,
  r"""FixedResonance holding Chemical shift anisotropy constraint.
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.CsaConstraint', CsaConstraint)

###############################################################################
class ChemicalShiftConstraint(SingleConstraint):
  r"""Chemical shift constraint (shift value that must be reproduced by the 
structure).
  """
  #   from data model element ccp.nmr.NmrConstraint.ChemicalShiftConstraint
  _metaclass = metaPackage.getElement('ChemicalShiftConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraintGroups', 'contributions', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'resonance', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, ChemicalShiftConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.ChemicalShiftConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['constraintGroups'] = set()
      dataDict['contributions'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['resonance'] = None
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.ChemicalShiftConstraint', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.ChemicalShiftConstraint.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ChemicalShiftConstraint')
          )

      serialDict = {}
      serialDict['contributions'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ChemicalShiftConstraint:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    contributions = dataDict.get('contributions').values()
    for contribution in contributions:
      if (not (contribution in objsToBeDeleted)):
        objsToBeDeleted.add(contribution)
        objsToBeChecked.append(contribution)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ChemicalShiftConstraint:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeDeleted))):
      chemicalShiftConstraints = resonance.__dict__.get('chemicalShiftConstraints')
      chemicalShiftConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.ChemicalShiftConstraint:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeUnDeleted)):

      childrenDict = parentList.__dict__.get('constraints')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeUnDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.add(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeUnDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.add(self)

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeUnDeleted))):
      chemicalShiftConstraints = resonance.__dict__.get('chemicalShiftConstraints')
      chemicalShiftConstraints.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('contributions').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('contributions').values()
      for value in values:
        if (not isinstance(value, ChemicalShiftContribution)):
          raise ApiError("""%s.checkValid: contributions:
           value is not of class ccp.nmr.NmrConstraint.ChemicalShiftContribution""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: contributions:
           non-reciprocal link contributions from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link nmrConstraintValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, ChemicalShiftConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.ChemicalShiftConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link peakContribs from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('resonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: resonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('chemicalShiftConstraints')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: resonance:
         non-reciprocal link resonance from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    values = dataDict.get('constraintGroups')
    values = dataDict.get('contributions').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    value = dataDict.get('resonance')
    if (value is None):
      raise ApiError("""%s.checkValid: resonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (self.parentList.isotopeCode in (None, value.isotopeCode))):
      raise ApiError("""%s.checkValid: resonance:
       resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    values = dataDict.get('violations')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ChemicalShiftConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('contributions').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.ChemicalShiftConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('contributions').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('contributions').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemicalShiftConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemicalShiftConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftConstraint.contributions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('contributions').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemicalShiftConstraint.resonance
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newChemicalShiftContribution(self, **attrlinks):
    """
    Factory function to create
    ccp.nmr.NmrConstraint.ChemicalShiftContribution
    """
    return ChemicalShiftContribution(self, **attrlinks)

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ChemicalShiftConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks
  
  def setResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ChemicalShiftConstraint.resonance
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.setResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonance:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonance:
         cannot set resonance, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setResonance:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setResonance:
         Link resonance between objects from separate partitions
          - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (self.parentList.isotopeCode in (None, value.isotopeCode))):
            raise ApiError("""%s.setResonance:
             resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('chemicalShiftConstraints')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonance:
         Read link 'resonance' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('chemicalShiftConstraints')
      newSelves.add(self)

    dataDict['resonance'] = value

    # doNotifies

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ChemicalShiftConstraint.contributions
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('contributions')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups
  
  contributions = property(getContributions,  None, None,
  r"""child link to class ChemicalShiftContribution
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks
  
  resonance = property(getResonance, setResonance, None,
  r"""FixedResonance holding Chemical shift constraint.
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.ChemicalShiftConstraint', ChemicalShiftConstraint)

###############################################################################
class RdcConstraint(SingleConstraint):
  r"""Reduced dipolar coupling constraint. Ambiguous, may contain several 
RdcConstraintItems, each with a different assignment, describing 
alternative assignment possibilities.
  """
  #   from data model element ccp.nmr.NmrConstraint.RdcConstraint
  _metaclass = metaPackage.getElement('RdcConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'vectorLength', 'weight', 'constraintGroups', 'contributions', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, RdcConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.RdcConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['vectorLength'] = None
      dataDict['weight'] = 1.0
      dataDict['constraintGroups'] = set()
      dataDict['contributions'] = {}
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.RdcConstraint', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.RdcConstraint.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.RdcConstraint')
          )

      serialDict = {}
      serialDict['contributions'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.RdcConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    contributions = dataDict.get('contributions').values()
    for contribution in contributions:
      if (not (contribution in objsToBeDeleted)):
        objsToBeDeleted.add(contribution)
        objsToBeChecked.append(contribution)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.RdcConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.RdcConstraint:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeUnDeleted)):

      childrenDict = parentList.__dict__.get('constraints')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeUnDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.add(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeUnDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.add(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeUnDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('contributions').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('vectorLength')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: vectorLength:
           memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: vectorLength:
           PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: vectorLength:
           PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link constraintGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('contributions').values()
      for value in values:
        if (not isinstance(value, RdcContribution)):
          raise ApiError("""%s.checkValid: contributions:
           value is not of class ccp.nmr.NmrConstraint.RdcContribution""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: contributions:
           non-reciprocal link contributions from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, RdcConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.RdcConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link method from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link nmrConstraintValidations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, RdcConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.RdcConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link peakContribs from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link violations from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('vectorLength')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    values = dataDict.get('constraintGroups')
    values = dataDict.get('contributions').values()
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllContributions(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.RdcConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('contributions').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'isDistanceDependent', 'lowerLimit', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.RdcConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstContribution(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.RdcConstraint.contributions
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('contributions').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('contributions').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('contributions').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'ccpnInternalData', 'combinationId', 'error', 'isDistanceDependent', 'lowerLimit', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.RdcConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.RdcConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups
  
  def getContributions(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.contributions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('contributions').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit
  
  def getVectorLength(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.vectorLength
    """
    dataDict = self.__dict__
    result = dataDict.get('vectorLength')
    return result

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newRdcConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    return RdcConstraintItem(self, **attrlinks)
  
  def newRdcContribution(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.RdcContribution
    """
    return RdcContribution(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit
  
  def setVectorLength(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcConstraint.vectorLength
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setVectorLength:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setVectorLength:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setVectorLength:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('vectorLength')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setVectorLength:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setVectorLength:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['vectorLength'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setVectorLength')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setVectorLength, self.setVectorLength,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedContributions(self):
    """
    Sorted for ccp.nmr.NmrConstraint.RdcConstraint.contributions
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('contributions')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.RdcConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit
  
  vectorLength = property(getVectorLength, setVectorLength, None,
  r"""Length of vector betwen coupled atoms - in Angstrom
  """)

  weight = AbstractConstraint.weight

  constraintGroups = AbstractConstraint.constraintGroups
  
  contributions = property(getContributions,  None, None,
  r"""child link to class RdcContribution
  """)
  
  items = property(getItems,  None, None,
  r"""child link to class RdcConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.RdcConstraint', RdcConstraint)

###############################################################################
class FourAtomContribution(GenericContribution):
  r"""Contribution to Constraint, with targe value, upper and lower limits, 
and combination logic. For four-resonance (atom) corderedonstraint 
(dihedral)
  """
  #   from data model element ccp.nmr.NmrConstraint.FourAtomContribution
  _metaclass = metaPackage.getElement('FourAtomContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'isDistanceDependent', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.FourAtomContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, GenericConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.GenericConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['isDistanceDependent'] = None
      dataDict['lowerLimit'] = None
      dataDict['scale'] = 1.0
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.FourAtomContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.FourAtomContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.FourAtomContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.FourAtomContribution:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.FourAtomContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.FourAtomContribution:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.FourAtomContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.FourAtomContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isDistanceDependent')
      if (value is not None):
        if (not (value in [True, False])):
          raise ApiError("""%s.checkValid: isDistanceDependent:
           memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('scale')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: scale:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.checkValid: scale:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: scale:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, GenericConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.GenericConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, FourAtomItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.FourAtomItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    if (not (self.getByNavigation('constraint', 'parentList', 'itemLength') == 4)):
      raise ApiError("""%s.checkValid:
       constraint FourAtomContribution_matches_itemLength_4 violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('isDistanceDependent')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('scale')
    if (value is None):
      raise ApiError("""%s.checkValid: scale:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FourAtomContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FourAtomContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = tuple(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.FourAtomContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.FourAtomContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FourAtomContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FourAtomContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          if (isinstance(obj4, FourAtomContribution)):
            result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId

  getConstraint = GenericContribution.getConstraint

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = GenericContribution.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getIsDistanceDependent = GenericContribution.getIsDistanceDependent
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FourAtomContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result

  getLocalKey = GenericContribution.getLocalKey

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = GenericContribution.getParent

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getScale = GenericContribution.getScale

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newFourAtomItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.FourAtomItem
    """
    return FourAtomItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.FourAtomContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setIsDistanceDependent = GenericContribution.setIsDistanceDependent

  setLowerLimit = ConstraintContribution.setLowerLimit

  setScale = GenericContribution.setScale

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FourAtomContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  isDistanceDependent = GenericContribution.isDistanceDependent

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  scale = GenericContribution.scale

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight

  constraint = GenericContribution.constraint
  
  items = property(getItems,  None, None,
  r"""child link to class FourAtomItem
  """)

  parent = GenericContribution.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.FourAtomContribution', FourAtomContribution)

###############################################################################
class SingleAtomContribution(GenericContribution):
  r"""Contribution to Constraint, with targe value, upper and lower limits, 
and combination logic. For single-resonance (atom) constraint
  """
  #   from data model element ccp.nmr.NmrConstraint.SingleAtomContribution
  _metaclass = metaPackage.getElement('SingleAtomContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'isDistanceDependent', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.SingleAtomContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, GenericConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.GenericConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['isDistanceDependent'] = None
      dataDict['lowerLimit'] = None
      dataDict['scale'] = 1.0
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.SingleAtomContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.SingleAtomContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.SingleAtomContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.SingleAtomContribution:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.SingleAtomContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.SingleAtomContribution:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.SingleAtomContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.SingleAtomContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isDistanceDependent')
      if (value is not None):
        if (not (value in [True, False])):
          raise ApiError("""%s.checkValid: isDistanceDependent:
           memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('scale')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: scale:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.checkValid: scale:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: scale:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, GenericConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.GenericConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, SingleAtomItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.SingleAtomItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    if (not (self.getByNavigation('constraint', 'parentList', 'itemLength') == 1)):
      raise ApiError("""%s.checkValid:
       constraint SingleatomContribution_matches_itemlength_one violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('isDistanceDependent')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('scale')
    if (value is None):
      raise ApiError("""%s.checkValid: scale:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.SingleAtomContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.SingleAtomContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonance')
      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.SingleAtomContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.SingleAtomContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.SingleAtomContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.SingleAtomContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          if (isinstance(obj4, SingleAtomContribution)):
            result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId

  getConstraint = GenericContribution.getConstraint

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = GenericContribution.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getIsDistanceDependent = GenericContribution.getIsDistanceDependent
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleAtomContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result

  getLocalKey = GenericContribution.getLocalKey

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = GenericContribution.getParent

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getScale = GenericContribution.getScale

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newSingleAtomItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.SingleAtomItem
    """
    return SingleAtomItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.SingleAtomContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setIsDistanceDependent = GenericContribution.setIsDistanceDependent

  setLowerLimit = ConstraintContribution.setLowerLimit

  setScale = GenericContribution.setScale

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.SingleAtomContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  isDistanceDependent = GenericContribution.isDistanceDependent

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  scale = GenericContribution.scale

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight

  constraint = GenericContribution.constraint
  
  items = property(getItems,  None, None,
  r"""child link to class SingleAtomItem
  """)

  parent = GenericContribution.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.SingleAtomContribution', SingleAtomContribution)

###############################################################################
class AtomPairContribution(GenericContribution):
  r"""Contribution to Constraint, with targe value, upper and lower limits, 
and combination logic. For single-resonance (atom) constraint
  """
  #   from data model element ccp.nmr.NmrConstraint.AtomPairContribution
  _metaclass = metaPackage.getElement('AtomPairContribution')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('_ID', 'additionalLowerLimit', 'additionalUpperLimit', 'applicationData', 'ccpnInternalData', 'className', 'combinationId', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'isDistanceDependent', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'scale', 'serial', 'targetValue', 'upperLimit', 'weight', 'constraint', 'items', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.AtomPairContribution
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, GenericConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.GenericConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['additionalLowerLimit'] = None
      dataDict['additionalUpperLimit'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['combinationId'] = None
      dataDict['error'] = None
      dataDict['isDistanceDependent'] = None
      dataDict['lowerLimit'] = None
      dataDict['scale'] = 1.0
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['items'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccp.nmr.NmrConstraint.AtomPairContribution', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccp.nmr.NmrConstraint.AtomPairContribution.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.AtomPairContribution')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('contributions')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.AtomPairContribution:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.AtomPairContribution:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('contributions')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccp.nmr.NmrConstraint.AtomPairContribution:
    undeletes objects
    *Implementation function* - will CORRUPT DATA if 
    called outside the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeUnDeleted)):

      childrenDict = constraint.__dict__.get('contributions')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.AtomPairContribution
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.AtomPairContribution
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('contributions')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('additionalLowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalLowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('additionalUpperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: additionalUpperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('combinationId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: combinationId:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isDistanceDependent')
      if (value is not None):
        if (not (value in [True, False])):
          raise ApiError("""%s.checkValid: isDistanceDependent:
           memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('scale')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: scale:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.checkValid: scale:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: scale:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('constraint')
      if (not isinstance(value, GenericConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.GenericConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, AtomPairItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.AtomPairItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('contribution')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link items from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    if (not (self.getByNavigation('constraint', 'parentList', 'itemLength') == 2)):
      raise ApiError("""%s.checkValid:
       constraint AtomPairContribution_matches_itemLength_2 violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    value = dataDict.get('additionalLowerLimit')
    value = dataDict.get('additionalUpperLimit')
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('combinationId')
    value = dataDict.get('error')
    value = dataDict.get('isDistanceDependent')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('scale')
    if (value is None):
      raise ApiError("""%s.checkValid: scale:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('items').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AtomPairContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AtomPairContribution.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'contribution',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findUnorderedItem = ConstraintContribution.findUnorderedItem
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.AtomPairContribution
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAdditionalLowerLimit = ConstraintContribution.getAdditionalLowerLimit

  getAdditionalUpperLimit = ConstraintContribution.getAdditionalUpperLimit

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.AtomPairContribution
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AtomPairContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AtomPairContribution'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('contributions').get(objKey)
          if (isinstance(obj4, AtomPairContribution)):
            result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCombinationId = ConstraintContribution.getCombinationId

  getConstraint = GenericContribution.getConstraint

  getError = ConstraintContribution.getError

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = GenericContribution.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getIsDistanceDependent = GenericContribution.getIsDistanceDependent
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.AtomPairContribution.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result

  getLocalKey = GenericContribution.getLocalKey

  getLowerLimit = ConstraintContribution.getLowerLimit

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = GenericContribution.getParent

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getScale = GenericContribution.getScale

  getSerial = ConstraintContribution.getSerial

  getTargetValue = ConstraintContribution.getTargetValue

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUpperLimit = ConstraintContribution.getUpperLimit

  getWeight = ConstraintContribution.getWeight

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newAtomPairItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.AtomPairItem
    """
    return AtomPairItem(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.AtomPairContribution
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAdditionalLowerLimit = ConstraintContribution.setAdditionalLowerLimit

  setAdditionalUpperLimit = ConstraintContribution.setAdditionalUpperLimit

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCombinationId = ConstraintContribution.setCombinationId

  setError = ConstraintContribution.setError

  setIsDistanceDependent = GenericContribution.setIsDistanceDependent

  setLowerLimit = ConstraintContribution.setLowerLimit

  setScale = GenericContribution.setScale

  setSerial = ConstraintContribution.setSerial

  setTargetValue = ConstraintContribution.setTargetValue

  setUpperLimit = ConstraintContribution.setUpperLimit

  setWeight = ConstraintContribution.setWeight

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AtomPairContribution.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  additionalLowerLimit = ConstraintContribution.additionalLowerLimit

  additionalUpperLimit = ConstraintContribution.additionalUpperLimit

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  combinationId = ConstraintContribution.combinationId

  error = ConstraintContribution.error

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  isDistanceDependent = GenericContribution.isDistanceDependent

  lowerLimit = ConstraintContribution.lowerLimit

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  scale = GenericContribution.scale

  serial = ConstraintContribution.serial

  targetValue = ConstraintContribution.targetValue

  upperLimit = ConstraintContribution.upperLimit

  weight = ConstraintContribution.weight

  constraint = GenericContribution.constraint
  
  items = property(getItems,  None, None,
  r"""child link to class AtomPairItem
  """)

  parent = GenericContribution.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccp.nmr.NmrConstraint.AtomPairContribution', AtomPairContribution)
