"""
#######################################################################

CCPN Data Model version 3.0.2

Autogenerated by PyFileApiGen on Sat Aug 19 14:19:26 2017
  from data model element ccpnmr.gui.Window

#######################################################################
======================COPYRIGHT/LICENSE START==========================

Window.py: python API for CCPN data model, MetaPackage ccpnmr.gui.Window

Copyright (C) 2007  (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

A copy of this license can be found in ../../../../../../..//LGPL.license

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
"""

#import sets
import traceback
import types
import operator
import functools
import collections

# special function for fast whitespace checking.
# used in DataType Word and Token handcode
import re
containsWhitespace = re.compile('\s').search
containsNonAlphanumeric = re.compile('[^a-zA-Z0-9_]').search

# Global NaN constant
NaN = float('NaN')

from ccpn.util.Undo import _deleteAllApiObjects, restoreOriginalLinks, no_op
 
from ccpnmodel.ccpncore.memops.ApiError import ApiError

# imported packages:
import ccpnmodel.ccpncore.api.ccp.nmr.Nmr
import ccpnmodel.ccpncore.api.memops.Implementation

metaPackage = ccpnmodel.ccpncore.api.memops.Implementation.topPackage.metaObjFromQualName('ccpnmr.gui.Window')

###############################################################################
class Window(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Window, corresponding to operating system window
  """
  #   from data model element ccpnmr.gui.Window.Window
  _metaclass = metaPackage.getElement('Window')
  _packageName = 'ccpnmr.gui.Window'
  _packageShortName = 'GUIW'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'position', 'qualifiedName', 'serial', 'size', 'title', 'guiTask', 'modules', 'parent', 'root', 'topObject', 'windowStore',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Window.Window
    """
    dataDict = self.__dict__
    dataDict['windowStore'] = parent
    if (not isinstance(parent, WindowStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Window.WindowStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['position'] = [0, 0]
      dataDict['serial'] = None
      dataDict['size'] = [400, 400]
      dataDict['title'] = None
      dataDict['guiTask'] = None
      dataDict['modules'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Window.Window', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Window.Window.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccpnmr.gui.Window.Window')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('windows')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Window.Window:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    if any(x for x in self.modules if x not in objsToBeDeleted and x.guiTask not in objsToBeDeleted):
      raise ApiError("Window %s is not empty - first delete or disconnect modules %s." % (self, self.modules))
    
    # The following code interacts directly with the deletion implementation (use of 'objsToBeDeleted'). 
    # This is bad, but the only way to accomplish the desired result.
    if self is self.windowStore.mainWindow and self.windowStore not in objsToBeDeleted and not self.root.override:
      raise ApiError("Window %s: Main Window can only be deleted when the GuiStore is deleted." % self)
    if (dataDict.get('guiTask') is None):
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    guiTask = dataDict.get('guiTask')
    if (guiTask is not None):
      topObject = guiTask.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('ccpnmr.gui.Task')
    tobjList = root.__dict__.get('guiTasks').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    modules = dataDict.get('modules')
    pass
    for module in modules:
      topObject = module.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Window.Window:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    guiTask = dataDict.get('guiTask')
    if ((guiTask is not None and not (guiTask in objsToBeDeleted))):
      windows = guiTask.__dict__.get('windows')
      windows.remove(self)

    for module in dataDict.get('modules'):
      if (not (module in objsToBeDeleted)):
        module.__dict__['window'] = None

    windowStore = dataDict.get('windowStore')
    if (not (windowStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = windowStore.__dict__.get('windows')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Window.Window:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    windowStore = dataDict.get('windowStore')

    childrenDict = windowStore.__dict__.get('windows')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    guiTask = dataDict.get('guiTask')
    if ((guiTask is not None and not (guiTask in objsToBeUnDeleted))):
      windows = guiTask.__dict__.get('windows')
      windows.add(self)

    for module in dataDict.get('modules'):
      if (not (module in objsToBeUnDeleted)):
        if (module.__dict__.get('window') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of Window object modules link - backLink Module.window is not None""" % self.qualifiedName
          )

        module.__dict__['window'] = self

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addModule(self, value):
    """
    Add for ccpnmr.gui.Window.Window.modules
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccpnmr.gui.Task import Module as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addModule:
       value is not of class ccpnmr.gui.Task.Module""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('ccpnmr.gui.Task')
    tobjList = root.__dict__.get('guiTasks').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    currentValues = dataDict.get('modules')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.window}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      oldSelf = value.__dict__.get('window')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addModule:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addModule:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addModule:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addModule:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addModule:
           Link modules between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          (self, value) = (value, self)
          if (not (value.guiTask is self.guiTask)):
            raise ApiError("""%s.addModule:
             window constraint all_window_modules_must_belong_to_window_task violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

          (value, self) = (self, value)

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('window')
    if (oldSelf is not None):
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      siblingValues = oldSelf.__dict__.get('modules')
      siblingValues.remove(value)

    value.__dict__['window'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addModule')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addModule, undoArgs=(undoValueDict, 'window'),  redoArgs=(value,))

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Window.Window
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Window.Window
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('windowStore')
        dd = value.__dict__.get('windows')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'windowStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('position')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: position:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('size')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: size:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('title')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: title:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: title:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: title:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: title:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (dataDict.get('guiTask') is None):
        root = dataDict.get('topObject').__dict__.get('memopsRoot')
        root.refreshTopObjects('ccpnmr.gui.Task')
        tobjList = root.__dict__.get('guiTasks').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      value = dataDict.get('guiTask')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccpnmr.gui.Task import GuiTask as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: guiTask:
           value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('windows')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: guiTask:
           non-reciprocal link guiTask from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('modules')
      for value in values:
        from ccpnmodel.ccpncore.api.ccpnmr.gui.Task import Module as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: modules:
           value is not of class ccpnmr.gui.Task.Module""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('window')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: modules:
           non-reciprocal link modules from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: modules:
           Link modules between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('windowStore')
      if (not isinstance(value, WindowStore)):
        raise ApiError("""%s.checkValid: windowStore:
         value is not of class ccpnmr.gui.Window.WindowStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('position')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: position:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('size')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: size:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('title')
    if (value is None):
      raise ApiError("""%s.checkValid: title:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('guiTask')
    values = dataDict.get('modules')
    for value in values:
      (self, value) = (value, self)
      if (not (value.guiTask is self.guiTask)):
        raise ApiError("""%s.checkValid: modules:
         window constraint all_window_modules_must_belong_to_window_task violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      (value, self) = (self, value)

    value = dataDict.get('windowStore')
    if (value is None):
      raise ApiError("""%s.checkValid: windowStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllModules(self, **conditions):
    """
    FindAll for ccpnmr.gui.Window.Window.modules
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('modules')
      result = set(currentValues)

    else:
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('modules')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'windowId', 'guiTask', 'window',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstModule(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Window.Window.modules
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('modules')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('modules')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'windowId', 'guiTask', 'window',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Window.Window
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Window.Window
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Window.Window'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('windowStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Window')
        obj1 = obj0.__dict__.get('windowStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Window.Window'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('windows').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Window.Window
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('windowStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nmrProject'))

    result.append(dataDict.get('serial'))

    return result
  
  def getGuiTask(self):
    """
    Get for ccpnmr.gui.Window.Window.guiTask
    """
    dataDict = self.__dict__
    if (dataDict.get('guiTask') is None):
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    result = dataDict.get('guiTask')
    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Window.Window
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getModules(self):
    """
    Get for ccpnmr.gui.Window.Window.modules
    """
    dataDict = self.__dict__
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('ccpnmr.gui.Task')
    tobjList = root.__dict__.get('guiTasks').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    tempVar = dataDict.get('modules')
    result = frozenset(tempVar)
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Window.Window.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('windowStore')
    return result
  
  def getPosition(self):
    """
    Get for ccpnmr.gui.Window.Window.position
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('position')
    result = tuple(tempVar)
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccpnmr.gui.Window.Window.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getSize(self):
    """
    Get for ccpnmr.gui.Window.Window.size
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('size')
    result = tuple(tempVar)
    return result
  
  def getTitle(self):
    """
    Get for ccpnmr.gui.Window.Window.title
    """
    dataDict = self.__dict__
    result = dataDict.get('title')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getWindowStore(self):
    """
    Get for ccpnmr.gui.Window.Window.windowStore
    """
    dataDict = self.__dict__
    result = dataDict.get('windowStore')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeModule(self, value):
    """
    Remove for ccpnmr.gui.Window.Window.modules
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccpnmr.gui.Task import Module as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeModule:
       value is not of class ccpnmr.gui.Task.Module""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('ccpnmr.gui.Task')
    tobjList = root.__dict__.get('guiTasks').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    currentValues = dataDict.get('modules')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeModule:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeModule:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeModule:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeModule:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['window'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeModule')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setModules, self.removeModule,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Window.Window
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setGuiTask(self, value):
    """
    Set for ccpnmr.gui.Window.Window.guiTask
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccpnmr.gui.Task import GuiTask as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setGuiTask:
         value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (dataDict.get('guiTask') is None):
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = root.__dict__.get('guiTasks').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    currentValue = dataDict.get('guiTask')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      if (value is not None):
        topObject = value.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      if (currentValue is not None):
        topObject = currentValue.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setGuiTask:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setGuiTask:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setGuiTask:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setGuiTask:
           Link guiTask between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('windows')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setGuiTask:
         Read link 'guiTask' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('windows')
      newSelves.add(self)

    dataDict['guiTask'] = value
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setGuiTask')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setGuiTask, self.setGuiTask,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setModules(self, values):
    """
    Set for ccpnmr.gui.Window.Window.modules
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setModules:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccpnmr.gui.Task import Module as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setModules:
         value is not of class ccpnmr.gui.Task.Module""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('ccpnmr.gui.Task')
    tobjList = root.__dict__.get('guiTasks').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    currentValues = dataDict.get('modules')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.window) for y in (currentValues, values) for x in y)

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('window')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setModules:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setModules:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setModules:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setModules:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setModules:
           Link modules between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          (self, value) = (value, self)
          if (not (value.guiTask is self.guiTask)):
            raise ApiError("""%s.setModules:
             window constraint all_window_modules_must_belong_to_window_task violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

          (value, self) = (self, value)

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['window'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('window')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('modules')
          vv.remove(cv)

      cv.__dict__['window'] = self

    dataDict['modules'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setModules')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setModules, undoArgs=(undoValueDict, 'window'),  redoArgs=(values,))

  def setPosition(self, values):
    """
    Set for ccpnmr.gui.Window.Window.position
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setPosition:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('position')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPosition:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPosition:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (not (len(values) == 2)):
        raise ApiError("""%s.setPosition:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['position'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPosition')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPosition, self.setPosition,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setSerial(self, value):
    """
    Set for ccpnmr.gui.Window.Window.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('windowStore')
    oldSerial = parent.__dict__.get('_serialDict').get('windows')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['windows'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['windows'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setSize(self, values):
    """
    Set for ccpnmr.gui.Window.Window.size
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setSize:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('size')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSize:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSize:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (not (len(values) == 2)):
        raise ApiError("""%s.setSize:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['size'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSize')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSize, self.setSize,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setTitle(self, value):
    """
    Set for ccpnmr.gui.Window.Window.title
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setTitle:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setTitle:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setTitle:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setTitle:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('title')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTitle:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setTitle:
         cannot set title, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setTitle:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['title'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedModules(self):
    """
    Sorted for ccpnmr.gui.Window.Window.modules
    """
    dataDict = self.__dict__
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('ccpnmr.gui.Task')
    tobjList = root.__dict__.get('guiTasks').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    ll = dataDict.get('modules')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  position = property(getPosition, setPosition, None,
  r"""Windox x,y position in pixels. NBNB TBD decide whether pixels are the 
  correct unit, and which conventions and defaults are required.
  NBNB The 
  main window is created automatically whe the GuiStore is created - it 
  will have serial==1.and cannot be deleted except when the GuiStore is 
  deleted.  At creation time the label is 'Main' (but it can be 
  changed).If necessary we can make this a special subclass. 
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  size = property(getSize, setSize, None,
  r"""Window x,y size in pixels.
  """)
  
  title = property(getTitle, setTitle, None,
  r"""Window label. Recommended to be 'Main' for serial == 1 and 'W%s' % 
  serial for other windows.
  """)
  
  guiTask = property(getGuiTask, setGuiTask, None,
  r"""GuiTask diaplayed in a window 
  """)
  
  modules = property(getModules, setModules, None,
  r"""Module displayed in window
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for windowStore
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject
  
  windowStore = property(getWindowStore,  None, None,
  r"""parent link
  """)

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Window.Window', Window)

###############################################################################
class WindowStore(ccpnmodel.ccpncore.api.memops.Implementation.TopObject):
  r"""TopObject to group Gui windows for each NmrProject
  """
  #   from data model element ccpnmr.gui.Window.WindowStore
  _metaclass = metaPackage.getElement('WindowStore')
  _packageName = 'ccpnmr.gui.Window'
  _packageShortName = 'GUIW'
  _fieldNames = ('_ID', '_lastId', 'applicationData', 'ccpnInternalData', 'className', 'createdBy', 'fieldNames', 'guid', 'inConstructor', 'isDeleted', 'isLoaded', 'isModifiable', 'isModified', 'isReading', 'lastUnlockedBy', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'activeRepositories', 'mainWindow', 'memopsRoot', 'nmrProject', 'packageLocator', 'parent', 'root', 'topObject', 'windows',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Window.WindowStore
    """
    dataDict = self.__dict__
    dataDict['memopsRoot'] = parent
    from ccpnmodel.ccpncore.api.memops.Implementation import MemopsRoot as importedType
    if (not isinstance(parent, importedType)):
      raise ApiError("""%s.__init__:
       value is not of class memops.Implementation.MemopsRoot""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = self
    dataDict['topObject'] = topObject
    if (attrlinks.get('isReading', False)):
      del attrlinks['isReading']
      dataDict['isLoaded'] = False
      dataDict['isModified'] = False
      dataDict['isReading'] = True
    elif (parent.__dict__.get('isReading')):
      dataDict['isLoaded'] = False
      dataDict['isModified'] = False
      dataDict['isReading'] = True
    else:
      dataDict['isLoaded'] = True
      dataDict['isModified'] = True
      dataDict['isReading'] = False

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    try:
      if (not (dataDict.get('isReading'))):
        parent.refreshTopObjects('ccpnmr.gui.Window')

      dataDict['_ID'] = None
      dataDict['_lastId'] = 0
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['createdBy'] = None
      dataDict['guid'] = None
      dataDict['isModifiable'] = True
      dataDict['lastUnlockedBy'] = None
      dataDict['mainWindow'] = None
      dataDict['nmrProject'] = None
      dataDict['windows'] = {}
      dataDict['activeRepositories'] = list()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Window.WindowStore', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Window.WindowStore.__init__")
        del dataDict['inConstructor']
        raise

      serialDict = {}
      serialDict['windows'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('windowStores')
        objKey = dataDict.get('nmrProject')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['nmrProject'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        guid = dataDict.get('guid')
        if (guid is None):
          guid = root.newGuid()
          dataDict['guid'] = guid

        dd = root.__dict__.get('topObjects')
        if (dd.get(guid) is None):
          dd[guid] = self
        else:
          raise ApiError("""%s.__init__:
           Creating TopObject with preexisting guid""" % self.qualifiedName
           + ": %s" % (self,)
          )

        dataDict['createdBy'] = root.__dict__.get('currentUserId')
        
        
        dataDict['mainWindow'] = newWindow = self.newWindow(title='Main')
        objectsCreated.add(newWindow)

      if (notOverride):
        self.checkValid()

      if ((notIsReading or root.__dict__.get('currentWindowStore') is None)):
        root.__dict__['currentWindowStore'] = self

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Window.WindowStore:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    objsToBeDeleted.add(self)
    memopsRoot = dataDict.get('memopsRoot')
    if (memopsRoot is not None):
      topObject = memopsRoot.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrProject = dataDict.get('nmrProject')
    if (nmrProject is not None):
      topObject = nmrProject.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    windows = dataDict.get('windows').values()
    for window in windows:
      if (not (window in objsToBeDeleted)):
        objsToBeDeleted.add(window)
        objsToBeChecked.append(window)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Window.WindowStore:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    memopsRoot = dataDict.get('memopsRoot')
    if (self is memopsRoot.__dict__.get('currentWindowStore')):
      memopsRoot.__dict__['currentWindowStore'] = None

    nmrProject = dataDict.get('nmrProject')
    if ((nmrProject is not None and not (nmrProject in objsToBeDeleted))):
      nmrProject.__dict__['windowStore'] = None

    memopsRoot = dataDict.get('memopsRoot')
    if (not (memopsRoot in objsToBeDeleted)):
      objKey = dataDict.get('nmrProject')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = memopsRoot.__dict__.get('windowStores')
        if (self is dd.get(objKey)):
          del dd[objKey]

    dataDict['windows'] = {}
  
  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Window.WindowStore:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    memopsRoot = dataDict.get('memopsRoot')

    childrenDict = memopsRoot.__dict__.get('windowStores')
    objKey = dataDict.get('nmrProject')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['nmrProject'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    nmrProject = dataDict.get('nmrProject')
    if ((nmrProject is not None and not (nmrProject in objsToBeUnDeleted))):
      if (nmrProject.__dict__.get('windowStore') is not None):
        raise ApiError("""%s._singleUnDelete:
         Error undoing delete of WindowStore object nmrProject link - backLink NmrProject.windowStore is not None""" % self.qualifiedName
        )

      nmrProject.__dict__['windowStore'] = self

    memopsRoot.__dict__['topObjects'][self.guid] = self

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  backup = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.backup
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Window.WindowStore
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    self.checkValid(complete)
    values = dataDict.get('windows').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Window.WindowStore
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('nmrProject')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('memopsRoot')
        dd = value.__dict__.get('windowStores')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'memopsRoot' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('_lastId')
      if (value is None):
        raise ApiError("""%s.checkValid: _lastId:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _lastId:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('createdBy')
      if (value is None):
        raise ApiError("""%s.checkValid: createdBy:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: createdBy:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('guid')
      if (value is None):
        raise ApiError("""%s.checkValid: guid:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: guid:
         GuidString constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      isValid = frozenset('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789-').issuperset(value)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: guid:
         GuidString constraint value_is_url_safe violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('isModifiable')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: isModifiable:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('lastUnlockedBy')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('mainWindow')
      if (value is None):
        raise ApiError("""%s.checkValid: mainWindow:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not isinstance(value, Window)):
        raise ApiError("""%s.checkValid: mainWindow:
         value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
         + ": %s" % (value,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.checkValid: mainWindow:
         Link mainWindow between objects from separate partitions
          - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      value = dataDict.get('memopsRoot')
      from ccpnmodel.ccpncore.api.memops.Implementation import MemopsRoot as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: memopsRoot:
         value is not of class memops.Implementation.MemopsRoot""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('nmrProject')
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrProject as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: nmrProject:
         value is not of class ccp.nmr.Nmr.NmrProject""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelf = value.__dict__.get('windowStore')
      if (not (oldSelf is self)):
        raise ApiError("""%s.checkValid: nmrProject:
         non-reciprocal link nmrProject from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.checkValid: nmrProject:
         Link nmrProject between objects from separate partitions
          - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      value = self.getPackageLocator()
      if (value is None):
        raise ApiError("""%s.checkValid: packageLocator:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      from ccpnmodel.ccpncore.api.memops.Implementation import PackageLocator as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: packageLocator:
         value is not of class memops.Implementation.PackageLocator""" % self.qualifiedName
         + ": %s" % (value,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.checkValid: packageLocator:
         Link packageLocator between objects from separate partitions
          - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      values = dataDict.get('windows').values()
      for value in values:
        if (not isinstance(value, Window)):
          raise ApiError("""%s.checkValid: windows:
           value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('windowStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: windows:
           non-reciprocal link windows from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    if (dataDict.get('isLoaded')):
      # check explicit class constraints
      # check attributes
      values = dataDict.get('applicationData')
      for value in values:
        value.checkAllValid(complete)

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (not (value is None or isinstance(value, dict))):
          raise ApiError("""%s.checkValid: ccpnInternalData:
           ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isModifiable')
      if (value is None):
        raise ApiError("""%s.checkValid: isModifiable:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      # check roles
      value = dataDict.get('memopsRoot')
      if (value is None):
        raise ApiError("""%s.checkValid: memopsRoot:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('nmrProject')
      if (value is None):
        raise ApiError("""%s.checkValid: nmrProject:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('windows').values()
    else:
      # check unloaded TopObject
      value = dataDict.get('guid')
      if (value is None):
        raise ApiError("""%s.checkValid: guid:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('nmrProject')
      if (value is None):
        raise ApiError("""%s.checkValid: nmrProject:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllActiveRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.findAllActiveRepositories

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllWindows(self, **conditions):
    """
    FindAll for ccpnmr.gui.Window.WindowStore.windows
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('windows').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('windows').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'title', 'guiTask', 'windowStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstActiveRepository = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.findFirstActiveRepository

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstWindow(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Window.WindowStore.windows
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('windows').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('windows').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('windows').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'title', 'guiTask', 'windowStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Window.WindowStore
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getActiveRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getActiveRepositories

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Window.WindowStore
    """

    result = None
    if (1 != len(fullKey)):
      raise ApiError("""'ccpnmr.gui.Window.WindowStore'.getByKey:
       getByKey called with fullKey of wrong length. Parameters:"""
       + ": %s:%s" % (startObj, fullKey)
      )

    objKey = fullKey[0]
    obj1 = startObj.__dict__.get('windowStores').get(objKey)
    if (obj1 is None):
      startObj.refreshTopObjects('ccpnmr.gui.Window')
      obj1 = startObj.__dict__.get('windowStores').get(objKey)

    result = obj1
    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCreatedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getCreatedBy

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Window.WindowStore
    """
    dataDict = self.__dict__
    result = list()

    if (useGuid):
      result.append(dataDict.get('guid'))
    else:
      result.append(dataDict.get('nmrProject'))

    return result

  getGuid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getGuid

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getIsLoaded = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsLoaded

  getIsModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsModifiable

  getIsModified = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsModified

  getIsReading = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsReading

  getLastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getLastUnlockedBy
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Window.WindowStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrProject')
    return result
  
  def getMainWindow(self):
    """
    Get for ccpnmr.gui.Window.WindowStore.mainWindow
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    result = dataDict.get('mainWindow')
    return result
  
  def getMemopsRoot(self):
    """
    Get for ccpnmr.gui.Window.WindowStore.memopsRoot
    """
    dataDict = self.__dict__
    result = dataDict.get('memopsRoot')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getNmrProject(self):
    """
    Get for ccpnmr.gui.Window.WindowStore.nmrProject
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrProject')
    return result

  getPackageLocator = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getPackageLocator

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Window.WindowStore.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('memopsRoot')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getWindows(self):
    """
    Get for ccpnmr.gui.Window.WindowStore.windows
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('windows').values()
    result = frozenset(tempVar)
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  get_lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.get_lastId

  load = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.load

  loadFrom = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.loadFrom
  
  def newWindow(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Window.Window
    """
    return Window(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeFrom = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.removeFrom

  restore = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.restore

  save = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.save

  saveTo = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.saveTo
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Window.WindowStore
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCreatedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setCreatedBy

  setGuid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setGuid

  setIsModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setIsModifiable

  setLastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setLastUnlockedBy
  
  def setMainWindow(self, value):
    """
    Set for ccpnmr.gui.Window.WindowStore.mainWindow
    """
    dataDict = self.__dict__
    if (not isinstance(value, Window)):
      raise ApiError("""%s.setMainWindow:
       value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('mainWindow')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMainWindow:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMainWindow:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setMainWindow:
         cannot set mainWindow, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setMainWindow:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setMainWindow:
         Link mainWindow between objects from separate partitions
          - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    dataDict['mainWindow'] = value

    # doNotifies
  
  def setNmrProject(self, value):
    """
    Set for ccpnmr.gui.Window.WindowStore.nmrProject
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrProject as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.setNmrProject:
       value is not of class ccp.nmr.Nmr.NmrProject""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('nmrProject')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Window')
      tobjList = set(root.__dict__.get('windowStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrProject:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrProject:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setNmrProject:
         cannot set nmrProject, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setNmrProject:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value.__dict__.get('windowStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccpnmr.gui.Window')

      oldSelf = value.__dict__.get('windowStore')
      if (oldSelf is not None):
        raise ApiError("""%s.setNmrProject:
         oldSelf must be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setNmrProject:
         Link nmrProject between objects from separate partitions
          - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      currentValue.__dict__['windowStore'] = None

    if (value is not None):
      oldSelf = value.__dict__.get('windowStore')
      if (oldSelf is not None):
        oldSelf.__dict__['nmrProject'] = None

      value.__dict__['windowStore'] = self

    dataDict['nmrProject'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  set_lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.set_lastId
  
  def sortedWindows(self):
    """
    Sorted for ccpnmr.gui.Window.WindowStore.windows
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('windows')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  touch = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.touch

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  _lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject._lastId

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  createdBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.createdBy

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  guid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.guid

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  isLoaded = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isLoaded

  isModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isModifiable

  isModified = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isModified

  isReading = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isReading

  lastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.lastUnlockedBy

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  activeRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.activeRepositories
  
  mainWindow = property(getMainWindow, setMainWindow, None,
  r"""Main display window
  """)
  
  memopsRoot = property(getMemopsRoot,  None, None,
  r"""parent link
  """)
  
  nmrProject = property(getNmrProject, setNmrProject, None,
  r"""NmrProject that GuiStore belongs to
  """)

  packageLocator = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.packageLocator
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for memopsRoot
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject
  
  windows = property(getWindows,  None, None,
  r"""child link to class Window
  """)

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Window.WindowStore', WindowStore)
