"""
#######################################################################

CCPN Data Model version 3.0.2

Autogenerated by PyFileApiGen on Thu Apr 19 18:03:59 2018
  from data model element ccpnmr.gui.Task

#######################################################################
======================COPYRIGHT/LICENSE START==========================

Task.py: python API for CCPN data model, MetaPackage ccpnmr.gui.Task

Copyright (C) 2007  (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

A copy of this license can be found in ../../../../../../..//LGPL.license

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
"""

#import sets
import traceback
import types
import operator
import functools
import collections

# special function for fast whitespace checking.
# used in DataType Word and Token handcode
import re
containsWhitespace = re.compile('\s').search
containsNonAlphanumeric = re.compile('[^a-zA-Z0-9_]').search

# Global NaN constant
NaN = float('NaN')

from ccpn.util.Undo import _deleteAllApiObjects, restoreOriginalLinks, no_op
 
from ccpnmodel.ccpncore.memops.ApiError import ApiError

# imported packages:
import ccpnmodel.ccpncore.api.ccp.nmr.Nmr
import ccpnmodel.ccpncore.api.ccpnmr.gui.Window
import ccpnmodel.ccpncore.api.memops.Implementation

metaPackage = ccpnmodel.ccpncore.api.memops.Implementation.topPackage.metaObjFromQualName('ccpnmr.gui.Task')

###############################################################################
class Axis(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Axis. Key is axisCode and (optional) stripSerial. stripSerial==0 means 
'for all strips'.
NB The four axis types (frequency, value (e.g. FID), 
intensity and sampled use the same position and width fields. For 
sampled axes these are float represntations of Int values.
  """
  #   from data model element ccpnmr.gui.Task.Axis
  _metaclass = metaPackage.getElement('Axis')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'code', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'position', 'qualifiedName', 'regions', 'resonanceSerials', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'parent', 'resonances', 'root', 'spectrumDisplay', 'stripAxes', 'strips', 'topObject',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addRegion(self, value):
    """
    Add for ccpnmr.gui.Task.Axis.regions
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.addRegion:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.addRegion:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('regions')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addRegion:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addRegion:
       called on deleted object""" % self.qualifiedName
      )

    if (notOverride):
      pass

    undoValues = list(currentValues)
    currentValues.append(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addRegion')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setRegions, self.addRegion,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addResonance(self, value):
    """
    Add for ccpnmr.gui.Task.Axis.resonances
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Resonance as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addResonance:
       value is not of class ccp.nmr.Nmr.Resonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addResonance:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.addResonance:
           Link resonances between objects from separate partitions
           - ccpnmr.gui.Task.GuiTask.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('displayAxes')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonances, self.addResonance,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addResonanceSerial(self, value):
    """
    Add for ccpnmr.gui.Task.Axis.resonanceSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.addResonanceSerial:
       memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value > 0)):
      raise ApiError("""%s.addResonanceSerial:
       PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addResonanceSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addResonanceSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (notOverride):
      pass

    undoValues = list(currentValues)
    currentValues.append(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addResonanceSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceSerials, self.addResonanceSerial,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid
  
  def connectPositionTo(self, value):
    """
    Set axis to share position with target
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.connectPositionTo:
       called on deleted object""" % self.qualifiedName
      )

    if value is None:
      self.axisPositionGroup = None
    else:
      self.position = value.position
      group = value.axisPositionGroup
      if group:
        group.addAxis(self)
      else:
        self.topObject.newAxisPositionGroup(axes=(self, value))
  
  def connectTo(self, value):
    """
    Set axis to share position and width with target
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.connectTo:
       called on deleted object""" % self.qualifiedName
      )

    self.connectPositionTo(value)
    self.connectWidthTo(value)
  
  def connectWidthTo(self, value):
    """
    Set axis to share position with target
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.connectWidthTo:
       called on deleted object""" % self.qualifiedName
      )

    if value is None:
      self.axisWidthGroup = None
    else:
      self.width = value.width
      group = value.axisWidthGroup
      if group:
        group.addAxis(self)
      else:
        self.topObject.newAxisWidthGroup(axes=(self, value))

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete
  
  def disconnect(self):
    """
    Disconnect axis from all grouped axes.
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.disconnect:
       called on deleted object""" % self.qualifiedName
      )

    self.axisPositionGroup = None
    self.axisWidthGroup = None

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Axis.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'implName', 'isotopeCode', 'serial', 'nmrProject', 'resonanceGroup', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStripAxes(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Axis.stripAxes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripAxes')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('stripAxes')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'axis', 'strip',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStrips(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Axis.strips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getStrips()
      result = list(currentValues)

    else:
      currentValues = self.getStrips()
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Axis.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'implName', 'isotopeCode', 'serial', 'nmrProject', 'resonanceGroup', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStrip(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Axis.strips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getStrips()
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = self.getStrips()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStripAxis(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Axis.stripAxes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripAxes')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('stripAxes')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'axis', 'strip',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxisPositionGroup(self):
    """
    Get for ccpnmr.gui.Task.Axis.axisPositionGroup
    """
    dataDict = self.__dict__
    result = dataDict.get('axisPositionGroup')
    return result
  
  def getAxisWidthGroup(self):
    """
    Get for ccpnmr.gui.Task.Axis.axisWidthGroup
    """
    dataDict = self.__dict__
    result = dataDict.get('axisWidthGroup')
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.Axis
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Axis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Axis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        ll = list()
        objKey = fullKey[-2]
        ll.append(objKey)
        if (objKey is not None):
          objKey = fullKey[-1]
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        obj3 = obj2.__dict__.get('axes').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getCode(self):
    """
    Get for ccpnmr.gui.Task.Axis.code
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getCode:
     getCode should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.Axis
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(dataDict.get('code'))
    result.append(dataDict.get('stripSerial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.Axis
    """
    dataDict = self.__dict__
    ll = list()
    result = dataDict.get('code')
    ll.append(result)
    if (result is not None):
      result = dataDict.get('stripSerial')
      ll.append(result)
      if (result is not None):
        result = tuple(ll)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.Axis.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumDisplay')
    return result
  
  def getPosition(self):
    """
    Get for ccpnmr.gui.Task.Axis.position
    """
    dataDict = self.__dict__
    result = dataDict.get('position')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getRegions(self):
    """
    Get for ccpnmr.gui.Task.Axis.regions
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('regions')
    result = tuple(tempVar)
    return result
  
  def getResonanceSerials(self):
    """
    Get for ccpnmr.gui.Task.Axis.resonanceSerials
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonanceSerials')
    result = tuple(tempVar)
    return result
  
  def getResonances(self):
    """
    Get for ccpnmr.gui.Task.Axis.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSpectrumDisplay(self):
    """
    Get for ccpnmr.gui.Task.Axis.spectrumDisplay
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumDisplay')
    return result
  
  def getStripAxes(self):
    """
    Get for ccpnmr.gui.Task.Axis.stripAxes
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('stripAxes')
    result = frozenset(tempVar)
    return result
  
  def getStripSerial(self):
    """
    Get for ccpnmr.gui.Task.Axis.stripSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('stripSerial')
    return result
  
  def getStrips(self):
    """
    gtter for derived link strips
    """
    dataDict = self.__dict__
    serial = self.stripSerial
    if serial:
      result = (self.spectrumDisplay.findFirstStrip(serial=self.stripSerial),)
    else:
      result = self.spectrumDisplay.orderedStrips
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnit(self):
    """
    Get for ccpnmr.gui.Task.Axis.unit
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getUnit:
     getUnit should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getWidth(self):
    """
    Get for ccpnmr.gui.Task.Axis.width
    """
    dataDict = self.__dict__
    result = dataDict.get('width')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeRegion(self, value):
    """
    Remove for ccpnmr.gui.Task.Axis.regions
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.removeRegion:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.removeRegion:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('regions')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeRegion:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeRegion:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeRegion:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = list(currentValues)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeRegion')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setRegions, self.removeRegion,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeResonance(self, value):
    """
    Remove for ccpnmr.gui.Task.Axis.resonances
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Resonance as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeResonance:
       value is not of class ccp.nmr.Nmr.Resonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeResonance:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    oldSelves = value.__dict__.get('displayAxes')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonances, self.removeResonance,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeResonanceSerial(self, value):
    """
    Remove for ccpnmr.gui.Task.Axis.resonanceSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeResonanceSerial:
       memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value > 0)):
      raise ApiError("""%s.removeResonanceSerial:
       PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeResonanceSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeResonanceSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeResonanceSerial:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = list(currentValues)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeResonanceSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceSerials, self.removeResonanceSerial,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxisPositionGroup(self, value):
    """
    Set for ccpnmr.gui.Task.Axis.axisPositionGroup
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, AxisPositionGroup)):
        raise ApiError("""%s.setAxisPositionGroup:
         value is not of class ccpnmr.gui.Task.AxisPositionGroup""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('axisPositionGroup')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAxisPositionGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisPositionGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAxisPositionGroup:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (currentValue is not None):
        oldSelves = currentValue.__dict__.get('axes')
        if (len(oldSelves) < (2 + 1)):
          raise ApiError("""%s.setAxisPositionGroup:
           locard: oldSelves: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAxisPositionGroup:
           Link axisPositionGroup between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('axes')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setAxisPositionGroup:
         Read link 'axisPositionGroup' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('axes')
      newSelves.add(self)

    dataDict['axisPositionGroup'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAxisPositionGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisPositionGroup, self.setAxisPositionGroup,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setAxisWidthGroup(self, value):
    """
    Set for ccpnmr.gui.Task.Axis.axisWidthGroup
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, AxisWidthGroup)):
        raise ApiError("""%s.setAxisWidthGroup:
         value is not of class ccpnmr.gui.Task.AxisWidthGroup""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('axisWidthGroup')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAxisWidthGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisWidthGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAxisWidthGroup:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (currentValue is not None):
        oldSelves = currentValue.__dict__.get('axes')
        if (len(oldSelves) < (2 + 1)):
          raise ApiError("""%s.setAxisWidthGroup:
           locard: oldSelves: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAxisWidthGroup:
           Link axisWidthGroup between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('axes')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setAxisWidthGroup:
         Read link 'axisWidthGroup' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('axes')
      newSelves.add(self)

    dataDict['axisWidthGroup'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAxisWidthGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisWidthGroup, self.setAxisWidthGroup,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setCode(self, value):
    """
    Set for ccpnmr.gui.Task.Axis.code
    """
    dataDict = self.__dict__
    raise ApiError("""%s.setCode:
     setCode should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def setPosition(self, value):
    """
    setter for derived attribute position
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setPosition:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setPosition:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('position')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPosition:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPosition:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setPosition:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      group = self.axisPositionGroup
      if group is None:
        self.__dict__['position'] = value
      else:
        for axis in group.axes:
          axis.__dict__['position'] = value
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPosition')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPosition, self.setPosition,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setRegions(self, values):
    """
    Set for ccpnmr.gui.Task.Axis.regions
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        replaceIndex = values.index(value)
        values[replaceIndex] = castValue
        value = castValue
      else:
        raise ApiError("""%s.setRegions:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setRegions:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('regions')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setRegions:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setRegions:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['regions'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setRegions')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setRegions, self.setRegions,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setResonanceSerials(self, values):
    """
    Set for ccpnmr.gui.Task.Axis.resonanceSerials
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setResonanceSerials:
         memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setResonanceSerials:
         PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceSerials:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceSerials:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['resonanceSerials'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceSerials')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceSerials, self.setResonanceSerials,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setResonances(self, values):
    """
    Set for ccpnmr.gui.Task.Axis.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Resonance as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.Nmr.Resonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonances:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject')
      xx2 = xx1.__dict__.get('nmrProject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
           - ccpnmr.gui.Task.GuiTask.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('displayAxes')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('displayAxes')
        oldSelves.add(self)

    dataDict['resonances'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonances')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonances, self.setResonances,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setStripAxes(self, values):
    """
    Set for ccpnmr.gui.Task.Axis.stripAxes
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setStripAxes:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, StripAxis)):
        raise ApiError("""%s.setStripAxes:
         value is not of class ccpnmr.gui.Task.StripAxis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('stripAxes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStripAxes:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStripAxes:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setStripAxes:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setStripAxes:
           locard axis: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setStripAxes:
           Link stripAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['axis'] = self

    dataDict['stripAxes'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStripAxes')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setStripAxes, self.setStripAxes,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setStripSerial(self, value):
    """
    Set for ccpnmr.gui.Task.Axis.stripSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setStripSerial:
       memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value >= 0)):
      raise ApiError("""%s.setStripSerial:
       NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('stripSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStripSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setStripSerial:
         cannot set stripSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setStripSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['stripSerial'] = value

    # doNotifies
  
  def setUnit(self, value):
    """
    Set for ccpnmr.gui.Task.Axis.unit
    """
    dataDict = self.__dict__
    raise ApiError("""%s.setUnit:
     setUnit should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def setWidth(self, value):
    """
    setter for derived attribute width
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setWidth:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setWidth:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('width')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWidth:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWidth:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setWidth:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      group = self.axisWidthGroup
      if group is None:
        self.__dict__['width'] = value
      else:
        for axis in group.axes:
          axis.__dict__['width'] = value
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWidth')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWidth, self.setWidth,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedResonances(self):
    """
    Sorted for ccpnmr.gui.Task.Axis.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedStripAxes(self):
    """
    Sorted for ccpnmr.gui.Task.Axis.stripAxes
    """
    dataDict = self.__dict__
    ll = dataDict.get('stripAxes')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  code = property(getCode, setCode, None,
  r"""Axis code defining axis
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  position = property(getPosition, setPosition, None,
  r"""Centre position on axis in units of unit. NB for a sampled axis, the 
  position is the float value of an integer index.
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  regions = property(getRegions, setRegions, None,
  r"""List of selected region edges in units of unit. The first point is 
  region start, the next region stop, etc. NBNB TBD check if this is OK. 
  """)
  
  resonanceSerials = property(getResonanceSerials, setResonanceSerials, None,
  r"""Serial numbers of attached resonances - used to store resonances while 
  task is disconnected.
  """)
  
  stripSerial = property(getStripSerial, setStripSerial, None,
  r"""Serial of strip that Axis belongs to (Value 0 siginfies all strips).
  """)
  
  unit = property(getUnit, setUnit, None,
  r"""unit used for display
  """)
  
  width = property(getWidth, setWidth, None,
  r"""Display width for the axis in units of unit.NB for a sampled axis, the 
  position is the float value of an integer width.
  """)
  
  axisPositionGroup = property(getAxisPositionGroup, setAxisPositionGroup, None,
  r"""Axis grouping for positions
  """)
  
  axisWidthGroup = property(getAxisWidthGroup, setAxisWidthGroup, None,
  r"""Axis grouping for widths
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for spectrumDisplay
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""Resonances attached to Axis
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  spectrumDisplay = property(getSpectrumDisplay,  None, None,
  r"""parent link
  """)
  
  stripAxes = property(getStripAxes, setStripAxes, None,
  r"""
  """)
  
  strips = property(getStrips, None, None,
  r"""Strips that use Axis, in strip display order
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.Axis', Axis)

###############################################################################
class AxisPositionGroup(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Connecting class for Axis positions. NB. should NOT be coded to directly 
- all handing through Axis connect and disconnect functions.
  """
  #   from data model element ccpnmr.gui.Task.AxisPositionGroup
  _metaclass = metaPackage.getElement('AxisPositionGroup')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'axes', 'guiTask', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.AxisPositionGroup
    """
    dataDict = self.__dict__
    dataDict['guiTask'] = parent
    if (not isinstance(parent, GuiTask)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['serial'] = None
      dataDict['axes'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.AxisPositionGroup', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.AxisPositionGroup.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccpnmr.gui.Task.AxisPositionGroup')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('axisPositionGroups')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.AxisPositionGroup:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.AxisPositionGroup:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for axis in dataDict.get('axes'):
      if (not (axis in objsToBeDeleted)):
        axis.__dict__['axisPositionGroup'] = None

    guiTask = dataDict.get('guiTask')
    if (not (guiTask in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = guiTask.__dict__.get('axisPositionGroups')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.AxisPositionGroup:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    guiTask = dataDict.get('guiTask')

    childrenDict = guiTask.__dict__.get('axisPositionGroups')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for axis in dataDict.get('axes'):
      if (not (axis in objsToBeUnDeleted)):
        if (axis.__dict__.get('axisPositionGroup') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of AxisPositionGroup object axes link - backLink Axis.axisPositionGroup is not None""" % self.qualifiedName
          )

        axis.__dict__['axisPositionGroup'] = self

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addAxis(self, value):
    """
    Add for ccpnmr.gui.Task.AxisPositionGroup.axes
    """
    dataDict = self.__dict__
    if (not isinstance(value, Axis)):
      raise ApiError("""%s.addAxis:
       value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.axisPositionGroup}

    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAxis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAxis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addAxis:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addAxis:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      oldSelf = value.__dict__.get('axisPositionGroup')
      if (oldSelf is not None):
        siblingValues = oldSelf.__dict__.get('axes')
        if (len(siblingValues) < (2 + 1)):
          raise ApiError("""%s.addAxis:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addAxis:
           Link axes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('axisPositionGroup')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('axes')
      siblingValues.remove(value)

    value.__dict__['axisPositionGroup'] = self
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAxis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addAxis, undoArgs=(undoValueDict, 'axisPositionGroup'),  redoArgs=(value,))

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.AxisPositionGroup
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.AxisPositionGroup
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('guiTask')
        dd = value.__dict__.get('axisPositionGroups')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'guiTask' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('axes')
      for value in values:
        if (not isinstance(value, Axis)):
          raise ApiError("""%s.checkValid: axes:
           value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('axisPositionGroup')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: axes:
           non-reciprocal link axes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: axes:
           Link axes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('guiTask')
      if (not isinstance(value, GuiTask)):
        raise ApiError("""%s.checkValid: guiTask:
         value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    values = dataDict.get('axes')
    if (len(values) < 2):
      raise ApiError("""%s.checkValid: axes:
       locard: values must be of length >= 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('guiTask')
    if (value is None):
      raise ApiError("""%s.checkValid: guiTask:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllAxes(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.AxisPositionGroup.axes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('axes')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('axes')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAxis(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.AxisPositionGroup.axes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('axes')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('axes')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.AxisPositionGroup
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxes(self):
    """
    Get for ccpnmr.gui.Task.AxisPositionGroup.axes
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('axes')
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.AxisPositionGroup
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.AxisPositionGroup'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.AxisPositionGroup'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('axisPositionGroups').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.AxisPositionGroup
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(dataDict.get('serial'))

    return result
  
  def getGuiTask(self):
    """
    Get for ccpnmr.gui.Task.AxisPositionGroup.guiTask
    """
    dataDict = self.__dict__
    result = dataDict.get('guiTask')
    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.AxisPositionGroup
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.AxisPositionGroup.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('guiTask')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccpnmr.gui.Task.AxisPositionGroup.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeAxis(self, value):
    """
    Remove for ccpnmr.gui.Task.AxisPositionGroup.axes
    """
    dataDict = self.__dict__
    if (not isinstance(value, Axis)):
      raise ApiError("""%s.removeAxis:
       value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAxis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAxis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeAxis:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAxis:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (2 + 1)):
        raise ApiError("""%s.removeAxis:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    undoValues = set(currentValues)
    value.__dict__['axisPositionGroup'] = None
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAxis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxes, self.removeAxis,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.AxisPositionGroup
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxes(self, values):
    """
    Set for ccpnmr.gui.Task.AxisPositionGroup.axes
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAxes:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, Axis)):
        raise ApiError("""%s.setAxes:
         value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.axisPositionGroup) for y in (currentValues, values) for x in y)

    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAxes:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxes:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAxes:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (len(values) < 2):
        raise ApiError("""%s.setAxes:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      oldSelves = {}
      for cv in values:
        if (not (cv in currentValues)):
          oldSelf = cv.__dict__.get('axisPositionGroup')
          if (oldSelf is not None):
            knt = oldSelves.get(oldSelf)
            if (knt is None):
              knt = 1
            else:
              knt = knt + 1

            oldSelves[oldSelf] = knt

      for osv in oldSelves.keys():
        siblingValues = osv.__dict__.get('axes')
        knt = oldSelves.get(osv)
        if (len(siblingValues) < (2 + knt)):
          raise ApiError("""%s.setAxes:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAxes:
           Link axes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['axisPositionGroup'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('axisPositionGroup')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('axes')
          vv.remove(cv)

      cv.__dict__['axisPositionGroup'] = self

    dataDict['axes'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAxes')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setAxes, undoArgs=(undoValueDict, 'axisPositionGroup'),  redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setSerial(self, value):
    """
    Set for ccpnmr.gui.Task.AxisPositionGroup.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('guiTask')
    oldSerial = parent.__dict__.get('_serialDict').get('axisPositionGroups')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['axisPositionGroups'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['axisPositionGroups'] = value

    dataDict['serial'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedAxes(self):
    """
    Sorted for ccpnmr.gui.Task.AxisPositionGroup.axes
    """
    dataDict = self.__dict__
    ll = dataDict.get('axes')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  axes = property(getAxes, setAxes, None,
  r"""Axes connected through PositionGroup
  """)
  
  guiTask = property(getGuiTask,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for guiTask
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.AxisPositionGroup', AxisPositionGroup)

###############################################################################
class AxisWidthGroup(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Connecting class for Axis widths. NB. should NOT be coded to directly - 
all handing through Axis connect and disconnect functions.
  """
  #   from data model element ccpnmr.gui.Task.AxisWidthGroup
  _metaclass = metaPackage.getElement('AxisWidthGroup')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'axes', 'guiTask', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.AxisWidthGroup
    """
    dataDict = self.__dict__
    dataDict['guiTask'] = parent
    if (not isinstance(parent, GuiTask)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['serial'] = None
      dataDict['axes'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.AxisWidthGroup', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.AxisWidthGroup.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccpnmr.gui.Task.AxisWidthGroup')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('axisWidthGroups')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.AxisWidthGroup:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.AxisWidthGroup:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    for axis in dataDict.get('axes'):
      if (not (axis in objsToBeDeleted)):
        axis.__dict__['axisWidthGroup'] = None

    guiTask = dataDict.get('guiTask')
    if (not (guiTask in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = guiTask.__dict__.get('axisWidthGroups')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.AxisWidthGroup:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    guiTask = dataDict.get('guiTask')

    childrenDict = guiTask.__dict__.get('axisWidthGroups')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    for axis in dataDict.get('axes'):
      if (not (axis in objsToBeUnDeleted)):
        if (axis.__dict__.get('axisWidthGroup') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of AxisWidthGroup object axes link - backLink Axis.axisWidthGroup is not None""" % self.qualifiedName
          )

        axis.__dict__['axisWidthGroup'] = self

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addAxis(self, value):
    """
    Add for ccpnmr.gui.Task.AxisWidthGroup.axes
    """
    dataDict = self.__dict__
    if (not isinstance(value, Axis)):
      raise ApiError("""%s.addAxis:
       value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.axisWidthGroup}

    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAxis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAxis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addAxis:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addAxis:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      oldSelf = value.__dict__.get('axisWidthGroup')
      if (oldSelf is not None):
        siblingValues = oldSelf.__dict__.get('axes')
        if (len(siblingValues) < (2 + 1)):
          raise ApiError("""%s.addAxis:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addAxis:
           Link axes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('axisWidthGroup')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('axes')
      siblingValues.remove(value)

    value.__dict__['axisWidthGroup'] = self
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAxis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addAxis, undoArgs=(undoValueDict, 'axisWidthGroup'),  redoArgs=(value,))

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.AxisWidthGroup
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.AxisWidthGroup
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('guiTask')
        dd = value.__dict__.get('axisWidthGroups')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'guiTask' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('axes')
      for value in values:
        if (not isinstance(value, Axis)):
          raise ApiError("""%s.checkValid: axes:
           value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('axisWidthGroup')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: axes:
           non-reciprocal link axes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: axes:
           Link axes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('guiTask')
      if (not isinstance(value, GuiTask)):
        raise ApiError("""%s.checkValid: guiTask:
         value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    values = dataDict.get('axes')
    if (len(values) < 2):
      raise ApiError("""%s.checkValid: axes:
       locard: values must be of length >= 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('guiTask')
    if (value is None):
      raise ApiError("""%s.checkValid: guiTask:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllAxes(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.AxisWidthGroup.axes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('axes')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('axes')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAxis(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.AxisWidthGroup.axes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('axes')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('axes')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.AxisWidthGroup
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxes(self):
    """
    Get for ccpnmr.gui.Task.AxisWidthGroup.axes
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('axes')
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.AxisWidthGroup
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.AxisWidthGroup'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.AxisWidthGroup'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('axisWidthGroups').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.AxisWidthGroup
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(dataDict.get('serial'))

    return result
  
  def getGuiTask(self):
    """
    Get for ccpnmr.gui.Task.AxisWidthGroup.guiTask
    """
    dataDict = self.__dict__
    result = dataDict.get('guiTask')
    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.AxisWidthGroup
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.AxisWidthGroup.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('guiTask')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccpnmr.gui.Task.AxisWidthGroup.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeAxis(self, value):
    """
    Remove for ccpnmr.gui.Task.AxisWidthGroup.axes
    """
    dataDict = self.__dict__
    if (not isinstance(value, Axis)):
      raise ApiError("""%s.removeAxis:
       value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAxis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAxis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeAxis:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAxis:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (2 + 1)):
        raise ApiError("""%s.removeAxis:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    undoValues = set(currentValues)
    value.__dict__['axisWidthGroup'] = None
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAxis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxes, self.removeAxis,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.AxisWidthGroup
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxes(self, values):
    """
    Set for ccpnmr.gui.Task.AxisWidthGroup.axes
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAxes:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, Axis)):
        raise ApiError("""%s.setAxes:
         value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.axisWidthGroup) for y in (currentValues, values) for x in y)

    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAxes:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxes:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAxes:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (len(values) < 2):
        raise ApiError("""%s.setAxes:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      oldSelves = {}
      for cv in values:
        if (not (cv in currentValues)):
          oldSelf = cv.__dict__.get('axisWidthGroup')
          if (oldSelf is not None):
            knt = oldSelves.get(oldSelf)
            if (knt is None):
              knt = 1
            else:
              knt = knt + 1

            oldSelves[oldSelf] = knt

      for osv in oldSelves.keys():
        siblingValues = osv.__dict__.get('axes')
        knt = oldSelves.get(osv)
        if (len(siblingValues) < (2 + knt)):
          raise ApiError("""%s.setAxes:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAxes:
           Link axes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['axisWidthGroup'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('axisWidthGroup')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('axes')
          vv.remove(cv)

      cv.__dict__['axisWidthGroup'] = self

    dataDict['axes'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAxes')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setAxes, undoArgs=(undoValueDict, 'axisWidthGroup'),  redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setSerial(self, value):
    """
    Set for ccpnmr.gui.Task.AxisWidthGroup.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('guiTask')
    oldSerial = parent.__dict__.get('_serialDict').get('axisWidthGroups')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['axisWidthGroups'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['axisWidthGroups'] = value

    dataDict['serial'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedAxes(self):
    """
    Sorted for ccpnmr.gui.Task.AxisWidthGroup.axes
    """
    dataDict = self.__dict__
    ll = dataDict.get('axes')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  axes = property(getAxes, setAxes, None,
  r"""Axes connected through WidthGroup
  """)
  
  guiTask = property(getGuiTask,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for guiTask
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.AxisWidthGroup', AxisWidthGroup)

###############################################################################
class GuiTask(ccpnmodel.ccpncore.api.memops.Implementation.TopObject):
  r"""Task - group of modules that together accomplish a task. Serves both to 
store working activities, and as shareable template desciptions. You 
must pass in either an nmrProject or an nmrProjectName.
  """
  #   from data model element ccpnmr.gui.Task.GuiTask
  _metaclass = metaPackage.getElement('GuiTask')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', '_lastId', 'applicationData', 'ccpnInternalData', 'className', 'createdBy', 'details', 'fieldNames', 'guid', 'inConstructor', 'isDeleted', 'isLoaded', 'isModifiable', 'isModified', 'isReading', 'lastUnlockedBy', 'metaclass', 'name', 'nameSpace', 'nmrProjectName', 'packageName', 'packageShortName', 'qualifiedName', 'activeRepositories', 'axisPositionGroups', 'axisWidthGroups', 'marks', 'memopsRoot', 'modules', 'nmrProject', 'packageLocator', 'parent', 'root', 'topObject', 'windows',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.GuiTask
    """
    dataDict = self.__dict__
    dataDict['memopsRoot'] = parent
    from ccpnmodel.ccpncore.api.memops.Implementation import MemopsRoot as importedType
    if (not isinstance(parent, importedType)):
      raise ApiError("""%s.__init__:
       value is not of class memops.Implementation.MemopsRoot""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = self
    dataDict['topObject'] = topObject
    if (attrlinks.get('isReading', False)):
      del attrlinks['isReading']
      dataDict['isLoaded'] = False
      dataDict['isModified'] = False
      dataDict['isReading'] = True
    elif (parent.__dict__.get('isReading')):
      dataDict['isLoaded'] = False
      dataDict['isModified'] = False
      dataDict['isReading'] = True
    else:
      dataDict['isLoaded'] = True
      dataDict['isModified'] = True
      dataDict['isReading'] = False

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    try:
      if (not (dataDict.get('isReading'))):
        parent.refreshTopObjects('ccpnmr.gui.Task')

      dataDict['_ID'] = None
      dataDict['_lastId'] = 0
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['createdBy'] = None
      dataDict['details'] = None
      dataDict['guid'] = None
      dataDict['isModifiable'] = True
      dataDict['lastUnlockedBy'] = None
      dataDict['name'] = None
      dataDict['nameSpace'] = 'user'
      dataDict['nmrProjectName'] = None
      dataDict['axisPositionGroups'] = {}
      dataDict['axisWidthGroups'] = {}
      dataDict['marks'] = {}
      dataDict['modules'] = {}
      dataDict['nmrProject'] = None
      dataDict['windows'] = set()
      dataDict['activeRepositories'] = list()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.GuiTask', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.GuiTask.__init__")
        del dataDict['inConstructor']
        raise

      serialDict = {}
      serialDict['axisPositionGroups'] = 0
      serialDict['axisWidthGroups'] = 0
      serialDict['marks'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('guiTasks')
        ll = list()
        objKey = dataDict.get('nameSpace')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('name')
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['nameSpace', 'name'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        guid = dataDict.get('guid')
        if (guid is None):
          guid = root.newGuid()
          dataDict['guid'] = guid

        dd = root.__dict__.get('topObjects')
        if (dd.get(guid) is None):
          dd[guid] = self
        else:
          raise ApiError("""%s.__init__:
           Creating TopObject with preexisting guid""" % self.qualifiedName
           + ": %s" % (self,)
          )

        dataDict['createdBy'] = root.__dict__.get('currentUserId')
        
        
        if self.nmrProject is None:
          self.root.override = True
          try:
            self.nmrProject = self.root.findFirstNmrProject(name=self.nmrProjectName)
          finally:
            self.root.override = False
        else:
          dataDict['nmrProjectName'] = self.nmrProject.name
        
        if self.nmrProject is not None:
          if not self.windows:
            windowStore = self.nmrProject.windowStore
            if windowStore is not None:
              windows = windowStore.sortedWindows()
              for window in windows:
                if window.guiTask is None:
                  break
              else:
                # There will always be at least one window - the Main one.
                nextSerial = windows[-1].serial + 1
                window = windowStore.newWindow(title='W%s' % nextSerial)
                objectsCreated.add(window)
              window.guiTask = self

      if (notOverride):
        self.checkValid()

      if ((notIsReading or root.__dict__.get('currentGuiTask') is None)):
        root.__dict__['currentGuiTask'] = self

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.GuiTask:
       determines cascading deletes 
    to follow from delete of object.
       *Implementation function* - should 
    be called only by API delete function.
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    objsToBeDeleted.add(self)
    axisPositionGroups = dataDict.get('axisPositionGroups').values()
    for axisPositionGroup in axisPositionGroups:
      if (not (axisPositionGroup in objsToBeDeleted)):
        objsToBeDeleted.add(axisPositionGroup)
        objsToBeChecked.append(axisPositionGroup)

    axisWidthGroups = dataDict.get('axisWidthGroups').values()
    for axisWidthGroup in axisWidthGroups:
      if (not (axisWidthGroup in objsToBeDeleted)):
        objsToBeDeleted.add(axisWidthGroup)
        objsToBeChecked.append(axisWidthGroup)

    marks = dataDict.get('marks').values()
    for mark in marks:
      if (not (mark in objsToBeDeleted)):
        objsToBeDeleted.add(mark)
        objsToBeChecked.append(mark)

    memopsRoot = dataDict.get('memopsRoot')
    if (memopsRoot is not None):
      topObject = memopsRoot.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    modules = dataDict.get('modules').values()
    for module in modules:
      if (not (module in objsToBeDeleted)):
        objsToBeDeleted.add(module)
        objsToBeChecked.append(module)

    nmrProject = dataDict.get('nmrProject')
    if (nmrProject is not None):
      topObject = nmrProject.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    windows = dataDict.get('windows')
    pass
    for window in windows:
      topObject = window.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.GuiTask:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    memopsRoot = dataDict.get('memopsRoot')
    if (self is memopsRoot.__dict__.get('currentGuiTask')):
      memopsRoot.__dict__['currentGuiTask'] = None

    nmrProject = dataDict.get('nmrProject')
    if ((nmrProject is not None and not (nmrProject in objsToBeDeleted))):
      guiTasks = nmrProject.__dict__.get('guiTasks')
      guiTasks.remove(self)

    for window in dataDict.get('windows'):
      if (not (window in objsToBeDeleted)):
        window.__dict__['guiTask'] = None

    memopsRoot = dataDict.get('memopsRoot')
    if (not (memopsRoot in objsToBeDeleted)):
      ll = list()
      objKey = dataDict.get('nameSpace')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('name')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = memopsRoot.__dict__.get('guiTasks')
        if (self is dd.get(objKey)):
          del dd[objKey]

    dataDict['axisPositionGroups'] = {}
    dataDict['axisWidthGroups'] = {}
    dataDict['marks'] = {}
    dataDict['modules'] = {}
  
  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.GuiTask:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    memopsRoot = dataDict.get('memopsRoot')

    childrenDict = memopsRoot.__dict__.get('guiTasks')
    ll = list()
    objKey = dataDict.get('nameSpace')
    ll.append(objKey)
    if (objKey is not None):
      objKey = dataDict.get('name')
      ll.append(objKey)
      if (objKey is not None):
        objKey = tuple(ll)

    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['nameSpace', 'name'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    nmrProject = dataDict.get('nmrProject')
    if ((nmrProject is not None and not (nmrProject in objsToBeUnDeleted))):
      guiTasks = nmrProject.__dict__.get('guiTasks')
      guiTasks.add(self)

    for window in dataDict.get('windows'):
      if (not (window in objsToBeUnDeleted)):
        if (window.__dict__.get('guiTask') is not None):
          raise ApiError("""%s._singleUnDelete:
           Error undoing delete of GuiTask object windows link - backLink Window.guiTask is not None""" % self.qualifiedName
          )

        window.__dict__['guiTask'] = self

    memopsRoot.__dict__['topObjects'][self.guid] = self

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addWindow(self, value):
    """
    Add for ccpnmr.gui.Task.GuiTask.windows
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccpnmr.gui.Window import Window as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addWindow:
       value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('windows')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = {value:value.guiTask}

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('guiTask') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccpnmr.gui.Task')
        tobjList = root.__dict__.get('guiTasks').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('guiTask')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addWindow:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addWindow:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addWindow:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addWindow:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addWindow:
           Link windows between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    undoValues = set(currentValues)
    oldSelf = value.__dict__.get('guiTask')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('windows')
      siblingValues.remove(value)

    value.__dict__['guiTask'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addWindow')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.addWindow, undoArgs=(undoValueDict, 'guiTask'),  redoArgs=(value,))

  backup = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.backup
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.GuiTask
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    self.checkValid(complete)
    values = dataDict.get('axisPositionGroups').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('axisWidthGroups').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('marks').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('modules').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.GuiTask
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      ll = list()
      objKey = dataDict.get('nameSpace')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('name')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('memopsRoot')
        dd = value.__dict__.get('guiTasks')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'memopsRoot' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('_lastId')
      if (value is None):
        raise ApiError("""%s.checkValid: _lastId:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _lastId:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('createdBy')
      if (value is None):
        raise ApiError("""%s.checkValid: createdBy:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: createdBy:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('guid')
      if (value is None):
        raise ApiError("""%s.checkValid: guid:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: guid:
         GuidString constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      isValid = frozenset('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789-').issuperset(value)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: guid:
         GuidString constraint value_is_url_safe violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('isModifiable')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: isModifiable:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('lastUnlockedBy')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: name:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('nameSpace')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: nameSpace:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: nameSpace:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: nameSpace:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: nameSpace:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('nmrProjectName')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: nmrProjectName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: nmrProjectName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: nmrProjectName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: nmrProjectName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      values = dataDict.get('axisPositionGroups').values()
      for value in values:
        if (not isinstance(value, AxisPositionGroup)):
          raise ApiError("""%s.checkValid: axisPositionGroups:
           value is not of class ccpnmr.gui.Task.AxisPositionGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('guiTask')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: axisPositionGroups:
           non-reciprocal link axisPositionGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('axisWidthGroups').values()
      for value in values:
        if (not isinstance(value, AxisWidthGroup)):
          raise ApiError("""%s.checkValid: axisWidthGroups:
           value is not of class ccpnmr.gui.Task.AxisWidthGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('guiTask')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: axisWidthGroups:
           non-reciprocal link axisWidthGroups from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('marks').values()
      for value in values:
        if (not isinstance(value, Mark)):
          raise ApiError("""%s.checkValid: marks:
           value is not of class ccpnmr.gui.Task.Mark""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('guiTask')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: marks:
           non-reciprocal link marks from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('memopsRoot')
      from ccpnmodel.ccpncore.api.memops.Implementation import MemopsRoot as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: memopsRoot:
         value is not of class memops.Implementation.MemopsRoot""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('modules').values()
      for value in values:
        if (not isinstance(value, Module)):
          raise ApiError("""%s.checkValid: modules:
           value is not of class ccpnmr.gui.Task.Module""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('guiTask')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: modules:
           non-reciprocal link modules from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('nmrProject')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrProject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrProject:
           value is not of class ccp.nmr.Nmr.NmrProject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('guiTasks')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrProject:
           non-reciprocal link nmrProject from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = self.getPackageLocator()
      if (value is None):
        raise ApiError("""%s.checkValid: packageLocator:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      from ccpnmodel.ccpncore.api.memops.Implementation import PackageLocator as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: packageLocator:
         value is not of class memops.Implementation.PackageLocator""" % self.qualifiedName
         + ": %s" % (value,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.checkValid: packageLocator:
         Link packageLocator between objects from separate partitions
          - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      values = dataDict.get('windows')
      for value in values:
        from ccpnmodel.ccpncore.api.ccpnmr.gui.Window import Window as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: windows:
           value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('guiTask')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: windows:
           non-reciprocal link windows from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: windows:
           Link windows between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (dataDict.get('isLoaded')):
      # check explicit class constraints
      # check attributes
      values = dataDict.get('applicationData')
      for value in values:
        value.checkAllValid(complete)

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (not (value is None or isinstance(value, dict))):
          raise ApiError("""%s.checkValid: ccpnInternalData:
           ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      value = dataDict.get('isModifiable')
      if (value is None):
        raise ApiError("""%s.checkValid: isModifiable:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('name')
      if (value is None):
        raise ApiError("""%s.checkValid: name:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('nameSpace')
      if (value is None):
        raise ApiError("""%s.checkValid: nameSpace:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('nmrProjectName')
      if (value is None):
        raise ApiError("""%s.checkValid: nmrProjectName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      # check roles
      values = dataDict.get('axisPositionGroups').values()
      values = dataDict.get('axisWidthGroups').values()
      values = dataDict.get('marks').values()
      value = dataDict.get('memopsRoot')
      if (value is None):
        raise ApiError("""%s.checkValid: memopsRoot:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('modules').values()
      value = dataDict.get('nmrProject')
      values = dataDict.get('windows')
    else:
      # check unloaded TopObject
      value = dataDict.get('guid')
      if (value is None):
        raise ApiError("""%s.checkValid: guid:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('nameSpace')
      if (value is None):
        raise ApiError("""%s.checkValid: nameSpace:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('name')
      if (value is None):
        raise ApiError("""%s.checkValid: name:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllActiveRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.findAllActiveRepositories

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllAxisPositionGroups(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.GuiTask.axisPositionGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('axisPositionGroups').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('axisPositionGroups').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'guiTask',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllAxisWidthGroups(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.GuiTask.axisWidthGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('axisWidthGroups').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('axisWidthGroups').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'guiTask',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllMarks(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.GuiTask.marks
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('marks').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('marks').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'colour', 'serial', 'style', 'guiTask',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllModules(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.GuiTask.modules
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('modules').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('modules').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'windowId', 'guiTask', 'window',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllWindows(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.GuiTask.windows
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('windows')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('windows')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'title', 'guiTask', 'windowStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstActiveRepository = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.findFirstActiveRepository

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAxisPositionGroup(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.GuiTask.axisPositionGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('axisPositionGroups').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('axisPositionGroups').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('axisPositionGroups').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'guiTask',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstAxisWidthGroup(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.GuiTask.axisWidthGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('axisWidthGroups').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('axisWidthGroups').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('axisWidthGroups').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'guiTask',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstMark(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.GuiTask.marks
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('marks').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('marks').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('marks').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'colour', 'serial', 'style', 'guiTask',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstModule(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.GuiTask.modules
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('modules').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('name')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('modules').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('modules').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'details', 'name', 'windowId', 'guiTask', 'window',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstWindow(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.GuiTask.windows
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('windows')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('windows')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'serial', 'title', 'guiTask', 'windowStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.GuiTask
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getActiveRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getActiveRepositories

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxisPositionGroups(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.axisPositionGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('axisPositionGroups').values()
    result = frozenset(tempVar)
    return result
  
  def getAxisWidthGroups(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.axisWidthGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('axisWidthGroups').values()
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.GuiTask
    """

    result = None
    if (2 != len(fullKey)):
      raise ApiError("""'ccpnmr.gui.Task.GuiTask'.getByKey:
       getByKey called with fullKey of wrong length. Parameters:"""
       + ": %s:%s" % (startObj, fullKey)
      )

    ll = list()
    objKey = fullKey[0]
    ll.append(objKey)
    if (objKey is not None):
      objKey = fullKey[1]
      ll.append(objKey)
      if (objKey is not None):
        objKey = tuple(ll)

    obj1 = startObj.__dict__.get('guiTasks').get(objKey)
    if (obj1 is None):
      startObj.refreshTopObjects('ccpnmr.gui.Task')
      obj1 = startObj.__dict__.get('guiTasks').get(objKey)

    result = obj1
    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getCreatedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getCreatedBy
  
  def getDetails(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.GuiTask
    """
    dataDict = self.__dict__
    result = list()

    if (useGuid):
      result.append(dataDict.get('guid'))
    else:
      result.append(dataDict.get('nameSpace'))
      result.append(dataDict.get('name'))

    return result

  getGuid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getGuid

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getIsLoaded = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsLoaded

  getIsModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsModifiable

  getIsModified = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsModified

  getIsReading = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getIsReading

  getLastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getLastUnlockedBy
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.GuiTask
    """
    dataDict = self.__dict__
    ll = list()
    result = dataDict.get('nameSpace')
    ll.append(result)
    if (result is not None):
      result = dataDict.get('name')
      ll.append(result)
      if (result is not None):
        result = tuple(ll)

    return result
  
  def getMarks(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.marks
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('marks').values()
    result = frozenset(tempVar)
    return result
  
  def getMemopsRoot(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.memopsRoot
    """
    dataDict = self.__dict__
    result = dataDict.get('memopsRoot')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getModules(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.modules
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('modules').values()
    result = frozenset(tempVar)
    return result
  
  def getName(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNameSpace(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.nameSpace
    """
    dataDict = self.__dict__
    result = dataDict.get('nameSpace')
    return result
  
  def getNmrProject(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.nmrProject
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrProject')
    return result
  
  def getNmrProjectName(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.nmrProjectName
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrProjectName')
    return result

  getPackageLocator = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.getPackageLocator

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('memopsRoot')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getWindows(self):
    """
    Get for ccpnmr.gui.Task.GuiTask.windows
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('windows')
    result = frozenset(tempVar)
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  get_lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.get_lastId

  load = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.load

  loadFrom = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.loadFrom
  
  def newAxisPositionGroup(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.AxisPositionGroup
    """
    return AxisPositionGroup(self, **attrlinks)
  
  def newAxisWidthGroup(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.AxisWidthGroup
    """
    return AxisWidthGroup(self, **attrlinks)
  
  def newBoundDisplay(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.BoundDisplay
    """
    return BoundDisplay(self, **attrlinks)
  
  def newFreeDisplay(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.FreeDisplay
    """
    return FreeDisplay(self, **attrlinks)
  
  def newGenericModule(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.GenericModule
    """
    return GenericModule(self, **attrlinks)
  
  def newMark(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.Mark
    """
    return Mark(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeFrom = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.removeFrom
  
  def removeWindow(self, value):
    """
    Remove for ccpnmr.gui.Task.GuiTask.windows
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccpnmr.gui.Window import Window as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeWindow:
       value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('windows')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeWindow:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeWindow:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeWindow:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeWindow:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    undoValues = set(currentValues)
    value.__dict__['guiTask'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeWindow')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWindows, self.removeWindow,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  restore = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.restore

  save = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.save

  saveTo = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.saveTo
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.GuiTask
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setCreatedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setCreatedBy
  
  def setDetails(self, value):
    """
    Set for ccpnmr.gui.Task.GuiTask.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setGuid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setGuid

  setIsModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setIsModifiable

  setLastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.setLastUnlockedBy
  
  def setName(self, value):
    """
    Set for ccpnmr.gui.Task.GuiTask.name
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setName:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setName:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setName:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setName:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setName:
         cannot set name, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['name'] = value

    # doNotifies
  
  def setNameSpace(self, value):
    """
    Set for ccpnmr.gui.Task.GuiTask.nameSpace
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setNameSpace:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setNameSpace:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setNameSpace:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setNameSpace:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('nameSpace')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNameSpace:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setNameSpace:
         cannot set nameSpace, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setNameSpace:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['nameSpace'] = value

    # doNotifies
  
  def setNmrProject(self, value):
    """
    Set for ccpnmr.gui.Task.GuiTask.nmrProject
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import NmrProject as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setNmrProject:
         value is not of class ccp.nmr.Nmr.NmrProject""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('nmrProject')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrProject:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrProject:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setNmrProject:
         cannot set nmrProject, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setNmrProject:
           Link nmrProject between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('guiTasks')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setNmrProject:
         Read link 'nmrProject' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('guiTasks')
      newSelves.add(self)

    dataDict['nmrProject'] = value

    # doNotifies
  
  def setNmrProjectName(self, value):
    """
    Set for ccpnmr.gui.Task.GuiTask.nmrProjectName
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setNmrProjectName:
       memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 80):
      raise ApiError("""%s.setNmrProjectName:
       memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setNmrProjectName:
       memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.splitlines()) <= 1)):
      raise ApiError("""%s.setNmrProjectName:
       Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('nmrProjectName')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrProjectName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setNmrProjectName:
         cannot set nmrProjectName, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setNmrProjectName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['nmrProjectName'] = value

    # doNotifies
  
  def setWindows(self, values):
    """
    Set for ccpnmr.gui.Task.GuiTask.windows
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setWindows:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccpnmodel.ccpncore.api.ccpnmr.gui.Window import Window as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setWindows:
         value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('windows')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      undoValueDict = collections.OrderedDict((x, x.guiTask) for y in (currentValues, values) for x in y)

    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccpnmr.gui.Task')
      tobjList = set(root.__dict__.get('guiTasks').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('guiTask')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setWindows:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWindows:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWindows:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setWindows:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setWindows:
           Link windows between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['guiTask'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('guiTask')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('windows')
          vv.remove(cv)

      cv.__dict__['guiTask'] = self

    dataDict['windows'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWindows')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(restoreOriginalLinks, self.setWindows, undoArgs=(undoValueDict, 'guiTask'),  redoArgs=(values,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  set_lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.set_lastId
  
  def sortedAxisPositionGroups(self):
    """
    Sorted for ccpnmr.gui.Task.GuiTask.axisPositionGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('axisPositionGroups')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedAxisWidthGroups(self):
    """
    Sorted for ccpnmr.gui.Task.GuiTask.axisWidthGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('axisWidthGroups')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedMarks(self):
    """
    Sorted for ccpnmr.gui.Task.GuiTask.marks
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('marks')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedModules(self):
    """
    Sorted for ccpnmr.gui.Task.GuiTask.modules
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('modules')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedWindows(self):
    """
    Sorted for ccpnmr.gui.Task.GuiTask.windows
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('windows')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  touch = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.touch

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  _lastId = ccpnmodel.ccpncore.api.memops.Implementation.TopObject._lastId

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  createdBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.createdBy
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  guid = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.guid

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  isLoaded = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isLoaded

  isModifiable = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isModifiable

  isModified = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isModified

  isReading = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.isReading

  lastUnlockedBy = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.lastUnlockedBy

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of Task - Together with namespace identifies Task.
  """)
  
  nameSpace = property(getNameSpace, setNameSpace, None,
  r"""Name space of Task.Groups tasks by origin. Only tasks in namespace 
  'user' are modifiable, and can be connected to actual data.
  """)
  
  nmrProjectName = property(getNmrProjectName, setNmrProjectName, None,
  r"""NmrProject name. Serves to store link to NmrProject while task is 
  disconnected.
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  activeRepositories = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.activeRepositories
  
  axisPositionGroups = property(getAxisPositionGroups,  None, None,
  r"""child link to class AxisPositionGroup
  """)
  
  axisWidthGroups = property(getAxisWidthGroups,  None, None,
  r"""child link to class AxisWidthGroup
  """)
  
  marks = property(getMarks,  None, None,
  r"""child link to class Mark
  """)
  
  memopsRoot = property(getMemopsRoot,  None, None,
  r"""parent link
  """)
  
  modules = property(getModules,  None, None,
  r"""child link to class Module
  """)
  
  nmrProject = property(getNmrProject, setNmrProject, None,
  r"""NmrProject that task is active in. Tasks with no NmrProject attached are 
  not active.
  """)

  packageLocator = ccpnmodel.ccpncore.api.memops.Implementation.TopObject.packageLocator
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for memopsRoot
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject
  
  windows = property(getWindows, setWindows, None,
  r"""Wndows displaying GuiTAsk
  """)

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.GuiTask', GuiTask)

###############################################################################
class Mark(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Group of markings - infinite lines at specific positions exending across 
all matching axes fo all windows.
  """
  #   from data model element ccpnmr.gui.Task.Mark
  _metaclass = metaPackage.getElement('Mark')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'colour', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'style', 'guiTask', 'parent', 'root', 'rulers', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.Mark
    """
    dataDict = self.__dict__
    dataDict['guiTask'] = parent
    if (not isinstance(parent, GuiTask)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['colour'] = None
      dataDict['serial'] = None
      dataDict['style'] = 'simple'
      dataDict['rulers'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.Mark', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.Mark.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccpnmr.gui.Task.Mark')
          )

      serialDict = {}
      serialDict['rulers'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('marks')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.Mark:
       determines cascading deletes to 
    follow from delete of object.
       *Implementation function* - should be 
    called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    rulers = dataDict.get('rulers').values()
    for ruler in rulers:
      if (not (ruler in objsToBeDeleted)):
        objsToBeDeleted.add(ruler)
        objsToBeChecked.append(ruler)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.Mark:   deletes objects
    *Implementation 
    function* - will CORRUPT DATA if called outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    guiTask = dataDict.get('guiTask')
    if (not (guiTask in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = guiTask.__dict__.get('marks')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.Mark:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    guiTask = dataDict.get('guiTask')

    childrenDict = guiTask.__dict__.get('marks')
    objKey = dataDict.get('serial')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['serial'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.Mark
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('rulers').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.Mark
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('guiTask')
        dd = value.__dict__.get('marks')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'guiTask' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('colour')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: colour:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: colour:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: colour:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: colour:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('style')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: style:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: style:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: style:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: style:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('guiTask')
      if (not isinstance(value, GuiTask)):
        raise ApiError("""%s.checkValid: guiTask:
         value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('rulers').values()
      for value in values:
        if (not isinstance(value, Ruler)):
          raise ApiError("""%s.checkValid: rulers:
           value is not of class ccpnmr.gui.Task.Ruler""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('mark')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: rulers:
           non-reciprocal link rulers from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('colour')
    if (value is None):
      raise ApiError("""%s.checkValid: colour:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('style')
    if (value is None):
      raise ApiError("""%s.checkValid: style:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('guiTask')
    if (value is None):
      raise ApiError("""%s.checkValid: guiTask:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('rulers').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllRulers(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Mark.rulers
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('rulers').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('rulers').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'axisCode', 'ccpnInternalData', 'label', 'position', 'serial', 'unit', 'mark',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstRuler(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Mark.rulers
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('rulers').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('rulers').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('rulers').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'axisCode', 'ccpnInternalData', 'label', 'position', 'serial', 'unit', 'mark',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.Mark
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.Mark
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Mark'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Mark'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('marks').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getColour(self):
    """
    Get for ccpnmr.gui.Task.Mark.colour
    """
    dataDict = self.__dict__
    result = dataDict.get('colour')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.Mark
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(dataDict.get('serial'))

    return result
  
  def getGuiTask(self):
    """
    Get for ccpnmr.gui.Task.Mark.guiTask
    """
    dataDict = self.__dict__
    result = dataDict.get('guiTask')
    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.Mark
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.Mark.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('guiTask')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getRulers(self):
    """
    Get for ccpnmr.gui.Task.Mark.rulers
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('rulers').values()
    result = frozenset(tempVar)
    return result
  
  def getSerial(self):
    """
    Get for ccpnmr.gui.Task.Mark.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getStyle(self):
    """
    Get for ccpnmr.gui.Task.Mark.style
    """
    dataDict = self.__dict__
    result = dataDict.get('style')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newRuler(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.Ruler
    """
    return Ruler(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.Mark
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setColour(self, value):
    """
    Set for ccpnmr.gui.Task.Mark.colour
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setColour:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setColour:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setColour:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setColour:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('colour')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setColour:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setColour:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setColour:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['colour'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setColour')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setColour, self.setColour,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSerial(self, value):
    """
    Set for ccpnmr.gui.Task.Mark.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('guiTask')
    oldSerial = parent.__dict__.get('_serialDict').get('marks')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['marks'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['marks'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setStyle(self, value):
    """
    Set for ccpnmr.gui.Task.Mark.style
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setStyle:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setStyle:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setStyle:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setStyle:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('style')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStyle:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStyle:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setStyle:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['style'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStyle')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setStyle, self.setStyle,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedRulers(self):
    """
    Sorted for ccpnmr.gui.Task.Mark.rulers
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('rulers')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  colour = property(getColour, setColour, None,
  r"""Colour description string
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  style = property(getStyle, setStyle, None,
  r"""Style description string
  """)
  
  guiTask = property(getGuiTask,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for guiTask
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  rulers = property(getRulers,  None, None,
  r"""child link to class Ruler
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.Mark', Mark)

###############################################################################
class Module(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Module, displaying data or actions
  """
  #   from data model element ccpnmr.gui.Task.Module
  _metaclass = metaPackage.getElement('Module')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'windowId', 'guiTask', 'parameters', 'parent', 'root', 'topObject', 'window',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid
  
  def copyToTask(self, newTask, nmrProject):
    """
    Export copy to new task. guiTask and window parameters are mandatory.
    """
    dataDict = self.__dict__
    raise ApiError("""%s.copyToTask:
     copyToTask should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete
  
  def disconnect(self):
    dataDict = self.__dict__
    raise ApiError("""%s.disconnect:
     disconnect should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllParameters(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Module.parameters
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('parameters').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('parameters').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'value', 'module',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstParameter(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Module.parameters
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('parameters').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('name')
      if (objKey is not None):
        result = dataDict.get('parameters').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('parameters').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'name', 'value', 'module',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.Module
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Module'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Module'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('modules').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getDetails(self):
    """
    Get for ccpnmr.gui.Task.Module.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.Module
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(dataDict.get('name'))

    return result
  
  def getGuiTask(self):
    """
    Get for ccpnmr.gui.Task.Module.guiTask
    """
    dataDict = self.__dict__
    result = dataDict.get('guiTask')
    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.Module
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccpnmr.gui.Task.Module.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParameters(self):
    """
    Get for ccpnmr.gui.Task.Module.parameters
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('parameters').values()
    result = frozenset(tempVar)
    return result
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.Module.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('guiTask')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getWindow(self):
    """
    Get for ccpnmr.gui.Task.Module.window
    """
    dataDict = self.__dict__
    result = dataDict.get('window')
    return result
  
  def getWindowId(self):
    """
    Get for ccpnmr.gui.Task.Module.windowId
    """
    dataDict = self.__dict__
    result = dataDict.get('windowId')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newParameter(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.Parameter
    """
    return Parameter(self, **attrlinks)
  
  def reconnect(self, window):
    """
    reconnect module, disambiguating links. window parameter is mandatory
    """
    dataDict = self.__dict__
    raise ApiError("""%s.reconnect:
     reconnect should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setDetails(self, value):
    """
    Set for ccpnmr.gui.Task.Module.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDetails, self.setDetails,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setName(self, value):
    """
    Set for ccpnmr.gui.Task.Module.name
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setName:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setName:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setName:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setName:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setName:
         cannot set name, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['name'] = value

    # doNotifies
  
  def setWindow(self, value):
    """
    Set for ccpnmr.gui.Task.Module.window
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccpnmr.gui.Window import Window as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setWindow:
         value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('window')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      if (value is not None):
        topObject = value.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      if (currentValue is not None):
        topObject = currentValue.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWindow:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWindow:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setWindow:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setWindow:
           Link window between objects from separate partitions
            - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          if (not (value.guiTask is self.guiTask)):
            raise ApiError("""%s.setWindow:
             window constraint all_window_modules_must_belong_to_window_task violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('modules')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setWindow:
         Read link 'window' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('modules')
      newSelves.add(self)

    dataDict['window'] = value
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWindow')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWindow, self.setWindow,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setWindowId(self, value):
    """
    Set for ccpnmr.gui.Task.Module.windowId
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setWindowId:
         memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setWindowId:
         PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('windowId')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWindowId:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWindowId:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['windowId'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWindowId')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWindowId, self.setWindowId,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedParameters(self):
    """
    Sorted for ccpnmr.gui.Task.Module.parameters
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('parameters')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  windowId = property(getWindowId, setWindowId, None,
  r"""Serial of connected window. Serves as group identifier when task is 
  disconnected - modules with same windowId end up in same window, but not 
  necessarily with the same serial.
  """)
  
  guiTask = property(getGuiTask,  None, None,
  r"""parent link
  """)
  
  parameters = property(getParameters,  None, None,
  r"""child link to class Parameter
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for guiTask
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject
  
  window = property(getWindow, setWindow, None,
  r"""Window currently harbouring module
  """)

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.Module', Module)

###############################################################################
class Parameter(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""General-purpose keyword-value parameter for Modules
  """
  #   from data model element ccpnmr.gui.Task.Parameter
  _metaclass = metaPackage.getElement('Parameter')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'value', 'module', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.Parameter
    """
    dataDict = self.__dict__
    dataDict['module'] = parent
    if (not isinstance(parent, Module)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.Module""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['name'] = None
      dataDict['value'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.Parameter', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.Parameter.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('parameters')
        objKey = dataDict.get('name')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['name'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.Parameter:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.Parameter:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    module = dataDict.get('module')
    if (not (module in objsToBeDeleted)):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = module.__dict__.get('parameters')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.Parameter:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    module = dataDict.get('module')
    if (not (module in objsToBeUnDeleted)):

      childrenDict = module.__dict__.get('parameters')
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['name'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.Parameter
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.Parameter
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('module')
        dd = value.__dict__.get('parameters')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'module' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: name:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('value')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: value:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      value = dataDict.get('module')
      if (not isinstance(value, Module)):
        raise ApiError("""%s.checkValid: module:
         value is not of class ccpnmr.gui.Task.Module""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('name')
    if (value is None):
      raise ApiError("""%s.checkValid: name:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('value')
    # check roles
    value = dataDict.get('module')
    if (value is None):
      raise ApiError("""%s.checkValid: module:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.Parameter
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.Parameter
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Parameter'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Parameter'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('parameters').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.Parameter
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('module')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(dataDict.get('name'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.Parameter
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getModule(self):
    """
    Get for ccpnmr.gui.Task.Parameter.module
    """
    dataDict = self.__dict__
    result = dataDict.get('module')
    return result
  
  def getName(self):
    """
    Get for ccpnmr.gui.Task.Parameter.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.Parameter.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('module')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getValue(self):
    """
    Get for ccpnmr.gui.Task.Parameter.value
    """
    dataDict = self.__dict__
    result = dataDict.get('value')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.Parameter
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setName(self, value):
    """
    Set for ccpnmr.gui.Task.Parameter.name
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setName:
       memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 80):
      raise ApiError("""%s.setName:
       memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setName:
       memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.splitlines()) <= 1)):
      raise ApiError("""%s.setName:
       Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setName:
         cannot set name, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['name'] = value

    # doNotifies
  
  def setValue(self, value):
    """
    Set for ccpnmr.gui.Task.Parameter.value
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
        pass
      else:
        raise ApiError("""%s.setValue:
         memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('value')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setValue:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['value'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setValue, self.setValue,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""name of parameter - key for object
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  value = property(getValue, setValue, None,
  r"""Parameter value - can be of any of the several types supported by the 
  Multiple data type
  """)
  
  module = property(getModule,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for module
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.Parameter', Parameter)

###############################################################################
class PeakListView(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""
  """
  #   from data model element ccpnmr.gui.Task.PeakListView
  _metaclass = metaPackage.getElement('PeakListView')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'isSymbolDisplayed', 'isTextDisplayed', 'metaclass', 'packageName', 'packageShortName', 'peakListSerial', 'qualifiedName', 'symbolColour', 'symbolStyle', 'textColour', 'parent', 'peakList', 'peakViews', 'root', 'spectrumView', 'stripPeakListViews', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.PeakListView
    """
    dataDict = self.__dict__
    dataDict['spectrumView'] = parent
    if (not isinstance(parent, SpectrumView)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.SpectrumView""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['isSymbolDisplayed'] = True
      dataDict['isTextDisplayed'] = True
      dataDict['peakListSerial'] = None
      dataDict['symbolColour'] = '#7a7a7a'
      dataDict['symbolStyle'] = 'cross'
      dataDict['textColour'] = '#7a7a7a'
      dataDict['peakList'] = None
      dataDict['peakViews'] = {}
      dataDict['stripPeakListViews'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.PeakListView', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.PeakListView.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('peakListViews')
        objKey = dataDict.get('peakListSerial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['peakListSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      peakList = self.peakList
      if peakList:
        self.peakListSerial = peakList.serial
      else:
        dataSource = self.spectrumView.dataSource
        if dataSource is not None:
          dataDict['peakList'] = dataSource.findFirstPeakList(serial=self.peakListSerial)
      
      _undo = root._undo
      if _undo is not None:
        _undo.increaseBlocking()
      try:
        for stripSpectrumView in self.spectrumView.stripSpectrumViews:
          plv = stripSpectrumView.newStripPeakListView(peakListView=self)
          objectsCreated.add(plv)
      finally:
        if _undo is not None:
          _undo.decreaseBlocking()

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.PeakListView:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    peakList = dataDict.get('peakList')
    if (peakList is not None):
      topObject = peakList.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakViews = dataDict.get('peakViews').values()
    for peakView in peakViews:
      if (not (peakView in objsToBeDeleted)):
        objsToBeDeleted.add(peakView)
        objsToBeChecked.append(peakView)

    stripPeakListViews = dataDict.get('stripPeakListViews')
    for stripPeakListView in stripPeakListViews:
      if (not (stripPeakListView in objsToBeDeleted)):
        objsToBeDeleted.add(stripPeakListView)
        objsToBeChecked.append(stripPeakListView)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.PeakListView:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    peakList = dataDict.get('peakList')
    if ((peakList is not None and not (peakList in objsToBeDeleted))):
      peakListViews = peakList.__dict__.get('peakListViews')
      peakListViews.remove(self)

    spectrumView = dataDict.get('spectrumView')
    if (not (spectrumView in objsToBeDeleted)):
      objKey = dataDict.get('peakListSerial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = spectrumView.__dict__.get('peakListViews')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.PeakListView:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    spectrumView = dataDict.get('spectrumView')
    if (not (spectrumView in objsToBeUnDeleted)):

      childrenDict = spectrumView.__dict__.get('peakListViews')
      objKey = dataDict.get('peakListSerial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['peakListSerial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    peakList = dataDict.get('peakList')
    if ((peakList is not None and not (peakList in objsToBeUnDeleted))):
      peakListViews = peakList.__dict__.get('peakListViews')
      peakListViews.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.PeakListView
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('peakViews').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.PeakListView
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('peakListSerial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('spectrumView')
        dd = value.__dict__.get('peakListViews')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'spectrumView' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isSymbolDisplayed')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: isSymbolDisplayed:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('isTextDisplayed')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: isTextDisplayed:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('peakListSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: peakListSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('symbolColour')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: symbolColour:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: symbolColour:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: symbolColour:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: symbolColour:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('symbolStyle')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: symbolStyle:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: symbolStyle:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: symbolStyle:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: symbolStyle:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('textColour')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: textColour:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: textColour:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: textColour:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: textColour:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('peakList')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import PeakList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peakList:
           value is not of class ccp.nmr.Nmr.PeakList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('peakListViews')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: peakList:
           non-reciprocal link peakList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('peakViews').values()
      for value in values:
        if (not isinstance(value, PeakView)):
          raise ApiError("""%s.checkValid: peakViews:
           value is not of class ccpnmr.gui.Task.PeakView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('peakListView')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakViews:
           non-reciprocal link peakViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('spectrumView')
      if (not isinstance(value, SpectrumView)):
        raise ApiError("""%s.checkValid: spectrumView:
         value is not of class ccpnmr.gui.Task.SpectrumView""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('stripPeakListViews')
      for value in values:
        if (not isinstance(value, StripPeakListView)):
          raise ApiError("""%s.checkValid: stripPeakListViews:
           value is not of class ccpnmr.gui.Task.StripPeakListView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('peakListView')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripPeakListViews:
           non-reciprocal link stripPeakListViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('spectrumView')
        yy1 = value.__dict__.get('stripSpectrumView')
        yy2 = yy1.__dict__.get('spectrumView')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: stripPeakListViews:
           Link stripPeakListViews between objects from separate partitions
           - ccpnmr.gui.Task.StripSpectrumView.spectrumView not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('isSymbolDisplayed')
    if (value is None):
      raise ApiError("""%s.checkValid: isSymbolDisplayed:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('isTextDisplayed')
    if (value is None):
      raise ApiError("""%s.checkValid: isTextDisplayed:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('peakListSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: peakListSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('symbolColour')
    if (value is None):
      raise ApiError("""%s.checkValid: symbolColour:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('symbolStyle')
    if (value is None):
      raise ApiError("""%s.checkValid: symbolStyle:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('textColour')
    if (value is None):
      raise ApiError("""%s.checkValid: textColour:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('peakList')
    values = dataDict.get('peakViews').values()
    value = dataDict.get('spectrumView')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumView:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripPeakListViews')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllPeakViews(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.PeakListView.peakViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('peakViews').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('peakViews').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'peakSerial', 'peak', 'peakListView',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStripPeakListViews(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.PeakListView.stripPeakListViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripPeakListViews')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('stripPeakListViews')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'peakListView', 'stripSpectrumView',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstPeakView(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.PeakListView.peakViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('peakViews').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('peak')
      if (objKey is not None):
        result = dataDict.get('peakViews').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('peakViews').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'peakSerial', 'peak', 'peakListView',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStripPeakListView(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.PeakListView.stripPeakListViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripPeakListViews')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('stripPeakListViews')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'peakListView', 'stripSpectrumView',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.PeakListView
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.PeakListView
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (6 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.PeakListView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.PeakListView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        ll = list()
        objKey = fullKey[-3]
        ll.append(objKey)
        if (objKey is not None):
          objKey = fullKey[-2]
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        obj3 = obj2.__dict__.get('spectrumViews').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('peakListViews').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.PeakListView
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('spectrumView')
    obj2 = obj3.__dict__.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(obj3.__dict__.get('spectrumName'))
    result.append(obj3.__dict__.get('stripSerial'))
    result.append(dataDict.get('peakListSerial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getIsSymbolDisplayed(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.isSymbolDisplayed
    """
    dataDict = self.__dict__
    result = dataDict.get('isSymbolDisplayed')
    return result
  
  def getIsTextDisplayed(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.isTextDisplayed
    """
    dataDict = self.__dict__
    result = dataDict.get('isTextDisplayed')
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.PeakListView
    """
    dataDict = self.__dict__
    result = dataDict.get('peakListSerial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumView')
    return result
  
  def getPeakList(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.peakList
    """
    dataDict = self.__dict__
    result = dataDict.get('peakList')
    return result
  
  def getPeakListSerial(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.peakListSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('peakListSerial')
    return result
  
  def getPeakViews(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.peakViews
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('peakViews').values()
    result = frozenset(tempVar)
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSpectrumView(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.spectrumView
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumView')
    return result
  
  def getStripPeakListViews(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.stripPeakListViews
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('stripPeakListViews')
    result = frozenset(tempVar)
    return result
  
  def getSymbolColour(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.symbolColour
    """
    dataDict = self.__dict__
    result = dataDict.get('symbolColour')
    return result
  
  def getSymbolStyle(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.symbolStyle
    """
    dataDict = self.__dict__
    result = dataDict.get('symbolStyle')
    return result
  
  def getTextColour(self):
    """
    Get for ccpnmr.gui.Task.PeakListView.textColour
    """
    dataDict = self.__dict__
    result = dataDict.get('textColour')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newPeakView(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.PeakView
    """
    return PeakView(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.PeakListView
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setIsSymbolDisplayed(self, value):
    """
    Set for ccpnmr.gui.Task.PeakListView.isSymbolDisplayed
    """
    dataDict = self.__dict__
    if (not (value in [True, False])):
      raise ApiError("""%s.setIsSymbolDisplayed:
       memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isSymbolDisplayed')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsSymbolDisplayed:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsSymbolDisplayed:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setIsSymbolDisplayed:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['isSymbolDisplayed'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsSymbolDisplayed')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setIsSymbolDisplayed, self.setIsSymbolDisplayed,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setIsTextDisplayed(self, value):
    """
    Set for ccpnmr.gui.Task.PeakListView.isTextDisplayed
    """
    dataDict = self.__dict__
    if (not (value in [True, False])):
      raise ApiError("""%s.setIsTextDisplayed:
       memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isTextDisplayed')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsTextDisplayed:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsTextDisplayed:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setIsTextDisplayed:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['isTextDisplayed'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsTextDisplayed')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setIsTextDisplayed, self.setIsTextDisplayed,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPeakList(self, value):
    """
    Set for ccpnmr.gui.Task.PeakListView.peakList
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import PeakList as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setPeakList:
         value is not of class ccp.nmr.Nmr.PeakList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peakList')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakList:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPeakList:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeakList:
         cannot set peakList, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.setPeakList:
           Link peakList between objects from separate partitions
           - ccpnmr.gui.Task.GuiTask.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('peakListViews')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setPeakList:
         Read link 'peakList' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('peakListViews')
      newSelves.add(self)

    dataDict['peakList'] = value

    # doNotifies
  
  def setPeakListSerial(self, value):
    """
    Set for ccpnmr.gui.Task.PeakListView.peakListSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setPeakListSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peakListSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakListSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeakListSerial:
         cannot set peakListSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPeakListSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['peakListSerial'] = value

    # doNotifies
  
  def setStripPeakListViews(self, values):
    """
    Set for ccpnmr.gui.Task.PeakListView.stripPeakListViews
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setStripPeakListViews:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, StripPeakListView)):
        raise ApiError("""%s.setStripPeakListViews:
         value is not of class ccpnmr.gui.Task.StripPeakListView""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('stripPeakListViews')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStripPeakListViews:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStripPeakListViews:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setStripPeakListViews:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setStripPeakListViews:
           locard peakListView: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('spectrumView')
      for value in values:
        yy1 = value.__dict__.get('stripSpectrumView')
        yy2 = yy1.__dict__.get('spectrumView')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.setStripPeakListViews:
           Link stripPeakListViews between objects from separate partitions
           - ccpnmr.gui.Task.StripSpectrumView.spectrumView not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['peakListView'] = self

    dataDict['stripPeakListViews'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStripPeakListViews')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setStripPeakListViews, self.setStripPeakListViews,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setSymbolColour(self, value):
    """
    Set for ccpnmr.gui.Task.PeakListView.symbolColour
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSymbolColour:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setSymbolColour:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setSymbolColour:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setSymbolColour:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('symbolColour')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSymbolColour:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSymbolColour:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setSymbolColour:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['symbolColour'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSymbolColour')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSymbolColour, self.setSymbolColour,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSymbolStyle(self, value):
    """
    Set for ccpnmr.gui.Task.PeakListView.symbolStyle
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSymbolStyle:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setSymbolStyle:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setSymbolStyle:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setSymbolStyle:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('symbolStyle')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSymbolStyle:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSymbolStyle:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setSymbolStyle:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['symbolStyle'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSymbolStyle')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSymbolStyle, self.setSymbolStyle,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setTextColour(self, value):
    """
    Set for ccpnmr.gui.Task.PeakListView.textColour
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setTextColour:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setTextColour:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setTextColour:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setTextColour:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('textColour')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTextColour:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTextColour:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setTextColour:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['textColour'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTextColour')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTextColour, self.setTextColour,
                      undoArgs=(currentValue,), redoArgs=(value,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedPeakViews(self):
    """
    Sorted for ccpnmr.gui.Task.PeakListView.peakViews
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('peakViews')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedStripPeakListViews(self):
    """
    Sorted for ccpnmr.gui.Task.PeakListView.stripPeakListViews
    """
    dataDict = self.__dict__
    ll = dataDict.get('stripPeakListViews')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  isSymbolDisplayed = property(getIsSymbolDisplayed, setIsSymbolDisplayed, None,
  r"""Is symbol displayed 
  """)
  
  isTextDisplayed = property(getIsTextDisplayed, setIsTextDisplayed, None,
  r"""Is text annotation displayed 
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  peakListSerial = property(getPeakListSerial, setPeakListSerial, None,
  r"""Serial of attached peakList - key attribute
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  symbolColour = property(getSymbolColour, setSymbolColour, None,
  r"""Peak marker symbol colour string - only set if you want ot override the 
  PeakList settings
  """)
  
  symbolStyle = property(getSymbolStyle, setSymbolStyle, None,
  r"""Peak marker symbol style identifier - only set if you want to override 
  the PeakList settings
  """)
  
  textColour = property(getTextColour, setTextColour, None,
  r"""text colour - only set if you want to override the PeakList settings
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for spectrumView
  """)
  
  peakList = property(getPeakList, setPeakList, None,
  r"""PeakList that PeakListView pertains to
  """)
  
  peakViews = property(getPeakViews,  None, None,
  r"""child link to class PeakView
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  spectrumView = property(getSpectrumView,  None, None,
  r"""parent link
  """)
  
  stripPeakListViews = property(getStripPeakListViews, setStripPeakListViews, None,
  r"""StripPeakListViews connecting PeakListView to Strips
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.PeakListView', PeakListView)

###############################################################################
class PeakView(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""
  """
  #   from data model element ccpnmr.gui.Task.PeakView
  _metaclass = metaPackage.getElement('PeakView')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'peakSerial', 'qualifiedName', 'textOffset', 'parent', 'peak', 'peakListView', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.PeakView
    """
    dataDict = self.__dict__
    dataDict['peakListView'] = parent
    if (not isinstance(parent, PeakListView)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.PeakListView""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['peakSerial'] = None
      dataDict['textOffset'] = [0.0, 0.0]
      dataDict['peak'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.PeakView', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.PeakView.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('peakViews')
        objKey = dataDict.get('peak')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['peak'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.PeakView:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    peak = dataDict.get('peak')
    if (peak is not None):
      topObject = peak.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.PeakView:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    peak = dataDict.get('peak')
    if ((peak is not None and not (peak in objsToBeDeleted))):
      peakViews = peak.__dict__.get('peakViews')
      peakViews.remove(self)

    peakListView = dataDict.get('peakListView')
    if (not (peakListView in objsToBeDeleted)):
      objKey = dataDict.get('peak')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = peakListView.__dict__.get('peakViews')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.PeakView:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    peakListView = dataDict.get('peakListView')
    if (not (peakListView in objsToBeUnDeleted)):

      childrenDict = peakListView.__dict__.get('peakViews')
      objKey = dataDict.get('peak')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['peak'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    peak = dataDict.get('peak')
    if ((peak is not None and not (peak in objsToBeUnDeleted))):
      peakViews = peak.__dict__.get('peakViews')
      peakViews.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.PeakView
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.PeakView
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('peak')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('peakListView')
        dd = value.__dict__.get('peakViews')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'peakListView' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('peakSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: peakSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('textOffset')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: textOffset:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: textOffset:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      value = dataDict.get('peak')
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: peak:
         value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('peakViews')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: peak:
         non-reciprocal link peak from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('peakListView')
      if (not isinstance(value, PeakListView)):
        raise ApiError("""%s.checkValid: peakListView:
         value is not of class ccpnmr.gui.Task.PeakListView""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('peakSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: peakSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('textOffset')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: textOffset:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('peak')
    if (value is None):
      raise ApiError("""%s.checkValid: peak:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('peakListView')
    if (value is None):
      raise ApiError("""%s.checkValid: peakListView:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.PeakView
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.PeakView
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (7 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.PeakView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.PeakView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-5]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        ll = list()
        objKey = fullKey[-4]
        ll.append(objKey)
        if (objKey is not None):
          objKey = fullKey[-3]
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        obj3 = obj2.__dict__.get('spectrumViews').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-2]
          obj4 = obj3.__dict__.get('peakListViews').get(objKey)

          if (obj4 is not None):
            objKey = fullKey[-1]
            obj5 = obj4.__dict__.get('peakViews').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.PeakView
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('peakListView')
    obj3 = obj4.__dict__.get('spectrumView')
    obj2 = obj3.__dict__.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(obj3.__dict__.get('spectrumName'))
    result.append(obj3.__dict__.get('stripSerial'))
    result.append(obj4.__dict__.get('peakListSerial'))
    result.append(dataDict.get('peak'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.PeakView
    """
    dataDict = self.__dict__
    result = dataDict.get('peak')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.PeakView.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('peakListView')
    return result
  
  def getPeak(self):
    """
    Get for ccpnmr.gui.Task.PeakView.peak
    """
    dataDict = self.__dict__
    result = dataDict.get('peak')
    return result
  
  def getPeakListView(self):
    """
    Get for ccpnmr.gui.Task.PeakView.peakListView
    """
    dataDict = self.__dict__
    result = dataDict.get('peakListView')
    return result
  
  def getPeakSerial(self):
    """
    Get for ccpnmr.gui.Task.PeakView.peakSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('peakSerial')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getTextOffset(self):
    """
    Get for ccpnmr.gui.Task.PeakView.textOffset
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('textOffset')
    result = tuple(tempVar)
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.PeakView
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setPeak(self, value):
    """
    Set for ccpnmr.gui.Task.PeakView.peak
    """
    dataDict = self.__dict__
    from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Peak as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.setPeak:
       value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peak')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeak:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPeak:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeak:
         cannot set peak, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPeak:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      xx2 = xx1.__dict__.get('nmrProject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx2 is yy1)):
        raise ApiError("""%s.setPeak:
         Link peak between objects from separate partitions
         - ccpnmr.gui.Task.GuiTask.nmrProject not set correctly""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('peakViews')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setPeak:
         Read link 'peak' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('peakViews')
      newSelves.add(self)

    dataDict['peak'] = value

    # doNotifies
  
  def setPeakSerial(self, value):
    """
    Set for ccpnmr.gui.Task.PeakView.peakSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setPeakSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peakSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeakSerial:
         cannot set peakSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPeakSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['peakSerial'] = value

    # doNotifies
  
  def setTextOffset(self, values):
    """
    Set for ccpnmr.gui.Task.PeakView.textOffset
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        replaceIndex = values.index(value)
        values[replaceIndex] = castValue
        value = castValue
      else:
        raise ApiError("""%s.setTextOffset:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setTextOffset:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('textOffset')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTextOffset:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTextOffset:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (not (len(values) == 2)):
        raise ApiError("""%s.setTextOffset:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['textOffset'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTextOffset')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setTextOffset, self.setTextOffset,
                      undoArgs=(currentValues,), redoArgs=(values,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  peakSerial = property(getPeakSerial, setPeakSerial, None,
  r"""serial for connected peak - key attribute
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  textOffset = property(getTextOffset, setTextOffset, None,
  r"""Text annotation offset. NBNB we need to decide which unit to use.
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for peakListView
  """)
  
  peak = property(getPeak, setPeak, None,
  r"""Peak that PeakView pertains to
  """)
  
  peakListView = property(getPeakListView,  None, None,
  r"""parent link
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.PeakView', PeakView)

###############################################################################
class Ruler(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Single line with position, axisCode, and unit, displayed across all 
matching axes in all display modules
  """
  #   from data model element ccpnmr.gui.Task.Ruler
  _metaclass = metaPackage.getElement('Ruler')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'axisCode', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'label', 'metaclass', 'packageName', 'packageShortName', 'position', 'qualifiedName', 'serial', 'unit', 'mark', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.Ruler
    """
    dataDict = self.__dict__
    dataDict['mark'] = parent
    if (not isinstance(parent, Mark)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.Mark""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['axisCode'] = None
      dataDict['ccpnInternalData'] = None
      dataDict['label'] = None
      dataDict['position'] = None
      dataDict['serial'] = None
      dataDict['unit'] = 'ppm'

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.Ruler', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.Ruler.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccpnmr.gui.Task.Ruler')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('rulers')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.Ruler:
       determines cascading deletes 
    to follow from delete of object.
       *Implementation function* - should 
    be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.Ruler:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    mark = dataDict.get('mark')
    if (not (mark in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = mark.__dict__.get('rulers')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.Ruler:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    mark = dataDict.get('mark')
    if (not (mark in objsToBeUnDeleted)):

      childrenDict = mark.__dict__.get('rulers')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.Ruler
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.Ruler
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('mark')
        dd = value.__dict__.get('rulers')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'mark' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('axisCode')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: axisCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: axisCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: axisCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: axisCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('label')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: label:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: label:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: label:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: label:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('position')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: position:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: position:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: unit:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('mark')
      if (not isinstance(value, Mark)):
        raise ApiError("""%s.checkValid: mark:
         value is not of class ccpnmr.gui.Task.Mark""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('axisCode')
    if (value is None):
      raise ApiError("""%s.checkValid: axisCode:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('label')
    value = dataDict.get('position')
    if (value is None):
      raise ApiError("""%s.checkValid: position:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    if (value is None):
      raise ApiError("""%s.checkValid: unit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('mark')
    if (value is None):
      raise ApiError("""%s.checkValid: mark:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.Ruler
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxisCode(self):
    """
    Get for ccpnmr.gui.Task.Ruler.axisCode
    """
    dataDict = self.__dict__
    result = dataDict.get('axisCode')
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.Ruler
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Ruler'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Ruler'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('marks').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('rulers').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.Ruler
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('mark')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLabel(self):
    """
    Get for ccpnmr.gui.Task.Ruler.label
    """
    dataDict = self.__dict__
    result = dataDict.get('label')
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.Ruler
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getMark(self):
    """
    Get for ccpnmr.gui.Task.Ruler.mark
    """
    dataDict = self.__dict__
    result = dataDict.get('mark')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.Ruler.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('mark')
    return result
  
  def getPosition(self):
    """
    Get for ccpnmr.gui.Task.Ruler.position
    """
    dataDict = self.__dict__
    result = dataDict.get('position')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccpnmr.gui.Task.Ruler.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnit(self):
    """
    Get for ccpnmr.gui.Task.Ruler.unit
    """
    dataDict = self.__dict__
    result = dataDict.get('unit')
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.Ruler
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxisCode(self, value):
    """
    Set for ccpnmr.gui.Task.Ruler.axisCode
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setAxisCode:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setAxisCode:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setAxisCode:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setAxisCode:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('axisCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setAxisCode:
         cannot set axisCode, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setAxisCode:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['axisCode'] = value

    # doNotifies

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setLabel(self, value):
    """
    Set for ccpnmr.gui.Task.Ruler.label
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setLabel:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setLabel:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setLabel:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setLabel:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('label')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setLabel:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setLabel:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['label'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setLabel')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setLabel, self.setLabel,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPosition(self, value):
    """
    Set for ccpnmr.gui.Task.Ruler.position
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setPosition:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setPosition:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('position')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPosition:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPosition:
         cannot set position, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPosition:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['position'] = value

    # doNotifies
  
  def setSerial(self, value):
    """
    Set for ccpnmr.gui.Task.Ruler.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('mark')
    oldSerial = parent.__dict__.get('_serialDict').get('rulers')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['rulers'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['rulers'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setUnit(self, value):
    """
    Set for ccpnmr.gui.Task.Ruler.unit
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('unit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setUnit:
         cannot set unit, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setUnit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['unit'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData
  
  axisCode = property(getAxisCode, setAxisCode, None,
  r"""Axis code for ruler - deternines which axes hte ruler is displayed on
  """)

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  label = property(getLabel, setLabel, None,
  r"""Text label to be displayed alongside ruler.
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  position = property(getPosition, setPosition, None,
  r"""Ruler position
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  unit = property(getUnit, setUnit, None,
  r"""Unit of position - defaults to ppm
  """)
  
  mark = property(getMark,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for mark
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.Ruler', Ruler)

###############################################################################
class SpectrumView(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""View of spectrum in DisplayModule, holding module-specific spectrum 
display parameters. May be attached to a specific strip (if stripSerial 
> 0) or to all strips (stripSerial == 0). Either a dataSource or an 
experimentName and dataSourceSerial can be passed in at object creation.
  """
  #   from data model element ccpnmr.gui.Task.SpectrumView
  _metaclass = metaPackage.getElement('SpectrumView')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'dimensionOrdering', 'displayNegativeContours', 'displayPositiveContours', 'experimentType', 'fieldNames', 'inConstructor', 'isDeleted', 'isDisplayed', 'metaclass', 'negativeContourBase', 'negativeContourColour', 'negativeContourCount', 'negativeContourFactor', 'packageName', 'packageShortName', 'positiveContourBase', 'positiveContourColour', 'positiveContourCount', 'positiveContourFactor', 'qualifiedName', 'sliceColour', 'spectrumName', 'stripSerial', 'dataSource', 'orderedDataDims', 'parent', 'peakListViews', 'root', 'spectrumDisplay', 'stripSpectrumViews', 'strips', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.SpectrumView
    """
    dataDict = self.__dict__
    dataDict['spectrumDisplay'] = parent
    if (not isinstance(parent, SpectrumDisplay)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['dimensionOrdering'] = list()
      dataDict['displayNegativeContours'] = True
      dataDict['displayPositiveContours'] = True
      dataDict['experimentType'] = None
      dataDict['isDisplayed'] = True
      dataDict['negativeContourBase'] = None
      dataDict['negativeContourColour'] = None
      dataDict['negativeContourCount'] = None
      dataDict['negativeContourFactor'] = None
      dataDict['positiveContourBase'] = None
      dataDict['positiveContourColour'] = None
      dataDict['positiveContourCount'] = None
      dataDict['positiveContourFactor'] = None
      dataDict['sliceColour'] = None
      dataDict['spectrumName'] = None
      dataDict['stripSerial'] = 0
      dataDict['dataSource'] = None
      dataDict['peakListViews'] = {}
      dataDict['stripSpectrumViews'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.SpectrumView', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.SpectrumView.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('spectrumViews')
        ll = list()
        objKey = dataDict.get('spectrumName')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('stripSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['spectrumName', 'stripSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      dataSource = self.dataSource
      if dataSource is None:
        nmrProject = self.topObject.nmrProject
        if nmrProject is not None:
          for experiment in nmrProject.sortedExperiments():
            dataSources = experiment.findAllDataSources(name=self.spectrumName)
            if dataSources:
              dataDict['dataSource'] = list(dataSources)[0]
              break
      
      _undo = root._undo
      if _undo is not None:
        _undo.increaseBlocking()
      try:
        stripSerial = self.stripSerial
        if stripSerial:
          strip = self.spectrumDisplay.findFirstStrip(serial=stripSerial)
          if strip is None:
            raise ValueError("%s has no Strip with serial %s" % (self.spectrumDisplay, stripSerial))
          else:
            ssv = strip.newStripSpectrumView(spectrumView=self)
            objectsCreated.add(ssv)
        else:
          for strip in self.spectrumDisplay.sortedStrips():
            ssv = strip.newStripSpectrumView(spectrumView=self)
            objectsCreated.add(ssv)
      finally:
        if _undo is not None:
          _undo.decreaseBlocking()

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.SpectrumView:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    dataSource = dataDict.get('dataSource')
    if (dataSource is not None):
      topObject = dataSource.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakListViews = dataDict.get('peakListViews').values()
    for peakListView in peakListViews:
      if (not (peakListView in objsToBeDeleted)):
        objsToBeDeleted.add(peakListView)
        objsToBeChecked.append(peakListView)

    stripSpectrumViews = dataDict.get('stripSpectrumViews')
    for stripSpectrumView in stripSpectrumViews:
      if (not (stripSpectrumView in objsToBeDeleted)):
        objsToBeDeleted.add(stripSpectrumView)
        objsToBeChecked.append(stripSpectrumView)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.SpectrumView:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    dataSource = dataDict.get('dataSource')
    if ((dataSource is not None and not (dataSource in objsToBeDeleted))):
      spectrumViews = dataSource.__dict__.get('spectrumViews')
      spectrumViews.remove(self)

    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeDeleted)):
      ll = list()
      objKey = dataDict.get('spectrumName')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = spectrumDisplay.__dict__.get('spectrumViews')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.SpectrumView:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeUnDeleted)):

      childrenDict = spectrumDisplay.__dict__.get('spectrumViews')
      ll = list()
      objKey = dataDict.get('spectrumName')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['spectrumName', 'stripSerial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    dataSource = dataDict.get('dataSource')
    if ((dataSource is not None and not (dataSource in objsToBeUnDeleted))):
      spectrumViews = dataSource.__dict__.get('spectrumViews')
      spectrumViews.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.SpectrumView
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('peakListViews').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.SpectrumView
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      ll = list()
      objKey = dataDict.get('spectrumName')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('spectrumDisplay')
        dd = value.__dict__.get('spectrumViews')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'spectrumDisplay' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('dimensionOrdering')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: dimensionOrdering:
           memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value >= 0)):
          raise ApiError("""%s.checkValid: dimensionOrdering:
           NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('displayNegativeContours')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: displayNegativeContours:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('displayPositiveContours')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: displayPositiveContours:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('experimentType')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: experimentType:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: experimentType:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: experimentType:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: experimentType:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isDisplayed')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: isDisplayed:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('negativeContourBase')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: negativeContourBase:
           memops.Implementation.NegativeFloat input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: negativeContourBase:
           NegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value < 0)):
          raise ApiError("""%s.checkValid: negativeContourBase:
           NegativeFloat constraint value_lt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('negativeContourColour')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: negativeContourColour:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: negativeContourColour:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: negativeContourColour:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: negativeContourColour:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('negativeContourCount')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: negativeContourCount:
           memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value >= 0)):
          raise ApiError("""%s.checkValid: negativeContourCount:
           NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('negativeContourFactor')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: negativeContourFactor:
           memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: negativeContourFactor:
           PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: negativeContourFactor:
           PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('positiveContourBase')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: positiveContourBase:
           memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: positiveContourBase:
           PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: positiveContourBase:
           PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('positiveContourColour')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: positiveContourColour:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: positiveContourColour:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: positiveContourColour:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: positiveContourColour:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('positiveContourCount')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: positiveContourCount:
           memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value >= 0)):
          raise ApiError("""%s.checkValid: positiveContourCount:
           NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('positiveContourFactor')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: positiveContourFactor:
           memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: positiveContourFactor:
           PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: positiveContourFactor:
           PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('sliceColour')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: sliceColour:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: sliceColour:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: sliceColour:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: sliceColour:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('spectrumName')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: spectrumName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: spectrumName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: spectrumName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: spectrumName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('stripSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('dataSource')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import DataSource as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: dataSource:
           value is not of class ccp.nmr.Nmr.DataSource""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('spectrumViews')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: dataSource:
           non-reciprocal link dataSource from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getOrderedDataDims()
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import AbstractDataDim as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: orderedDataDims:
           value is not of class ccp.nmr.Nmr.AbstractDataDim""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: orderedDataDims:
           Link orderedDataDims between objects from separate partitions
           - ccpnmr.gui.Task.GuiTask.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('peakListViews').values()
      for value in values:
        if (not isinstance(value, PeakListView)):
          raise ApiError("""%s.checkValid: peakListViews:
           value is not of class ccpnmr.gui.Task.PeakListView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('spectrumView')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakListViews:
           non-reciprocal link peakListViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('spectrumDisplay')
      if (not isinstance(value, SpectrumDisplay)):
        raise ApiError("""%s.checkValid: spectrumDisplay:
         value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('stripSpectrumViews')
      for value in values:
        if (not isinstance(value, StripSpectrumView)):
          raise ApiError("""%s.checkValid: stripSpectrumViews:
           value is not of class ccpnmr.gui.Task.StripSpectrumView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('spectrumView')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripSpectrumViews:
           non-reciprocal link stripSpectrumViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: stripSpectrumViews:
           Link stripSpectrumViews between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getStrips()
      for value in values:
        if (not isinstance(value, Strip)):
          raise ApiError("""%s.checkValid: strips:
           value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getSpectrumViews()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: strips:
           non-reciprocal link strips from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('dimensionOrdering')
    if (len(values) < 2):
      raise ApiError("""%s.checkValid: dimensionOrdering:
       locard: values must be of length >= 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('displayNegativeContours')
    if (value is None):
      raise ApiError("""%s.checkValid: displayNegativeContours:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('displayPositiveContours')
    if (value is None):
      raise ApiError("""%s.checkValid: displayPositiveContours:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('experimentType')
    value = dataDict.get('isDisplayed')
    if (value is None):
      raise ApiError("""%s.checkValid: isDisplayed:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('negativeContourBase')
    value = dataDict.get('negativeContourColour')
    value = dataDict.get('negativeContourCount')
    value = dataDict.get('negativeContourFactor')
    value = dataDict.get('positiveContourBase')
    value = dataDict.get('positiveContourColour')
    value = dataDict.get('positiveContourCount')
    value = dataDict.get('positiveContourFactor')
    value = dataDict.get('sliceColour')
    value = dataDict.get('spectrumName')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumName:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('stripSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: stripSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not ((value == 0) == (self.spectrumDisplay.stripType != 'Free'))):
      raise ApiError("""%s.checkValid: stripSerial:
       stripSerial constraint only_free_strip_displays_have_individual_spectrum_views violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    # check roles
    value = dataDict.get('dataSource')
    values = dataDict.get('peakListViews').values()
    value = dataDict.get('spectrumDisplay')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumDisplay:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripSpectrumViews')

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllOrderedDataDims(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumView.orderedDataDims
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedDataDims()
      result = list(currentValues)

    else:
      currentValues = self.getOrderedDataDims()
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'dim', 'fileDim', 'gaussianBroadening', 'isComplex', 'lorentzianBroadening', 'numPoints', 'shapeSerial', 'sineWindowShift', 'unit', 'windowFunction', 'dataSource', 'expDim', 'predictMethod',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result
  
  def findAllPeakListViews(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumView.peakListViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('peakListViews').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('peakListViews').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'isSymbolDisplayed', 'isTextDisplayed', 'peakListSerial', 'symbolColour', 'symbolStyle', 'textColour', 'peakList', 'spectrumView',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStripSpectrumViews(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumView.stripSpectrumViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripSpectrumViews')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('stripSpectrumViews')
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'spectrumView', 'strip',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStrips(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumView.strips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getStrips()
      result = set(currentValues)

    else:
      currentValues = self.getStrips()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstOrderedDataDim(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumView.orderedDataDims
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedDataDims()
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = self.getOrderedDataDims()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'dim', 'fileDim', 'gaussianBroadening', 'isComplex', 'lorentzianBroadening', 'numPoints', 'shapeSerial', 'sineWindowShift', 'unit', 'windowFunction', 'dataSource', 'expDim', 'predictMethod',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstPeakListView(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumView.peakListViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('peakListViews').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('peakListSerial')
      if (objKey is not None):
        result = dataDict.get('peakListViews').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('peakListViews').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'isSymbolDisplayed', 'isTextDisplayed', 'peakListSerial', 'symbolColour', 'symbolStyle', 'textColour', 'peakList', 'spectrumView',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStrip(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumView.strips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getStrips()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = self.getStrips()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStripSpectrumView(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumView.stripSpectrumViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripSpectrumViews')
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = dataDict.get('stripSpectrumViews')
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'spectrumView', 'strip',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.SpectrumView
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.SpectrumView
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.SpectrumView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.SpectrumView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        ll = list()
        objKey = fullKey[-2]
        ll.append(objKey)
        if (objKey is not None):
          objKey = fullKey[-1]
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        obj3 = obj2.__dict__.get('spectrumViews').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getDataSource(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.dataSource
    """
    dataDict = self.__dict__
    result = dataDict.get('dataSource')
    return result
  
  def getDimensionOrdering(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.dimensionOrdering
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('dimensionOrdering')
    result = tuple(tempVar)
    return result
  
  def getDisplayNegativeContours(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.displayNegativeContours
    """
    dataDict = self.__dict__
    result = dataDict.get('displayNegativeContours')
    return result
  
  def getDisplayPositiveContours(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.displayPositiveContours
    """
    dataDict = self.__dict__
    result = dataDict.get('displayPositiveContours')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey
  
  def getExperimentType(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.experimentType
    """
    dataDict = self.__dict__
    result = dataDict.get('experimentType')
    return result

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.SpectrumView
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(dataDict.get('spectrumName'))
    result.append(dataDict.get('stripSerial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getIsDisplayed(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.isDisplayed
    """
    dataDict = self.__dict__
    result = dataDict.get('isDisplayed')
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.SpectrumView
    """
    dataDict = self.__dict__
    ll = list()
    result = dataDict.get('spectrumName')
    ll.append(result)
    if (result is not None):
      result = dataDict.get('stripSerial')
      ll.append(result)
      if (result is not None):
        result = tuple(ll)

    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getNegativeContourBase(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.negativeContourBase
    """
    dataDict = self.__dict__
    result = dataDict.get('negativeContourBase')
    return result
  
  def getNegativeContourColour(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.negativeContourColour
    """
    dataDict = self.__dict__
    result = dataDict.get('negativeContourColour')
    return result
  
  def getNegativeContourCount(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.negativeContourCount
    """
    dataDict = self.__dict__
    result = dataDict.get('negativeContourCount')
    return result
  
  def getNegativeContourFactor(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.negativeContourFactor
    """
    dataDict = self.__dict__
    result = dataDict.get('negativeContourFactor')
    return result
  
  def getOrderedDataDims(self):
    """
    getter for derived link orderedDataDims. NB return value may contain
    None.
    """
    dataDict = self.__dict__
    serial = self.stripSerial
    sourceObj = self.spectrumDisplay
    if serial:
      sourceObj = sourceObj.findFirstStrip(serial=serial)
      if sourceObj is None:
        raise ValueError("SpectrumView %s for non-existent strip" % self)
    axisCodes = sourceObj.axisCodes
    dimensionOrdering = self.dimensionOrdering
    ff = self.dataSource.findFirstDataDim
    result =tuple(ff(dim=dimensionOrdering[axisCodes.index(x)]) for x in sourceObj.axisOrder)
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumDisplay')
    return result
  
  def getPeakListViews(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.peakListViews
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('peakListViews').values()
    result = frozenset(tempVar)
    return result
  
  def getPositiveContourBase(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.positiveContourBase
    """
    dataDict = self.__dict__
    result = dataDict.get('positiveContourBase')
    return result
  
  def getPositiveContourColour(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.positiveContourColour
    """
    dataDict = self.__dict__
    result = dataDict.get('positiveContourColour')
    return result
  
  def getPositiveContourCount(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.positiveContourCount
    """
    dataDict = self.__dict__
    result = dataDict.get('positiveContourCount')
    return result
  
  def getPositiveContourFactor(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.positiveContourFactor
    """
    dataDict = self.__dict__
    result = dataDict.get('positiveContourFactor')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSliceColour(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.sliceColour
    """
    dataDict = self.__dict__
    result = dataDict.get('sliceColour')
    return result
  
  def getSpectrumDisplay(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.spectrumDisplay
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumDisplay')
    return result
  
  def getSpectrumName(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.spectrumName
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumName')
    return result
  
  def getStripSerial(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.stripSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('stripSerial')
    return result
  
  def getStripSpectrumViews(self):
    """
    Get for ccpnmr.gui.Task.SpectrumView.stripSpectrumViews
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('stripSpectrumViews')
    result = frozenset(tempVar)
    return result
  
  def getStrips(self):
    """
    getter for derived link strips
    """
    dataDict = self.__dict__
    if self.stripSerial:
      result = (self.findFirstStripSpectrumView().strip,)
    else:
      result = self.spectrumDisplay.orderedStrips
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newPeakListView(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.PeakListView
    """
    return PeakListView(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.SpectrumView
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setDataSource(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.dataSource
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import DataSource as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setDataSource:
         value is not of class ccp.nmr.Nmr.DataSource""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('dataSource')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDataSource:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setDataSource:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setDataSource:
         cannot set dataSource, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.setDataSource:
           Link dataSource between objects from separate partitions
           - ccpnmr.gui.Task.GuiTask.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('spectrumViews')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setDataSource:
         Read link 'dataSource' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('spectrumViews')
      newSelves.add(self)

    dataDict['dataSource'] = value

    # doNotifies
  
  def setDimensionOrdering(self, values):
    """
    Set for ccpnmr.gui.Task.SpectrumView.dimensionOrdering
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDimensionOrdering:
         memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value >= 0)):
        raise ApiError("""%s.setDimensionOrdering:
         NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('dimensionOrdering')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDimensionOrdering:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setDimensionOrdering:
         cannot set dimensionOrdering, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (len(values) < 2):
        raise ApiError("""%s.setDimensionOrdering:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['dimensionOrdering'] = values

    # doNotifies
  
  def setDisplayNegativeContours(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.displayNegativeContours
    """
    dataDict = self.__dict__
    if (not (value in [True, False])):
      raise ApiError("""%s.setDisplayNegativeContours:
       memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('displayNegativeContours')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDisplayNegativeContours:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDisplayNegativeContours:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setDisplayNegativeContours:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['displayNegativeContours'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDisplayNegativeContours')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDisplayNegativeContours, self.setDisplayNegativeContours,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setDisplayPositiveContours(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.displayPositiveContours
    """
    dataDict = self.__dict__
    if (not (value in [True, False])):
      raise ApiError("""%s.setDisplayPositiveContours:
       memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('displayPositiveContours')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDisplayPositiveContours:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDisplayPositiveContours:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setDisplayPositiveContours:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['displayPositiveContours'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDisplayPositiveContours')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setDisplayPositiveContours, self.setDisplayPositiveContours,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setExperimentType(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.experimentType
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setExperimentType:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setExperimentType:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setExperimentType:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setExperimentType:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('experimentType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setExperimentType:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setExperimentType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['experimentType'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setExperimentType')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setExperimentType, self.setExperimentType,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setIsDisplayed(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.isDisplayed
    """
    dataDict = self.__dict__
    if (not (value in [True, False])):
      raise ApiError("""%s.setIsDisplayed:
       memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isDisplayed')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsDisplayed:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsDisplayed:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setIsDisplayed:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['isDisplayed'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsDisplayed')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setIsDisplayed, self.setIsDisplayed,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setNegativeContourBase(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.negativeContourBase
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setNegativeContourBase:
         memops.Implementation.NegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setNegativeContourBase:
         NegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value < 0)):
        raise ApiError("""%s.setNegativeContourBase:
         NegativeFloat constraint value_lt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('negativeContourBase')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNegativeContourBase:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNegativeContourBase:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['negativeContourBase'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNegativeContourBase')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNegativeContourBase, self.setNegativeContourBase,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setNegativeContourColour(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.negativeContourColour
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setNegativeContourColour:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setNegativeContourColour:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setNegativeContourColour:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setNegativeContourColour:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('negativeContourColour')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNegativeContourColour:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNegativeContourColour:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['negativeContourColour'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNegativeContourColour')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNegativeContourColour, self.setNegativeContourColour,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setNegativeContourCount(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.negativeContourCount
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setNegativeContourCount:
         memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value >= 0)):
        raise ApiError("""%s.setNegativeContourCount:
         NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('negativeContourCount')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNegativeContourCount:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNegativeContourCount:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['negativeContourCount'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNegativeContourCount')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNegativeContourCount, self.setNegativeContourCount,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setNegativeContourFactor(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.negativeContourFactor
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setNegativeContourFactor:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setNegativeContourFactor:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setNegativeContourFactor:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('negativeContourFactor')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNegativeContourFactor:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNegativeContourFactor:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['negativeContourFactor'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNegativeContourFactor')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setNegativeContourFactor, self.setNegativeContourFactor,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPositiveContourBase(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.positiveContourBase
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setPositiveContourBase:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setPositiveContourBase:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setPositiveContourBase:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('positiveContourBase')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPositiveContourBase:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPositiveContourBase:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['positiveContourBase'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPositiveContourBase')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositiveContourBase, self.setPositiveContourBase,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPositiveContourColour(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.positiveContourColour
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setPositiveContourColour:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setPositiveContourColour:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setPositiveContourColour:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setPositiveContourColour:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('positiveContourColour')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPositiveContourColour:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPositiveContourColour:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['positiveContourColour'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPositiveContourColour')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositiveContourColour, self.setPositiveContourColour,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPositiveContourCount(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.positiveContourCount
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setPositiveContourCount:
         memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value >= 0)):
        raise ApiError("""%s.setPositiveContourCount:
         NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('positiveContourCount')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPositiveContourCount:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPositiveContourCount:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['positiveContourCount'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPositiveContourCount')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositiveContourCount, self.setPositiveContourCount,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setPositiveContourFactor(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.positiveContourFactor
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setPositiveContourFactor:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setPositiveContourFactor:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setPositiveContourFactor:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('positiveContourFactor')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPositiveContourFactor:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPositiveContourFactor:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['positiveContourFactor'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPositiveContourFactor')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositiveContourFactor, self.setPositiveContourFactor,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSliceColour(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.sliceColour
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setSliceColour:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setSliceColour:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setSliceColour:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setSliceColour:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('sliceColour')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setSliceColour:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSliceColour:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['sliceColour'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setSliceColour')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setSliceColour, self.setSliceColour,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setSpectrumName(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.spectrumName
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSpectrumName:
       memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 80):
      raise ApiError("""%s.setSpectrumName:
       memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setSpectrumName:
       memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.splitlines()) <= 1)):
      raise ApiError("""%s.setSpectrumName:
       Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('spectrumName')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSpectrumName:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSpectrumName:
         cannot set spectrumName, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSpectrumName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['spectrumName'] = value

    # doNotifies
  
  def setStripSerial(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumView.stripSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setStripSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('stripSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStripSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setStripSerial:
         cannot set stripSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setStripSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          if (not ((value == 0) == (self.spectrumDisplay.stripType != 'Free'))):
            raise ApiError("""%s.setStripSerial:
             stripSerial constraint only_free_strip_displays_have_individual_spectrum_views violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['stripSerial'] = value

    # doNotifies
  
  def setStripSpectrumViews(self, values):
    """
    Set for ccpnmr.gui.Task.SpectrumView.stripSpectrumViews
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setStripSpectrumViews:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, StripSpectrumView)):
        raise ApiError("""%s.setStripSpectrumViews:
         value is not of class ccpnmr.gui.Task.StripSpectrumView""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('stripSpectrumViews')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStripSpectrumViews:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStripSpectrumViews:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setStripSpectrumViews:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setStripSpectrumViews:
           locard spectrumView: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setStripSpectrumViews:
           Link stripSpectrumViews between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['spectrumView'] = self

    dataDict['stripSpectrumViews'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStripSpectrumViews')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setStripSpectrumViews, self.setStripSpectrumViews,
                      undoArgs=(currentValues,), redoArgs=(values,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedPeakListViews(self):
    """
    Sorted for ccpnmr.gui.Task.SpectrumView.peakListViews
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('peakListViews')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedStripSpectrumViews(self):
    """
    Sorted for ccpnmr.gui.Task.SpectrumView.stripSpectrumViews
    """
    dataDict = self.__dict__
    ll = dataDict.get('stripSpectrumViews')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedStrips(self):
    """
    Sorted for ccpnmr.gui.Task.SpectrumView.strips
    """
    dataDict = self.__dict__
    ll = self.getStrips()
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  dimensionOrdering = property(getDimensionOrdering, setDimensionOrdering, None,
  r"""Dimension number ordering matching original axis ordering and 
  SpectrumDiplay.axisCodes. NB values where no dataDim matches should have 
  0 as a sentinel. If e.g. an HSQC-NOESY (dim 1 Hn, dim 2 Nh, dim 3 H) is 
  displayed on a 4D Hn,Hc,Ch,Nh window. we would 
  have:
  SpectrumDisplay.axisCodes: 'Hn','Hc','Ch','Nh'
  dimensionOrdering: 
  1,3,0,2
  """)
  
  displayNegativeContours = property(getDisplayNegativeContours, setDisplayNegativeContours, None,
  r"""Toggle display of negative contours on/off
  """)
  
  displayPositiveContours = property(getDisplayPositiveContours, setDisplayPositiveContours, None,
  r"""Toggle display of positive contours on/off
  """)
  
  experimentType = property(getExperimentType, setExperimentType, None,
  r"""Systematic name of experiment. Stored when disconnected to facilitate 
  finding a suitable experiment when sharing the Task,
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted
  
  isDisplayed = property(getIsDisplayed, setIsDisplayed, None,
  r"""Is spectrum displayed?
  """)

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  negativeContourBase = property(getNegativeContourBase, setNegativeContourBase, None,
  r"""base level for positive contours
  """)
  
  negativeContourColour = property(getNegativeContourColour, setNegativeContourColour, None,
  r"""Negative contour colour or colour scheme string. Could be a colour name 
  or colour specification.
  """)
  
  negativeContourCount = property(getNegativeContourCount, setNegativeContourCount, None,
  r"""Number of negative contours to display
  """)
  
  negativeContourFactor = property(getNegativeContourFactor, setNegativeContourFactor, None,
  r"""Negative contour level multiplier (defaults to sqrt(2))
  """)

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  positiveContourBase = property(getPositiveContourBase, setPositiveContourBase, None,
  r"""base level for positive contours
  """)
  
  positiveContourColour = property(getPositiveContourColour, setPositiveContourColour, None,
  r"""Positive contour colour or colour scheme string. Could be a colour name 
  or colour specification.
  """)
  
  positiveContourCount = property(getPositiveContourCount, setPositiveContourCount, None,
  r"""Number of positive contours to display
  """)
  
  positiveContourFactor = property(getPositiveContourFactor, setPositiveContourFactor, None,
  r"""Positive contour level multiplier (defaults to sqrt(2))
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  sliceColour = property(getSliceColour, setSliceColour, None,
  r"""Slice or 1D colour or colour scheme string. Could be a colour name or 
  colour specification.
  """)
  
  spectrumName = property(getSpectrumName, setSpectrumName, None,
  r"""Name of experiment being viewed. Part of key. 
  """)
  
  stripSerial = property(getStripSerial, setStripSerial, None,
  r"""Serial of attached strip - value 0 means  all strips
  """)
  
  dataSource = property(getDataSource, setDataSource, None,
  r"""DataSource that SpectrumView pertains to
  """)
  
  orderedDataDims = property(getOrderedDataDims, None, None,
  r"""dataDims in order of current axis settings
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for spectrumDisplay
  """)
  
  peakListViews = property(getPeakListViews,  None, None,
  r"""child link to class PeakListView
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  spectrumDisplay = property(getSpectrumDisplay,  None, None,
  r"""parent link
  """)
  
  stripSpectrumViews = property(getStripSpectrumViews, setStripSpectrumViews, None,
  r"""StripSpectrumViews defining a strip where this SpectrumView is avalid
  """)
  
  strips = property(getStrips, None, None,
  r"""Strips that SpectrumView applies to
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.SpectrumView', SpectrumView)

###############################################################################
class Strip(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Abstract superclass for display strips
  """
  #   from data model element ccpnmr.gui.Task.Strip
  _metaclass = metaPackage.getElement('Strip')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'index', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'positions', 'qualifiedName', 'serial', 'units', 'widths', 'orderedAxes', 'root', 'spectrumDisplay', 'spectrumViews', 'stripAxes', 'stripSpectrumViews', 'topObject',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addPosition(self, value):
    """
    Add for ccpnmr.gui.Task.Strip.positions
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.addPosition:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.addPosition:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getPositions()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addPosition:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addPosition:
       called on deleted object""" % self.qualifiedName
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setPositions(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addPosition')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositions, self.addPosition,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addUnit(self, value):
    """
    Add for ccpnmr.gui.Task.Strip.units
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.addUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.addUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.addUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.addUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getUnits()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addUnit:
       called on deleted object""" % self.qualifiedName
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setUnits(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnits, self.addUnit,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addWidth(self, value):
    """
    Add for ccpnmr.gui.Task.Strip.widths
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.addWidth:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.addWidth:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getWidths()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addWidth:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addWidth:
       called on deleted object""" % self.qualifiedName
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setWidths(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addWidth')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWidths, self.addWidth,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid
  
  def clone(self):
    """
    Make duplicate of strip and place it as the last ordered strip.
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.clone:
       called on deleted object""" % self.qualifiedName
      )

    from ccpnmodel.ccpncore.lib import CopyData
    spectrumDisplay = self.spectrumDisplay
    
    stripSerial = spectrumDisplay.__dict__['_serialDict']['strips'] + 1
    for axis in spectrumDisplay.findAllAxes(stripSerial=self.serial):
      CopyData.copySubTree(axis, spectrumDisplay, maySkipCrosslinks=True, topObjectParameters={'stripSerial': stripSerial})
    for view in spectrumDisplay.findAllSpectrumViews(stripSerial=self.serial):
      CopyData.copySubTree(view, spectrumDisplay, maySkipCrosslinks=True, topObjectParameters={'stripSerial': stripSerial})
    
    makeStrip = getattr(spectrumDisplay, 'new'+self.className)
    if 'Free' in self.className:
      result = makeStrip(axisCodes=self.axisCodes, axisOrder=self.axisOrder)
    else:
      result = makeStrip(axisOrder=self.axisOrder)
    
    undo = self.root._undo
    if undo is not None:
       undo.newItem(result.delete, self.clone)
    return result

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllOrderedAxes(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Strip.orderedAxes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedAxes()
      result = list(currentValues)

    else:
      currentValues = self.getOrderedAxes()
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result
  
  def findAllSpectrumViews(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Strip.spectrumViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getSpectrumViews()
      result = set(currentValues)

    else:
      currentValues = self.getSpectrumViews()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'displayNegativeContours', 'displayPositiveContours', 'experimentType', 'isDisplayed', 'negativeContourBase', 'negativeContourColour', 'negativeContourCount', 'negativeContourFactor', 'positiveContourBase', 'positiveContourColour', 'positiveContourCount', 'positiveContourFactor', 'sliceColour', 'spectrumName', 'stripSerial', 'dataSource', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStripAxes(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Strip.stripAxes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripAxes').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('stripAxes').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'axis', 'strip',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStripSpectrumViews(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.Strip.stripSpectrumViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripSpectrumViews').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('stripSpectrumViews').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'spectrumView', 'strip',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAxis(self, value):
    """
    Find connected axis that has exactly the input axis code.
    """
    dataDict = self.__dict__
    try:
      index = self.axisOrder.index(value)
      result = self.orderedAxes[index]
    except ValueError:
      result = None
    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstOrderedAxis(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Strip.orderedAxes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedAxes()
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = self.getOrderedAxes()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstSpectrumView(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Strip.spectrumViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getSpectrumViews()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      currentValues = self.getSpectrumViews()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'displayNegativeContours', 'displayPositiveContours', 'experimentType', 'isDisplayed', 'negativeContourBase', 'negativeContourColour', 'negativeContourCount', 'negativeContourFactor', 'positiveContourBase', 'positiveContourColour', 'positiveContourCount', 'positiveContourFactor', 'sliceColour', 'spectrumName', 'stripSerial', 'dataSource', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStripAxis(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Strip.stripAxes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripAxes').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('axis')
      if (objKey is not None):
        result = dataDict.get('stripAxes').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('stripAxes').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'axis', 'strip',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStripSpectrumView(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.Strip.stripSpectrumViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripSpectrumViews').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('spectrumView')
      if (objKey is not None):
        result = dataDict.get('stripSpectrumViews').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('stripSpectrumViews').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'spectrumView', 'strip',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.Strip
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Strip'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.Strip'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('strips').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.Strip
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor
  
  def getIndex(self):
    """
    Get for ccpnmr.gui.Task.Strip.index
    """
    dataDict = self.__dict__
    result = dataDict.get('index')
    return result

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.Strip
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getOrderedAxes(self):
    """
    getter for derived link orderedAxes
    """
    dataDict = self.__dict__
    display = self.spectrumDisplay
    axisOrder = self.axisOrder
    stripDirection = display.stripDirection
    if stripDirection is None:
      result = tuple(display.findFirstAxis(code=x) for x in axisOrder)
    else:
      result = []
      stripSerial = self.serial
      index = 'XY'.index(stripDirection)
      for ii,code in enumerate(axisOrder):
        if ii == index:
          result.append(display.findFirstAxis(code=code))
        else:
          result.append(display.findFirstAxis(code=code, stripSerial=stripSerial))
      result = tuple(result)
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getPositions(self):
    """
    getter for derived attribute positions
    """
    dataDict = self.__dict__
    result = tuple(x.position for x in self.orderedAxes)
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccpnmr.gui.Task.Strip.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getSpectrumDisplay(self):
    """
    Get for ccpnmr.gui.Task.Strip.spectrumDisplay
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getSpectrumDisplay:
     getSpectrumDisplay should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getSpectrumViews(self):
    """
    getter for derived link spectrumViews
    """
    dataDict = self.__dict__
    result = tuple(x.spectrumView for x in self.sortedStripSpectrumViews() )
    return result
  
  def getStripAxes(self):
    """
    Get for ccpnmr.gui.Task.Strip.stripAxes
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('stripAxes').values()
    result = frozenset(tempVar)
    return result
  
  def getStripSpectrumViews(self):
    """
    Get for ccpnmr.gui.Task.Strip.stripSpectrumViews
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('stripSpectrumViews').values()
    result = frozenset(tempVar)
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnits(self):
    """
    getter for derived attribute units
    """
    dataDict = self.__dict__
    result = tuple(x.unit for x in self.orderedAxes)
    return result
  
  def getWidths(self):
    """
    getter for derived attribute widths
    """
    dataDict = self.__dict__
    result = tuple(x.width for x in self.orderedAxes)
    return result

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def moveTo(self, newIndex):
    """
    Move strip in stripOrder to position determined by newIndex
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.moveTo:
       called on deleted object""" % self.qualifiedName
      )

    if not isinstance(newIndex, int) or newIndex < 0:
      raise ApiError("Parameter to moveTo function is not a non-negative integer: %s" % newIndex)
    
    ii = 0
    oldIndex = self.index
    for strip in self.spectrumDisplay.orderedStrips:
      if strip is self:
        strip.__dict__['index'] = newIndex
        continue
      else:
        if ii == newIndex:
          ii += 1
        strip.__dict__['index'] = ii
        ii += 1
    
    undo = self.root._undo
    if undo is not None:
      undo.newItem(self.moveTo, self.moveTo, undoArgs=(oldIndex,), redoArgs=(
    newIndex,))
  
  def newStripAxis(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.StripAxis
    """
    return StripAxis(self, **attrlinks)
  
  def newStripSpectrumView(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.StripSpectrumView
    """
    return StripSpectrumView(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removePosition(self, value):
    """
    Remove for ccpnmr.gui.Task.Strip.positions
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.removePosition:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.removePosition:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getPositions()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removePosition:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removePosition:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removePosition:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setPositions(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removePosition')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositions, self.removePosition,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeUnit(self, value):
    """
    Remove for ccpnmr.gui.Task.Strip.units
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.removeUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.removeUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.removeUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getUnits()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeUnit:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeUnit:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setUnits(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnits, self.removeUnit,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeWidth(self, value):
    """
    Remove for ccpnmr.gui.Task.Strip.widths
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.removeWidth:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.removeWidth:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getWidths()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeWidth:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeWidth:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeWidth:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setWidths(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeWidth')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWidths, self.removeWidth,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def resetAxisOrder(self):
    """
    Reset axisOrder to original value
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.resetAxisOrder:
       called on deleted object""" % self.qualifiedName
      )

    self.axisOrder = self.axisCodes

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setIndex(self, value):
    """
    Set for ccpnmr.gui.Task.Strip.index
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setIndex:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('index')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIndex:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setIndex:
         cannot set index, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setIndex:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['index'] = value

    # doNotifies
  
  def setOrderedAxes(self, values):
    """
    setter for derived link orderedAxes
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setOrderedAxes:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, Axis)):
        raise ApiError("""%s.setOrderedAxes:
         value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedAxes()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOrderedAxes:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOrderedAxes:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setOrderedAxes:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.axisOrder = [(x and x.code) for x in values]
      # The (x and x.code) trick gives None if x is None, x.code otherwise.
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOrderedAxes')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedAxes, self.setOrderedAxes,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setPositions(self, values):
    """
    setter for derived attribute positions
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        replaceIndex = values.index(value)
        values[replaceIndex] = castValue
        value = castValue
      else:
        raise ApiError("""%s.setPositions:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setPositions:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getPositions()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPositions:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPositions:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      for ii,axis in enumerate(self.orderedAxes):
        axis.position = values[ii]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPositions')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositions, self.setPositions,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setSerial(self, value):
    """
    Set for ccpnmr.gui.Task.Strip.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
      pass
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('spectrumDisplay')
    oldSerial = parent.__dict__.get('_serialDict').get('strips')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['strips'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['strips'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setUnits(self, values):
    """
    setter for derived link units
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setUnits:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setUnits:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setUnits:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setUnits:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getUnits()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUnits:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnits:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      for ii,axis in enumerate(self.orderedAxes):
        axis.unit = values[ii]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUnits')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnits, self.setUnits,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setWidths(self, values):
    """
    setter for derived attribute widths
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        replaceIndex = values.index(value)
        values[replaceIndex] = castValue
        value = castValue
      else:
        raise ApiError("""%s.setWidths:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setWidths:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getWidths()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWidths:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWidths:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      for ii,axis in enumerate(self.orderedAxes):
        axis.width = values[ii]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWidths')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWidths, self.setWidths,
                      undoArgs=(currentValues,), redoArgs=(values,))

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedSpectrumViews(self):
    """
    Sorted for ccpnmr.gui.Task.Strip.spectrumViews
    """
    dataDict = self.__dict__
    ll = self.getSpectrumViews()
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedStripAxes(self):
    """
    Sorted for ccpnmr.gui.Task.Strip.stripAxes
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('stripAxes')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedStripSpectrumViews(self):
    """
    Sorted for ccpnmr.gui.Task.Strip.stripSpectrumViews
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('stripSpectrumViews')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor
  
  index = property(getIndex, setIndex, None,
  r"""Index of strip in strip ordering, starting at zero, set automatically on 
  object creation. New strips are added at the end of the list. Indices 
  are reset when strips are deleted, by the Strip.moveTo(newIndex) 
  command, and when the orderedStrips link is set.
  """)

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  positions = property(getPositions, setPositions, None,
  r"""Axis positions in axis order
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  units = property(getUnits, setUnits, None,
  r"""Axis units in axis order
  """)
  
  widths = property(getWidths, setWidths, None,
  r"""Axis widths in axis order
  """)
  
  orderedAxes = property(getOrderedAxes, setOrderedAxes, None,
  r"""
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  spectrumDisplay = property(getSpectrumDisplay,  None, None,
  r"""parent link
  """)
  
  spectrumViews = property(getSpectrumViews, None, None,
  r"""SpectrumViews showing spectra viewed in this strip
  """)
  
  stripAxes = property(getStripAxes,  None, None,
  r"""child link to class StripAxis
  """)
  
  stripSpectrumViews = property(getStripSpectrumViews,  None, None,
  r"""child link to class StripSpectrumView
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.Strip', Strip)

###############################################################################
class StripAxis(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Axis belonging to specific strip
  """
  #   from data model element ccpnmr.gui.Task.StripAxis
  _metaclass = metaPackage.getElement('StripAxis')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'axis', 'parent', 'root', 'strip', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.StripAxis
    """
    dataDict = self.__dict__
    dataDict['strip'] = parent
    if (not isinstance(parent, Strip)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['axis'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.StripAxis', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.StripAxis.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('stripAxes')
        objKey = dataDict.get('axis')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['axis'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.StripAxis:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.StripAxis:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    axis = dataDict.get('axis')
    if ((axis is not None and not (axis in objsToBeDeleted))):
      stripAxes = axis.__dict__.get('stripAxes')
      stripAxes.remove(self)

    strip = dataDict.get('strip')
    if (not (strip in objsToBeDeleted)):
      objKey = dataDict.get('axis')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = strip.__dict__.get('stripAxes')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.StripAxis:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    strip = dataDict.get('strip')
    if (not (strip in objsToBeUnDeleted)):

      childrenDict = strip.__dict__.get('stripAxes')
      objKey = dataDict.get('axis')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['axis'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    axis = dataDict.get('axis')
    if ((axis is not None and not (axis in objsToBeUnDeleted))):
      stripAxes = axis.__dict__.get('stripAxes')
      stripAxes.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.StripAxis
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.StripAxis
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('axis')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('strip')
        dd = value.__dict__.get('stripAxes')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'strip' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('axis')
      if (not isinstance(value, Axis)):
        raise ApiError("""%s.checkValid: axis:
         value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('stripAxes')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: axis:
         non-reciprocal link axis from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('strip')
      if (not isinstance(value, Strip)):
        raise ApiError("""%s.checkValid: strip:
         value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('axis')
    if (value is None):
      raise ApiError("""%s.checkValid: axis:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('strip')
    if (value is None):
      raise ApiError("""%s.checkValid: strip:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.StripAxis
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxis(self):
    """
    Get for ccpnmr.gui.Task.StripAxis.axis
    """
    dataDict = self.__dict__
    result = dataDict.get('axis')
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.StripAxis
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.StripAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.StripAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('strips').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('stripAxes').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.StripAxis
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('strip')
    obj2 = obj3.__dict__.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('axis'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.StripAxis
    """
    dataDict = self.__dict__
    result = dataDict.get('axis')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.StripAxis.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('strip')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getStrip(self):
    """
    Get for ccpnmr.gui.Task.StripAxis.strip
    """
    dataDict = self.__dict__
    result = dataDict.get('strip')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.StripAxis
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxis(self, value):
    """
    Set for ccpnmr.gui.Task.StripAxis.axis
    """
    dataDict = self.__dict__
    if (not isinstance(value, Axis)):
      raise ApiError("""%s.setAxis:
       value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('axis')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxis:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAxis:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setAxis:
         cannot set axis, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setAxis:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setAxis:
         Link axis between objects from separate partitions
          - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('stripAxes')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setAxis:
         Read link 'axis' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('stripAxes')
      newSelves.add(self)

    dataDict['axis'] = value

    # doNotifies

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  axis = property(getAxis, setAxis, None,
  r"""Axis belonging to Strip
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for strip
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  strip = property(getStrip,  None, None,
  r"""parent link
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.StripAxis', StripAxis)

###############################################################################
class StripPeakListView(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Strip-specific PeakListView
  """
  #   from data model element ccpnmr.gui.Task.StripPeakListView
  _metaclass = metaPackage.getElement('StripPeakListView')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'parent', 'peakListView', 'root', 'stripSpectrumView', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.StripPeakListView
    """
    dataDict = self.__dict__
    dataDict['stripSpectrumView'] = parent
    if (not isinstance(parent, StripSpectrumView)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.StripSpectrumView""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['peakListView'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.StripPeakListView', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.StripPeakListView.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('stripPeakListViews')
        objKey = dataDict.get('peakListView')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['peakListView'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.StripPeakListView:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    # The following code interacts directly with the deletion implementation (use of 'objsToBeDeleted'). 
    # This is bad, but the only way to accomplish the desired result.
    if self.peakListView not in objsToBeDeleted and self.stripSpectrumView not in objsToBeDeleted and not self.root.override:
      raise ApiError("StripPeakListView %s: StripPeakListViews can only be deleted when the PeakListView or StripSpectrumView is deleted." % self)
    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.StripPeakListView:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    peakListView = dataDict.get('peakListView')
    if ((peakListView is not None and not (peakListView in objsToBeDeleted))):
      stripPeakListViews = peakListView.__dict__.get('stripPeakListViews')
      stripPeakListViews.remove(self)

    stripSpectrumView = dataDict.get('stripSpectrumView')
    if (not (stripSpectrumView in objsToBeDeleted)):
      objKey = dataDict.get('peakListView')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = stripSpectrumView.__dict__.get('stripPeakListViews')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.StripPeakListView:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    stripSpectrumView = dataDict.get('stripSpectrumView')
    if (not (stripSpectrumView in objsToBeUnDeleted)):

      childrenDict = stripSpectrumView.__dict__.get('stripPeakListViews')
      objKey = dataDict.get('peakListView')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['peakListView'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    peakListView = dataDict.get('peakListView')
    if ((peakListView is not None and not (peakListView in objsToBeUnDeleted))):
      stripPeakListViews = peakListView.__dict__.get('stripPeakListViews')
      stripPeakListViews.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.StripPeakListView
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.StripPeakListView
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('peakListView')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('stripSpectrumView')
        dd = value.__dict__.get('stripPeakListViews')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'stripSpectrumView' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('peakListView')
      if (not isinstance(value, PeakListView)):
        raise ApiError("""%s.checkValid: peakListView:
         value is not of class ccpnmr.gui.Task.PeakListView""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('stripPeakListViews')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: peakListView:
         non-reciprocal link peakListView from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('stripSpectrumView')
      if (not isinstance(value, StripSpectrumView)):
        raise ApiError("""%s.checkValid: stripSpectrumView:
         value is not of class ccpnmr.gui.Task.StripSpectrumView""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('peakListView')
    if (value is None):
      raise ApiError("""%s.checkValid: peakListView:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('stripSpectrumView')
    if (value is None):
      raise ApiError("""%s.checkValid: stripSpectrumView:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.StripPeakListView
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.StripPeakListView
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (6 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.StripPeakListView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.StripPeakListView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('strips').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-2]
          obj4 = obj3.__dict__.get('stripSpectrumViews').get(objKey)

          if (obj4 is not None):
            objKey = fullKey[-1]
            obj5 = obj4.__dict__.get('stripPeakListViews').get(objKey)
            result = obj5

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.StripPeakListView
    """
    dataDict = self.__dict__
    result = list()

    obj4 = dataDict.get('stripSpectrumView')
    obj3 = obj4.__dict__.get('strip')
    obj2 = obj3.__dict__.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(obj3.__dict__.get('serial'))
    result.append(obj4.__dict__.get('spectrumView'))
    result.append(dataDict.get('peakListView'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.StripPeakListView
    """
    dataDict = self.__dict__
    result = dataDict.get('peakListView')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.StripPeakListView.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('stripSpectrumView')
    return result
  
  def getPeakListView(self):
    """
    Get for ccpnmr.gui.Task.StripPeakListView.peakListView
    """
    dataDict = self.__dict__
    result = dataDict.get('peakListView')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getStripSpectrumView(self):
    """
    Get for ccpnmr.gui.Task.StripPeakListView.stripSpectrumView
    """
    dataDict = self.__dict__
    result = dataDict.get('stripSpectrumView')
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.StripPeakListView
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setPeakListView(self, value):
    """
    Set for ccpnmr.gui.Task.StripPeakListView.peakListView
    """
    dataDict = self.__dict__
    if (not isinstance(value, PeakListView)):
      raise ApiError("""%s.setPeakListView:
       value is not of class ccpnmr.gui.Task.PeakListView""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peakListView')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakListView:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPeakListView:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeakListView:
         cannot set peakListView, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPeakListView:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('stripSpectrumView')
      xx2 = xx1.__dict__.get('spectrumView')
      yy1 = value.__dict__.get('spectrumView')
      if (not (xx2 is yy1)):
        raise ApiError("""%s.setPeakListView:
         Link peakListView between objects from separate partitions
         - ccpnmr.gui.Task.StripSpectrumView.spectrumView not set correctly""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('stripPeakListViews')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setPeakListView:
         Read link 'peakListView' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('stripPeakListViews')
      newSelves.add(self)

    dataDict['peakListView'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for stripSpectrumView
  """)
  
  peakListView = property(getPeakListView, setPeakListView, None,
  r"""PeakListView holding data for StripPeakListView
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  stripSpectrumView = property(getStripSpectrumView,  None, None,
  r"""parent link
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.StripPeakListView', StripPeakListView)

###############################################################################
class StripSpectrumView(ccpnmodel.ccpncore.api.memops.Implementation.DataObject):
  r"""Class representing a spectrum being disoplayed in a strip
  """
  #   from data model element ccpnmr.gui.Task.StripSpectrumView
  _metaclass = metaPackage.getElement('StripSpectrumView')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'parent', 'root', 'spectrumView', 'strip', 'stripPeakListViews', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.StripSpectrumView
    """
    dataDict = self.__dict__
    dataDict['strip'] = parent
    if (not isinstance(parent, Strip)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['spectrumView'] = None
      dataDict['stripPeakListViews'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.StripSpectrumView', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.StripSpectrumView.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('stripSpectrumViews')
        objKey = dataDict.get('spectrumView')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['spectrumView'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      _undo = root._undo
      if _undo is not None:
        _undo.increaseBlocking()
      try:
        for peakListView in self.spectrumView.peakListViews:
          plv = self.newStripPeakListView(peakListView=peakListView)
          objectsCreated.add(plv)
      finally:
        if _undo is not None:
          _undo.decreaseBlocking()

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.StripSpectrumView:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    # The following code interacts directly with the deletion implementation (use of 'objsToBeDeleted'). 
    # This is bad, but the only way to accomplish the desired result.
    if self.spectrumView not in objsToBeDeleted and self.strip not in objsToBeDeleted and not self.root.override:
      raise ApiError("StripSpectrumView %s: StripSpectrumViews can only be deleted when the SpectrumView or Strip is deleted." % self)
    stripPeakListViews = dataDict.get('stripPeakListViews').values()
    for stripPeakListView in stripPeakListViews:
      if (not (stripPeakListView in objsToBeDeleted)):
        objsToBeDeleted.add(stripPeakListView)
        objsToBeChecked.append(stripPeakListView)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.StripSpectrumView:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    spectrumView = dataDict.get('spectrumView')
    if ((spectrumView is not None and not (spectrumView in objsToBeDeleted))):
      stripSpectrumViews = spectrumView.__dict__.get('stripSpectrumViews')
      stripSpectrumViews.remove(self)

    strip = dataDict.get('strip')
    if (not (strip in objsToBeDeleted)):
      objKey = dataDict.get('spectrumView')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = strip.__dict__.get('stripSpectrumViews')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.StripSpectrumView:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    strip = dataDict.get('strip')
    if (not (strip in objsToBeUnDeleted)):

      childrenDict = strip.__dict__.get('stripSpectrumViews')
      objKey = dataDict.get('spectrumView')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['spectrumView'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    spectrumView = dataDict.get('spectrumView')
    if ((spectrumView is not None and not (spectrumView in objsToBeUnDeleted))):
      stripSpectrumViews = spectrumView.__dict__.get('stripSpectrumViews')
      stripSpectrumViews.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.StripSpectrumView
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('stripPeakListViews').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.StripSpectrumView
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('spectrumView')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('strip')
        dd = value.__dict__.get('stripSpectrumViews')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'strip' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('spectrumView')
      if (not isinstance(value, SpectrumView)):
        raise ApiError("""%s.checkValid: spectrumView:
         value is not of class ccpnmr.gui.Task.SpectrumView""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('stripSpectrumViews')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: spectrumView:
         non-reciprocal link spectrumView from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('strip')
      if (not isinstance(value, Strip)):
        raise ApiError("""%s.checkValid: strip:
         value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('stripPeakListViews').values()
      for value in values:
        if (not isinstance(value, StripPeakListView)):
          raise ApiError("""%s.checkValid: stripPeakListViews:
           value is not of class ccpnmr.gui.Task.StripPeakListView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('stripSpectrumView')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripPeakListViews:
           non-reciprocal link stripPeakListViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('spectrumView')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumView:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('strip')
    if (value is None):
      raise ApiError("""%s.checkValid: strip:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripPeakListViews').values()

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllStripPeakListViews(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.StripSpectrumView.stripPeakListViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripPeakListViews').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('stripPeakListViews').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'peakListView', 'stripSpectrumView',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstStripPeakListView(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.StripSpectrumView.stripPeakListViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('stripPeakListViews').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('peakListView')
      if (objKey is not None):
        result = dataDict.get('stripPeakListViews').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('stripPeakListViews').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'peakListView', 'stripSpectrumView',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.StripSpectrumView
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.StripSpectrumView
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.StripSpectrumView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.StripSpectrumView'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('strips').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('stripSpectrumViews').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.StripSpectrumView
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('strip')
    obj2 = obj3.__dict__.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('spectrumView'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.StripSpectrumView
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumView')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.StripSpectrumView.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('strip')
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSpectrumView(self):
    """
    Get for ccpnmr.gui.Task.StripSpectrumView.spectrumView
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumView')
    return result
  
  def getStrip(self):
    """
    Get for ccpnmr.gui.Task.StripSpectrumView.strip
    """
    dataDict = self.__dict__
    result = dataDict.get('strip')
    return result
  
  def getStripPeakListViews(self):
    """
    Get for ccpnmr.gui.Task.StripSpectrumView.stripPeakListViews
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('stripPeakListViews').values()
    result = frozenset(tempVar)
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newStripPeakListView(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.StripPeakListView
    """
    return StripPeakListView(self, **attrlinks)

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.StripSpectrumView
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setSpectrumView(self, value):
    """
    Set for ccpnmr.gui.Task.StripSpectrumView.spectrumView
    """
    dataDict = self.__dict__
    if (not isinstance(value, SpectrumView)):
      raise ApiError("""%s.setSpectrumView:
       value is not of class ccpnmr.gui.Task.SpectrumView""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('spectrumView')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSpectrumView:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setSpectrumView:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSpectrumView:
         cannot set spectrumView, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSpectrumView:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setSpectrumView:
         Link spectrumView between objects from separate partitions
          - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('stripSpectrumViews')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setSpectrumView:
         Read link 'spectrumView' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('stripSpectrumViews')
      newSelves.add(self)

    dataDict['spectrumView'] = value

    # doNotifies

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedStripPeakListViews(self):
    """
    Sorted for ccpnmr.gui.Task.StripSpectrumView.stripPeakListViews
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('stripPeakListViews')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for strip
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  spectrumView = property(getSpectrumView, setSpectrumView, None,
  r"""SpectrumView linked to Strip
  """)
  
  strip = property(getStrip,  None, None,
  r"""parent link
  """)
  
  stripPeakListViews = property(getStripPeakListViews,  None, None,
  r"""child link to class StripPeakListView
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.StripSpectrumView', StripSpectrumView)

###############################################################################
class SampledAxis(Axis):
  r"""
  """
  #   from data model element ccpnmr.gui.Task.SampledAxis
  _metaclass = metaPackage.getElement('SampledAxis')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'code', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'position', 'qualifiedName', 'regions', 'resonanceSerials', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'parent', 'resonances', 'root', 'spectrumDisplay', 'stripAxes', 'strips', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.SampledAxis
    """
    dataDict = self.__dict__
    dataDict['spectrumDisplay'] = parent
    if (not isinstance(parent, SpectrumDisplay)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['code'] = None
      dataDict['position'] = 1.0
      dataDict['regions'] = list()
      dataDict['resonanceSerials'] = list()
      dataDict['stripSerial'] = 0
      dataDict['unit'] = None
      dataDict['width'] = 10.0
      dataDict['axisPositionGroup'] = None
      dataDict['axisWidthGroup'] = None
      dataDict['resonances'] = set()
      dataDict['stripAxes'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.SampledAxis', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.SampledAxis.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('axes')
        ll = list()
        objKey = dataDict.get('code')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('stripSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['code', 'stripSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        
        
        if self.resonances:
          self.resonanceSerials = [x.serial for x in self.resonances]
        else:
          nmrProject = self.topObject.nmrProject
          if nmrProject is not None:
            ll = [nmrProject.findFirstResonance(serial=x) for x in self.resonanceSerials]
            self.resonances = [x for x in ll if x is not None]

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      stripSerial = self.stripSerial
      if stripSerial:
        strip = self.spectrumDisplay.findFirstStrip(serial=stripSerial)
        if strip:
          sa = strip.newStripAxis(axis=self)
          objectsCreated.add(sa)
      else:
        for strip in self.spectrumDisplay.strips:
          sa = strip.newStripAxis(axis=self)
          objectsCreated.add(sa)

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.SampledAxis:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    spectrumDisplay = self.spectrumDisplay
    strip = spectrumDisplay.findFirstStrip(serial=self.stripSerial)
    if not (spectrumDisplay in objsToBeDeleted or (strip and strip in objsToBeDeleted)):
      raise ApiError("Axes cannot be deleted independently")
    axisPositionGroup = dataDict.get('axisPositionGroup')
    if (axisPositionGroup is not None):
      if (not (axisPositionGroup in objsToBeDeleted)):
        backlink = axisPositionGroup.__dict__.get('axes')
        key = (axisPositionGroup, 'axes')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 2):
          objsToBeDeleted.add(axisPositionGroup)
          objsToBeChecked.append(axisPositionGroup)
        else:
          linkCounter[key] = nFound

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if (axisWidthGroup is not None):
      if (not (axisWidthGroup in objsToBeDeleted)):
        backlink = axisWidthGroup.__dict__.get('axes')
        key = (axisWidthGroup, 'axes')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 2):
          objsToBeDeleted.add(axisWidthGroup)
          objsToBeChecked.append(axisWidthGroup)
        else:
          linkCounter[key] = nFound

    resonances = dataDict.get('resonances')
    pass
    for resonance in resonances:
      topObject = resonance.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    stripAxes = dataDict.get('stripAxes')
    for stripAxis in stripAxes:
      if (not (stripAxis in objsToBeDeleted)):
        objsToBeDeleted.add(stripAxis)
        objsToBeChecked.append(stripAxis)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.SampledAxis:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    axisPositionGroup = dataDict.get('axisPositionGroup')
    if ((axisPositionGroup is not None and not (axisPositionGroup in objsToBeDeleted))):
      axes = axisPositionGroup.__dict__.get('axes')
      axes.remove(self)

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if ((axisWidthGroup is not None and not (axisWidthGroup in objsToBeDeleted))):
      axes = axisWidthGroup.__dict__.get('axes')
      axes.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        displayAxes = resonance.__dict__.get('displayAxes')
        displayAxes.remove(self)

    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeDeleted)):
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = spectrumDisplay.__dict__.get('axes')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.SampledAxis:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeUnDeleted)):

      childrenDict = spectrumDisplay.__dict__.get('axes')
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['code', 'stripSerial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    axisPositionGroup = dataDict.get('axisPositionGroup')
    if ((axisPositionGroup is not None and not (axisPositionGroup in objsToBeUnDeleted))):
      axes = axisPositionGroup.__dict__.get('axes')
      axes.add(self)

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if ((axisWidthGroup is not None and not (axisWidthGroup in objsToBeUnDeleted))):
      axes = axisWidthGroup.__dict__.get('axes')
      axes.add(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        displayAxes = resonance.__dict__.get('displayAxes')
        displayAxes.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addRegion = Axis.addRegion

  addResonance = Axis.addResonance

  addResonanceSerial = Axis.addResonanceSerial
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.SampledAxis
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.SampledAxis
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('spectrumDisplay')
        dd = value.__dict__.get('axes')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'spectrumDisplay' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('code')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: code:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('position')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: position:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: position:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('regions')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: regions:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: regions:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('resonanceSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: resonanceSerials:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: resonanceSerials:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('stripSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripSerial:
         memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value >= 0)):
        raise ApiError("""%s.checkValid: stripSerial:
         NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: unit:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('width')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: width:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: width:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('axisPositionGroup')
      if (value is not None):
        if (not isinstance(value, AxisPositionGroup)):
          raise ApiError("""%s.checkValid: axisPositionGroup:
           value is not of class ccpnmr.gui.Task.AxisPositionGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('axes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: axisPositionGroup:
           non-reciprocal link axisPositionGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('axisWidthGroup')
      if (value is not None):
        if (not isinstance(value, AxisWidthGroup)):
          raise ApiError("""%s.checkValid: axisWidthGroup:
           value is not of class ccpnmr.gui.Task.AxisWidthGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('axes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: axisWidthGroup:
           non-reciprocal link axisWidthGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('resonances')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Resonance as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.Nmr.Resonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('displayAxes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('spectrumDisplay')
      if (not isinstance(value, SpectrumDisplay)):
        raise ApiError("""%s.checkValid: spectrumDisplay:
         value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('stripAxes')
      for value in values:
        if (not isinstance(value, StripAxis)):
          raise ApiError("""%s.checkValid: stripAxes:
           value is not of class ccpnmr.gui.Task.StripAxis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('axis')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripAxes:
           non-reciprocal link stripAxes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: stripAxes:
           Link stripAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getStrips()
      for value in values:
        if (not isinstance(value, Strip)):
          raise ApiError("""%s.checkValid: strips:
           value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getOrderedAxes()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: strips:
           non-reciprocal link strips from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('code')
    if (value is None):
      raise ApiError("""%s.checkValid: code:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (value[0].islower())):
      raise ApiError("""%s.checkValid: code:
       code constraint value_axis_code_starts_with_lower_case violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    value = dataDict.get('position')
    if (value is None):
      raise ApiError("""%s.checkValid: position:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('regions')
    values = dataDict.get('resonanceSerials')
    value = dataDict.get('stripSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: stripSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    if (value is None):
      raise ApiError("""%s.checkValid: unit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('width')
    if (value is None):
      raise ApiError("""%s.checkValid: width:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('axisPositionGroup')
    value = dataDict.get('axisWidthGroup')
    values = dataDict.get('resonances')
    value = dataDict.get('spectrumDisplay')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumDisplay:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripAxes')

  connectPositionTo = Axis.connectPositionTo

  connectTo = Axis.connectTo

  connectWidthTo = Axis.connectWidthTo

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  disconnect = Axis.disconnect

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllResonances = Axis.findAllResonances

  findAllStripAxes = Axis.findAllStripAxes

  findAllStrips = Axis.findAllStrips

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstResonance = Axis.findFirstResonance

  findFirstStrip = Axis.findFirstStrip

  findFirstStripAxis = Axis.findFirstStripAxis
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.SampledAxis
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData

  getAxisPositionGroup = Axis.getAxisPositionGroup

  getAxisWidthGroup = Axis.getAxisWidthGroup
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.SampledAxis
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.SampledAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.SampledAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        ll = list()
        objKey = fullKey[-2]
        ll.append(objKey)
        if (objKey is not None):
          objKey = fullKey[-1]
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        obj3 = obj2.__dict__.get('axes').get(objKey)
        if (isinstance(obj3, SampledAxis)):
          result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getCode(self):
    """
    Get for ccpnmr.gui.Task.SampledAxis.code
    """
    dataDict = self.__dict__
    result = dataDict.get('code')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = Axis.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = Axis.getLocalKey

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = Axis.getParent

  getPosition = Axis.getPosition

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRegions = Axis.getRegions

  getResonanceSerials = Axis.getResonanceSerials

  getResonances = Axis.getResonances

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSpectrumDisplay = Axis.getSpectrumDisplay

  getStripAxes = Axis.getStripAxes

  getStripSerial = Axis.getStripSerial

  getStrips = Axis.getStrips

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnit(self):
    """
    Get for ccpnmr.gui.Task.SampledAxis.unit
    """
    dataDict = self.__dict__
    result = dataDict.get('unit')
    return result

  getWidth = Axis.getWidth

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeRegion = Axis.removeRegion

  removeResonance = Axis.removeResonance

  removeResonanceSerial = Axis.removeResonanceSerial
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.SampledAxis
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setAxisPositionGroup = Axis.setAxisPositionGroup

  setAxisWidthGroup = Axis.setAxisWidthGroup

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setCode(self, value):
    """
    Set for ccpnmr.gui.Task.SampledAxis.code
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setCode:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setCode:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setCode:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setCode:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('code')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setCode:
         cannot set code, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setCode:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (value[0].islower())):
            raise ApiError("""%s.setCode:
             code constraint value_axis_code_starts_with_lower_case violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['code'] = value

    # doNotifies

  setPosition = Axis.setPosition

  setRegions = Axis.setRegions

  setResonanceSerials = Axis.setResonanceSerials

  setResonances = Axis.setResonances

  setStripAxes = Axis.setStripAxes

  setStripSerial = Axis.setStripSerial
  
  def setUnit(self, value):
    """
    Set for ccpnmr.gui.Task.SampledAxis.unit
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('unit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setUnit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['unit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnit, self.setUnit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setWidth = Axis.setWidth

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedResonances = Axis.sortedResonances

  sortedStripAxes = Axis.sortedStripAxes

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  code = property(getCode, setCode, None,
  r"""
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  position = Axis.position

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  regions = Axis.regions

  resonanceSerials = Axis.resonanceSerials

  stripSerial = Axis.stripSerial
  
  unit = property(getUnit, setUnit, None,
  r"""
  """)

  width = Axis.width

  axisPositionGroup = Axis.axisPositionGroup

  axisWidthGroup = Axis.axisWidthGroup

  parent = Axis.parent

  resonances = Axis.resonances

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  spectrumDisplay = Axis.spectrumDisplay

  stripAxes = Axis.stripAxes

  strips = Axis.strips

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.SampledAxis', SampledAxis)

###############################################################################
class FidAxis(Axis):
  r"""Axis for FID - pre Fourier transformation
  """
  #   from data model element ccpnmr.gui.Task.FidAxis
  _metaclass = metaPackage.getElement('FidAxis')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'code', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'position', 'qualifiedName', 'regions', 'resonanceSerials', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'parent', 'resonances', 'root', 'spectrumDisplay', 'stripAxes', 'strips', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.FidAxis
    """
    dataDict = self.__dict__
    dataDict['spectrumDisplay'] = parent
    if (not isinstance(parent, SpectrumDisplay)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['code'] = None
      dataDict['position'] = 1.0
      dataDict['regions'] = list()
      dataDict['resonanceSerials'] = list()
      dataDict['stripSerial'] = 0
      dataDict['unit'] = None
      dataDict['width'] = 10.0
      dataDict['axisPositionGroup'] = None
      dataDict['axisWidthGroup'] = None
      dataDict['resonances'] = set()
      dataDict['stripAxes'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.FidAxis', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.FidAxis.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('axes')
        ll = list()
        objKey = dataDict.get('code')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('stripSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['code', 'stripSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        
        
        if self.resonances:
          self.resonanceSerials = [x.serial for x in self.resonances]
        else:
          nmrProject = self.topObject.nmrProject
          if nmrProject is not None:
            ll = [nmrProject.findFirstResonance(serial=x) for x in self.resonanceSerials]
            self.resonances = [x for x in ll if x is not None]

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      stripSerial = self.stripSerial
      if stripSerial:
        strip = self.spectrumDisplay.findFirstStrip(serial=stripSerial)
        if strip:
          sa = strip.newStripAxis(axis=self)
          objectsCreated.add(sa)
      else:
        for strip in self.spectrumDisplay.strips:
          sa = strip.newStripAxis(axis=self)
          objectsCreated.add(sa)

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.FidAxis:
       determines cascading deletes 
    to follow from delete of object.
       *Implementation function* - should 
    be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    spectrumDisplay = self.spectrumDisplay
    strip = spectrumDisplay.findFirstStrip(serial=self.stripSerial)
    if not (spectrumDisplay in objsToBeDeleted or (strip and strip in objsToBeDeleted)):
      raise ApiError("Axes cannot be deleted independently")
    axisPositionGroup = dataDict.get('axisPositionGroup')
    if (axisPositionGroup is not None):
      if (not (axisPositionGroup in objsToBeDeleted)):
        backlink = axisPositionGroup.__dict__.get('axes')
        key = (axisPositionGroup, 'axes')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 2):
          objsToBeDeleted.add(axisPositionGroup)
          objsToBeChecked.append(axisPositionGroup)
        else:
          linkCounter[key] = nFound

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if (axisWidthGroup is not None):
      if (not (axisWidthGroup in objsToBeDeleted)):
        backlink = axisWidthGroup.__dict__.get('axes')
        key = (axisWidthGroup, 'axes')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 2):
          objsToBeDeleted.add(axisWidthGroup)
          objsToBeChecked.append(axisWidthGroup)
        else:
          linkCounter[key] = nFound

    resonances = dataDict.get('resonances')
    pass
    for resonance in resonances:
      topObject = resonance.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    stripAxes = dataDict.get('stripAxes')
    for stripAxis in stripAxes:
      if (not (stripAxis in objsToBeDeleted)):
        objsToBeDeleted.add(stripAxis)
        objsToBeChecked.append(stripAxis)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.FidAxis:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    axisPositionGroup = dataDict.get('axisPositionGroup')
    if ((axisPositionGroup is not None and not (axisPositionGroup in objsToBeDeleted))):
      axes = axisPositionGroup.__dict__.get('axes')
      axes.remove(self)

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if ((axisWidthGroup is not None and not (axisWidthGroup in objsToBeDeleted))):
      axes = axisWidthGroup.__dict__.get('axes')
      axes.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        displayAxes = resonance.__dict__.get('displayAxes')
        displayAxes.remove(self)

    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeDeleted)):
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = spectrumDisplay.__dict__.get('axes')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.FidAxis:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeUnDeleted)):

      childrenDict = spectrumDisplay.__dict__.get('axes')
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['code', 'stripSerial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    axisPositionGroup = dataDict.get('axisPositionGroup')
    if ((axisPositionGroup is not None and not (axisPositionGroup in objsToBeUnDeleted))):
      axes = axisPositionGroup.__dict__.get('axes')
      axes.add(self)

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if ((axisWidthGroup is not None and not (axisWidthGroup in objsToBeUnDeleted))):
      axes = axisWidthGroup.__dict__.get('axes')
      axes.add(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        displayAxes = resonance.__dict__.get('displayAxes')
        displayAxes.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addRegion = Axis.addRegion

  addResonance = Axis.addResonance

  addResonanceSerial = Axis.addResonanceSerial
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.FidAxis
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.FidAxis
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('spectrumDisplay')
        dd = value.__dict__.get('axes')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'spectrumDisplay' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('code')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: code:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('position')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: position:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: position:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('regions')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: regions:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: regions:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('resonanceSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: resonanceSerials:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: resonanceSerials:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('stripSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripSerial:
         memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value >= 0)):
        raise ApiError("""%s.checkValid: stripSerial:
         NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: unit:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('width')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: width:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: width:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('axisPositionGroup')
      if (value is not None):
        if (not isinstance(value, AxisPositionGroup)):
          raise ApiError("""%s.checkValid: axisPositionGroup:
           value is not of class ccpnmr.gui.Task.AxisPositionGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('axes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: axisPositionGroup:
           non-reciprocal link axisPositionGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('axisWidthGroup')
      if (value is not None):
        if (not isinstance(value, AxisWidthGroup)):
          raise ApiError("""%s.checkValid: axisWidthGroup:
           value is not of class ccpnmr.gui.Task.AxisWidthGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('axes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: axisWidthGroup:
           non-reciprocal link axisWidthGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('resonances')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Resonance as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.Nmr.Resonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('displayAxes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('spectrumDisplay')
      if (not isinstance(value, SpectrumDisplay)):
        raise ApiError("""%s.checkValid: spectrumDisplay:
         value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('stripAxes')
      for value in values:
        if (not isinstance(value, StripAxis)):
          raise ApiError("""%s.checkValid: stripAxes:
           value is not of class ccpnmr.gui.Task.StripAxis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('axis')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripAxes:
           non-reciprocal link stripAxes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: stripAxes:
           Link stripAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getStrips()
      for value in values:
        if (not isinstance(value, Strip)):
          raise ApiError("""%s.checkValid: strips:
           value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getOrderedAxes()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: strips:
           non-reciprocal link strips from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('code')
    if (value is None):
      raise ApiError("""%s.checkValid: code:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (value.startswith('fid'))):
      raise ApiError("""%s.checkValid: code:
       code constraint value_axis_code_starts_with_fid violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    value = dataDict.get('position')
    if (value is None):
      raise ApiError("""%s.checkValid: position:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('regions')
    values = dataDict.get('resonanceSerials')
    value = dataDict.get('stripSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: stripSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    if (value is None):
      raise ApiError("""%s.checkValid: unit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('width')
    if (value is None):
      raise ApiError("""%s.checkValid: width:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('axisPositionGroup')
    value = dataDict.get('axisWidthGroup')
    values = dataDict.get('resonances')
    value = dataDict.get('spectrumDisplay')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumDisplay:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripAxes')

  connectPositionTo = Axis.connectPositionTo

  connectTo = Axis.connectTo

  connectWidthTo = Axis.connectWidthTo

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  disconnect = Axis.disconnect

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllResonances = Axis.findAllResonances

  findAllStripAxes = Axis.findAllStripAxes

  findAllStrips = Axis.findAllStrips

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstResonance = Axis.findFirstResonance

  findFirstStrip = Axis.findFirstStrip

  findFirstStripAxis = Axis.findFirstStripAxis
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.FidAxis
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData

  getAxisPositionGroup = Axis.getAxisPositionGroup

  getAxisWidthGroup = Axis.getAxisWidthGroup
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.FidAxis
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.FidAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.FidAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        ll = list()
        objKey = fullKey[-2]
        ll.append(objKey)
        if (objKey is not None):
          objKey = fullKey[-1]
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        obj3 = obj2.__dict__.get('axes').get(objKey)
        if (isinstance(obj3, FidAxis)):
          result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getCode(self):
    """
    Get for ccpnmr.gui.Task.FidAxis.code
    """
    dataDict = self.__dict__
    result = dataDict.get('code')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = Axis.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = Axis.getLocalKey

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = Axis.getParent

  getPosition = Axis.getPosition

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRegions = Axis.getRegions

  getResonanceSerials = Axis.getResonanceSerials

  getResonances = Axis.getResonances

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSpectrumDisplay = Axis.getSpectrumDisplay

  getStripAxes = Axis.getStripAxes

  getStripSerial = Axis.getStripSerial

  getStrips = Axis.getStrips

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnit(self):
    """
    Get for ccpnmr.gui.Task.FidAxis.unit
    """
    dataDict = self.__dict__
    result = dataDict.get('unit')
    return result

  getWidth = Axis.getWidth

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeRegion = Axis.removeRegion

  removeResonance = Axis.removeResonance

  removeResonanceSerial = Axis.removeResonanceSerial
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.FidAxis
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setAxisPositionGroup = Axis.setAxisPositionGroup

  setAxisWidthGroup = Axis.setAxisWidthGroup

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setCode(self, value):
    """
    Set for ccpnmr.gui.Task.FidAxis.code
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setCode:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setCode:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setCode:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setCode:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('code')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setCode:
         cannot set code, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setCode:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (value.startswith('fid'))):
            raise ApiError("""%s.setCode:
             code constraint value_axis_code_starts_with_fid violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['code'] = value

    # doNotifies

  setPosition = Axis.setPosition

  setRegions = Axis.setRegions

  setResonanceSerials = Axis.setResonanceSerials

  setResonances = Axis.setResonances

  setStripAxes = Axis.setStripAxes

  setStripSerial = Axis.setStripSerial
  
  def setUnit(self, value):
    """
    Set for ccpnmr.gui.Task.FidAxis.unit
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('unit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setUnit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['unit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnit, self.setUnit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setWidth = Axis.setWidth

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedResonances = Axis.sortedResonances

  sortedStripAxes = Axis.sortedStripAxes

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  code = property(getCode, setCode, None,
  r"""
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  position = Axis.position

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  regions = Axis.regions

  resonanceSerials = Axis.resonanceSerials

  stripSerial = Axis.stripSerial
  
  unit = property(getUnit, setUnit, None,
  r"""
  """)

  width = Axis.width

  axisPositionGroup = Axis.axisPositionGroup

  axisWidthGroup = Axis.axisWidthGroup

  parent = Axis.parent

  resonances = Axis.resonances

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  spectrumDisplay = Axis.spectrumDisplay

  stripAxes = Axis.stripAxes

  strips = Axis.strips

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.FidAxis', FidAxis)

###############################################################################
class IntensityAxis(Axis):
  r"""
  """
  #   from data model element ccpnmr.gui.Task.IntensityAxis
  _metaclass = metaPackage.getElement('IntensityAxis')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'code', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'position', 'qualifiedName', 'regions', 'resonanceSerials', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'parent', 'resonances', 'root', 'spectrumDisplay', 'stripAxes', 'strips', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.IntensityAxis
    """
    dataDict = self.__dict__
    dataDict['spectrumDisplay'] = parent
    if (not isinstance(parent, SpectrumDisplay)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['code'] = 'intensity'
      dataDict['position'] = 1.0
      dataDict['regions'] = list()
      dataDict['resonanceSerials'] = list()
      dataDict['stripSerial'] = 0
      dataDict['unit'] = 'number'
      dataDict['width'] = 10.0
      dataDict['axisPositionGroup'] = None
      dataDict['axisWidthGroup'] = None
      dataDict['resonances'] = set()
      dataDict['stripAxes'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.IntensityAxis', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.IntensityAxis.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('axes')
        ll = list()
        objKey = dataDict.get('code')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('stripSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['code', 'stripSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        
        
        if self.resonances:
          self.resonanceSerials = [x.serial for x in self.resonances]
        else:
          nmrProject = self.topObject.nmrProject
          if nmrProject is not None:
            ll = [nmrProject.findFirstResonance(serial=x) for x in self.resonanceSerials]
            self.resonances = [x for x in ll if x is not None]

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      stripSerial = self.stripSerial
      if stripSerial:
        strip = self.spectrumDisplay.findFirstStrip(serial=stripSerial)
        if strip:
          sa = strip.newStripAxis(axis=self)
          objectsCreated.add(sa)
      else:
        for strip in self.spectrumDisplay.strips:
          sa = strip.newStripAxis(axis=self)
          objectsCreated.add(sa)

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.IntensityAxis:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    spectrumDisplay = self.spectrumDisplay
    strip = spectrumDisplay.findFirstStrip(serial=self.stripSerial)
    if not (spectrumDisplay in objsToBeDeleted or (strip and strip in objsToBeDeleted)):
      raise ApiError("Axes cannot be deleted independently")
    axisPositionGroup = dataDict.get('axisPositionGroup')
    if (axisPositionGroup is not None):
      if (not (axisPositionGroup in objsToBeDeleted)):
        backlink = axisPositionGroup.__dict__.get('axes')
        key = (axisPositionGroup, 'axes')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 2):
          objsToBeDeleted.add(axisPositionGroup)
          objsToBeChecked.append(axisPositionGroup)
        else:
          linkCounter[key] = nFound

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if (axisWidthGroup is not None):
      if (not (axisWidthGroup in objsToBeDeleted)):
        backlink = axisWidthGroup.__dict__.get('axes')
        key = (axisWidthGroup, 'axes')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 2):
          objsToBeDeleted.add(axisWidthGroup)
          objsToBeChecked.append(axisWidthGroup)
        else:
          linkCounter[key] = nFound

    resonances = dataDict.get('resonances')
    pass
    for resonance in resonances:
      topObject = resonance.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    stripAxes = dataDict.get('stripAxes')
    for stripAxis in stripAxes:
      if (not (stripAxis in objsToBeDeleted)):
        objsToBeDeleted.add(stripAxis)
        objsToBeChecked.append(stripAxis)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.IntensityAxis:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    axisPositionGroup = dataDict.get('axisPositionGroup')
    if ((axisPositionGroup is not None and not (axisPositionGroup in objsToBeDeleted))):
      axes = axisPositionGroup.__dict__.get('axes')
      axes.remove(self)

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if ((axisWidthGroup is not None and not (axisWidthGroup in objsToBeDeleted))):
      axes = axisWidthGroup.__dict__.get('axes')
      axes.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        displayAxes = resonance.__dict__.get('displayAxes')
        displayAxes.remove(self)

    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeDeleted)):
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = spectrumDisplay.__dict__.get('axes')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.IntensityAxis:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeUnDeleted)):

      childrenDict = spectrumDisplay.__dict__.get('axes')
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['code', 'stripSerial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    axisPositionGroup = dataDict.get('axisPositionGroup')
    if ((axisPositionGroup is not None and not (axisPositionGroup in objsToBeUnDeleted))):
      axes = axisPositionGroup.__dict__.get('axes')
      axes.add(self)

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if ((axisWidthGroup is not None and not (axisWidthGroup in objsToBeUnDeleted))):
      axes = axisWidthGroup.__dict__.get('axes')
      axes.add(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        displayAxes = resonance.__dict__.get('displayAxes')
        displayAxes.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addRegion = Axis.addRegion

  addResonance = Axis.addResonance

  addResonanceSerial = Axis.addResonanceSerial
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.IntensityAxis
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.IntensityAxis
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('spectrumDisplay')
        dd = value.__dict__.get('axes')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'spectrumDisplay' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('code')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: code:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('position')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: position:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: position:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('regions')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: regions:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: regions:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('resonanceSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: resonanceSerials:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: resonanceSerials:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('stripSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripSerial:
         memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value >= 0)):
        raise ApiError("""%s.checkValid: stripSerial:
         NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: unit:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('width')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: width:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: width:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('axisPositionGroup')
      if (value is not None):
        if (not isinstance(value, AxisPositionGroup)):
          raise ApiError("""%s.checkValid: axisPositionGroup:
           value is not of class ccpnmr.gui.Task.AxisPositionGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('axes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: axisPositionGroup:
           non-reciprocal link axisPositionGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('axisWidthGroup')
      if (value is not None):
        if (not isinstance(value, AxisWidthGroup)):
          raise ApiError("""%s.checkValid: axisWidthGroup:
           value is not of class ccpnmr.gui.Task.AxisWidthGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('axes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: axisWidthGroup:
           non-reciprocal link axisWidthGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('resonances')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Resonance as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.Nmr.Resonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('displayAxes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('spectrumDisplay')
      if (not isinstance(value, SpectrumDisplay)):
        raise ApiError("""%s.checkValid: spectrumDisplay:
         value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('stripAxes')
      for value in values:
        if (not isinstance(value, StripAxis)):
          raise ApiError("""%s.checkValid: stripAxes:
           value is not of class ccpnmr.gui.Task.StripAxis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('axis')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripAxes:
           non-reciprocal link stripAxes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: stripAxes:
           Link stripAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getStrips()
      for value in values:
        if (not isinstance(value, Strip)):
          raise ApiError("""%s.checkValid: strips:
           value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getOrderedAxes()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: strips:
           non-reciprocal link strips from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('code')
    if (value is None):
      raise ApiError("""%s.checkValid: code:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (value == 'intensity')):
      raise ApiError("""%s.checkValid: code:
       code constraint intensity_axis_code_is_intensity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    value = dataDict.get('position')
    if (value is None):
      raise ApiError("""%s.checkValid: position:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('regions')
    values = dataDict.get('resonanceSerials')
    value = dataDict.get('stripSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: stripSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    if (value is None):
      raise ApiError("""%s.checkValid: unit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (value == 'number')):
      raise ApiError("""%s.checkValid: unit:
       unit constraint inteisyty_unit_is_number violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    value = dataDict.get('width')
    if (value is None):
      raise ApiError("""%s.checkValid: width:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('axisPositionGroup')
    value = dataDict.get('axisWidthGroup')
    values = dataDict.get('resonances')
    value = dataDict.get('spectrumDisplay')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumDisplay:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripAxes')

  connectPositionTo = Axis.connectPositionTo

  connectTo = Axis.connectTo

  connectWidthTo = Axis.connectWidthTo

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  disconnect = Axis.disconnect

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllResonances = Axis.findAllResonances

  findAllStripAxes = Axis.findAllStripAxes

  findAllStrips = Axis.findAllStrips

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstResonance = Axis.findFirstResonance

  findFirstStrip = Axis.findFirstStrip

  findFirstStripAxis = Axis.findFirstStripAxis
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.IntensityAxis
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData

  getAxisPositionGroup = Axis.getAxisPositionGroup

  getAxisWidthGroup = Axis.getAxisWidthGroup
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.IntensityAxis
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.IntensityAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.IntensityAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        ll = list()
        objKey = fullKey[-2]
        ll.append(objKey)
        if (objKey is not None):
          objKey = fullKey[-1]
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        obj3 = obj2.__dict__.get('axes').get(objKey)
        if (isinstance(obj3, IntensityAxis)):
          result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getCode(self):
    """
    Get for ccpnmr.gui.Task.IntensityAxis.code
    """
    dataDict = self.__dict__
    result = dataDict.get('code')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = Axis.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = Axis.getLocalKey

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = Axis.getParent

  getPosition = Axis.getPosition

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRegions = Axis.getRegions

  getResonanceSerials = Axis.getResonanceSerials

  getResonances = Axis.getResonances

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSpectrumDisplay = Axis.getSpectrumDisplay

  getStripAxes = Axis.getStripAxes

  getStripSerial = Axis.getStripSerial

  getStrips = Axis.getStrips

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnit(self):
    """
    Get for ccpnmr.gui.Task.IntensityAxis.unit
    """
    dataDict = self.__dict__
    result = dataDict.get('unit')
    return result

  getWidth = Axis.getWidth

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeRegion = Axis.removeRegion

  removeResonance = Axis.removeResonance

  removeResonanceSerial = Axis.removeResonanceSerial
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.IntensityAxis
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setAxisPositionGroup = Axis.setAxisPositionGroup

  setAxisWidthGroup = Axis.setAxisWidthGroup

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setCode(self, value):
    """
    Set for ccpnmr.gui.Task.IntensityAxis.code
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setCode:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setCode:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setCode:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setCode:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('code')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setCode:
         cannot set code, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setCode:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (value == 'intensity')):
            raise ApiError("""%s.setCode:
             code constraint intensity_axis_code_is_intensity violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['code'] = value

    # doNotifies

  setPosition = Axis.setPosition

  setRegions = Axis.setRegions

  setResonanceSerials = Axis.setResonanceSerials

  setResonances = Axis.setResonances

  setStripAxes = Axis.setStripAxes

  setStripSerial = Axis.setStripSerial
  
  def setUnit(self, value):
    """
    Set for ccpnmr.gui.Task.IntensityAxis.unit
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('unit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setUnit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (value == 'number')):
            raise ApiError("""%s.setUnit:
             unit constraint inteisyty_unit_is_number violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['unit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnit, self.setUnit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setWidth = Axis.setWidth

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedResonances = Axis.sortedResonances

  sortedStripAxes = Axis.sortedStripAxes

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  code = property(getCode, setCode, None,
  r"""
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  position = Axis.position

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  regions = Axis.regions

  resonanceSerials = Axis.resonanceSerials

  stripSerial = Axis.stripSerial
  
  unit = property(getUnit, setUnit, None,
  r"""
  """)

  width = Axis.width

  axisPositionGroup = Axis.axisPositionGroup

  axisWidthGroup = Axis.axisWidthGroup

  parent = Axis.parent

  resonances = Axis.resonances

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  spectrumDisplay = Axis.spectrumDisplay

  stripAxes = Axis.stripAxes

  strips = Axis.strips

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.IntensityAxis', IntensityAxis)

###############################################################################
class FrequencyAxis(Axis):
  r"""Nmr frequency axis, with ppm (increasing to teh left), Hz, and point 
values
  """
  #   from data model element ccpnmr.gui.Task.FrequencyAxis
  _metaclass = metaPackage.getElement('FrequencyAxis')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'code', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'position', 'qualifiedName', 'regions', 'resonanceSerials', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'parent', 'resonances', 'root', 'spectrumDisplay', 'stripAxes', 'strips', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.FrequencyAxis
    """
    dataDict = self.__dict__
    dataDict['spectrumDisplay'] = parent
    if (not isinstance(parent, SpectrumDisplay)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['code'] = None
      dataDict['position'] = 1.0
      dataDict['regions'] = list()
      dataDict['resonanceSerials'] = list()
      dataDict['stripSerial'] = 0
      dataDict['unit'] = 'ppm'
      dataDict['width'] = 10.0
      dataDict['axisPositionGroup'] = None
      dataDict['axisWidthGroup'] = None
      dataDict['resonances'] = set()
      dataDict['stripAxes'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.FrequencyAxis', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.FrequencyAxis.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('axes')
        ll = list()
        objKey = dataDict.get('code')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('stripSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['code', 'stripSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        
        
        if self.resonances:
          self.resonanceSerials = [x.serial for x in self.resonances]
        else:
          nmrProject = self.topObject.nmrProject
          if nmrProject is not None:
            ll = [nmrProject.findFirstResonance(serial=x) for x in self.resonanceSerials]
            self.resonances = [x for x in ll if x is not None]

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      stripSerial = self.stripSerial
      if stripSerial:
        strip = self.spectrumDisplay.findFirstStrip(serial=stripSerial)
        if strip:
          sa = strip.newStripAxis(axis=self)
          objectsCreated.add(sa)
      else:
        for strip in self.spectrumDisplay.strips:
          sa = strip.newStripAxis(axis=self)
          objectsCreated.add(sa)

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.FrequencyAxis:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    spectrumDisplay = self.spectrumDisplay
    strip = spectrumDisplay.findFirstStrip(serial=self.stripSerial)
    if not (spectrumDisplay in objsToBeDeleted or (strip and strip in objsToBeDeleted)):
      raise ApiError("Axes cannot be deleted independently")
    
    
    axisPositionGroup = dataDict.get('axisPositionGroup')
    if (axisPositionGroup is not None):
      if (not (axisPositionGroup in objsToBeDeleted)):
        backlink = axisPositionGroup.__dict__.get('axes')
        key = (axisPositionGroup, 'axes')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 2):
          objsToBeDeleted.add(axisPositionGroup)
          objsToBeChecked.append(axisPositionGroup)
        else:
          linkCounter[key] = nFound

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if (axisWidthGroup is not None):
      if (not (axisWidthGroup in objsToBeDeleted)):
        backlink = axisWidthGroup.__dict__.get('axes')
        key = (axisWidthGroup, 'axes')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 2):
          objsToBeDeleted.add(axisWidthGroup)
          objsToBeChecked.append(axisWidthGroup)
        else:
          linkCounter[key] = nFound

    resonances = dataDict.get('resonances')
    pass
    for resonance in resonances:
      topObject = resonance.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    stripAxes = dataDict.get('stripAxes')
    for stripAxis in stripAxes:
      if (not (stripAxis in objsToBeDeleted)):
        objsToBeDeleted.add(stripAxis)
        objsToBeChecked.append(stripAxis)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.FrequencyAxis:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    axisPositionGroup = dataDict.get('axisPositionGroup')
    if ((axisPositionGroup is not None and not (axisPositionGroup in objsToBeDeleted))):
      axes = axisPositionGroup.__dict__.get('axes')
      axes.remove(self)

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if ((axisWidthGroup is not None and not (axisWidthGroup in objsToBeDeleted))):
      axes = axisWidthGroup.__dict__.get('axes')
      axes.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        displayAxes = resonance.__dict__.get('displayAxes')
        displayAxes.remove(self)

    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeDeleted)):
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = spectrumDisplay.__dict__.get('axes')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.FrequencyAxis:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeUnDeleted)):

      childrenDict = spectrumDisplay.__dict__.get('axes')
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['code', 'stripSerial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

    axisPositionGroup = dataDict.get('axisPositionGroup')
    if ((axisPositionGroup is not None and not (axisPositionGroup in objsToBeUnDeleted))):
      axes = axisPositionGroup.__dict__.get('axes')
      axes.add(self)

    axisWidthGroup = dataDict.get('axisWidthGroup')
    if ((axisWidthGroup is not None and not (axisWidthGroup in objsToBeUnDeleted))):
      axes = axisWidthGroup.__dict__.get('axes')
      axes.add(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeUnDeleted)):
        displayAxes = resonance.__dict__.get('displayAxes')
        displayAxes.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData

  addRegion = Axis.addRegion

  addResonance = Axis.addResonance

  addResonanceSerial = Axis.addResonanceSerial
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.FrequencyAxis
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.FrequencyAxis
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      ll = list()
      objKey = dataDict.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('spectrumDisplay')
        dd = value.__dict__.get('axes')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'spectrumDisplay' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('code')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: code:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: code:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('position')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: position:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: position:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('regions')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: regions:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: regions:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('resonanceSerials')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: resonanceSerials:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: resonanceSerials:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('stripSerial')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripSerial:
         memops.Implementation.NonNegativeInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value >= 0)):
        raise ApiError("""%s.checkValid: stripSerial:
         NonNegativeInt constraint int_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: unit:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: unit:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('width')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: width:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: width:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      value = dataDict.get('axisPositionGroup')
      if (value is not None):
        if (not isinstance(value, AxisPositionGroup)):
          raise ApiError("""%s.checkValid: axisPositionGroup:
           value is not of class ccpnmr.gui.Task.AxisPositionGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('axes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: axisPositionGroup:
           non-reciprocal link axisPositionGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('axisWidthGroup')
      if (value is not None):
        if (not isinstance(value, AxisWidthGroup)):
          raise ApiError("""%s.checkValid: axisWidthGroup:
           value is not of class ccpnmr.gui.Task.AxisWidthGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('axes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: axisWidthGroup:
           non-reciprocal link axisWidthGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('resonances')
      for value in values:
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import Resonance as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.Nmr.Resonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('displayAxes')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link resonances from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('spectrumDisplay')
      if (not isinstance(value, SpectrumDisplay)):
        raise ApiError("""%s.checkValid: spectrumDisplay:
         value is not of class ccpnmr.gui.Task.SpectrumDisplay""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('stripAxes')
      for value in values:
        if (not isinstance(value, StripAxis)):
          raise ApiError("""%s.checkValid: stripAxes:
           value is not of class ccpnmr.gui.Task.StripAxis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('axis')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripAxes:
           non-reciprocal link stripAxes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: stripAxes:
           Link stripAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getStrips()
      for value in values:
        if (not isinstance(value, Strip)):
          raise ApiError("""%s.checkValid: strips:
           value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getOrderedAxes()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: strips:
           non-reciprocal link strips from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('code')
    if (value is None):
      raise ApiError("""%s.checkValid: code:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (value[0].isupper())):
      raise ApiError("""%s.checkValid: code:
       code constraint frequency_axis_code_starts_with_upper_case violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    value = dataDict.get('position')
    if (value is None):
      raise ApiError("""%s.checkValid: position:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('regions')
    values = dataDict.get('resonanceSerials')
    value = dataDict.get('stripSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: stripSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('unit')
    if (value is None):
      raise ApiError("""%s.checkValid: unit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (value in ('ppm', 'Hz', 'point'))):
      raise ApiError("""%s.checkValid: unit:
       unit constraint frequency_unit_is_ppm_or_Hz_or_point violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    value = dataDict.get('width')
    if (value is None):
      raise ApiError("""%s.checkValid: width:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('axisPositionGroup')
    value = dataDict.get('axisWidthGroup')
    values = dataDict.get('resonances')
    value = dataDict.get('spectrumDisplay')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumDisplay:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripAxes')

  connectPositionTo = Axis.connectPositionTo

  connectTo = Axis.connectTo

  connectWidthTo = Axis.connectWidthTo

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  disconnect = Axis.disconnect

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllResonances = Axis.findAllResonances

  findAllStripAxes = Axis.findAllStripAxes

  findAllStrips = Axis.findAllStrips

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstResonance = Axis.findFirstResonance

  findFirstStrip = Axis.findFirstStrip

  findFirstStripAxis = Axis.findFirstStripAxis
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.FrequencyAxis
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData

  getAxisPositionGroup = Axis.getAxisPositionGroup

  getAxisWidthGroup = Axis.getAxisWidthGroup
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.FrequencyAxis
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.FrequencyAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.FrequencyAxis'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        ll = list()
        objKey = fullKey[-2]
        ll.append(objKey)
        if (objKey is not None):
          objKey = fullKey[-1]
          ll.append(objKey)
          if (objKey is not None):
            objKey = tuple(ll)

        obj3 = obj2.__dict__.get('axes').get(objKey)
        if (isinstance(obj3, FrequencyAxis)):
          result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName
  
  def getCode(self):
    """
    Get for ccpnmr.gui.Task.FrequencyAxis.code
    """
    dataDict = self.__dict__
    result = dataDict.get('code')
    return result

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = Axis.getFullKey

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = Axis.getLocalKey

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParent = Axis.getParent

  getPosition = Axis.getPosition

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRegions = Axis.getRegions

  getResonanceSerials = Axis.getResonanceSerials

  getResonances = Axis.getResonances

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSpectrumDisplay = Axis.getSpectrumDisplay

  getStripAxes = Axis.getStripAxes

  getStripSerial = Axis.getStripSerial

  getStrips = Axis.getStrips

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnit(self):
    """
    Get for ccpnmr.gui.Task.FrequencyAxis.unit
    """
    dataDict = self.__dict__
    result = dataDict.get('unit')
    return result

  getWidth = Axis.getWidth

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData

  removeRegion = Axis.removeRegion

  removeResonance = Axis.removeResonance

  removeResonanceSerial = Axis.removeResonanceSerial
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.FrequencyAxis
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setAxisPositionGroup = Axis.setAxisPositionGroup

  setAxisWidthGroup = Axis.setAxisWidthGroup

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData
  
  def setCode(self, value):
    """
    Set for ccpnmr.gui.Task.FrequencyAxis.code
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setCode:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setCode:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setCode:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setCode:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('code')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCode:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setCode:
         cannot set code, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setCode:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (value[0].isupper())):
            raise ApiError("""%s.setCode:
             code constraint frequency_axis_code_starts_with_upper_case violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['code'] = value

    # doNotifies

  setPosition = Axis.setPosition

  setRegions = Axis.setRegions

  setResonanceSerials = Axis.setResonanceSerials

  setResonances = Axis.setResonances

  setStripAxes = Axis.setStripAxes

  setStripSerial = Axis.setStripSerial
  
  def setUnit(self, value):
    """
    Set for ccpnmr.gui.Task.FrequencyAxis.unit
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('unit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnit:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setUnit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (value in ('ppm', 'Hz', 'point'))):
            raise ApiError("""%s.setUnit:
             unit constraint frequency_unit_is_ppm_or_Hz_or_point violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['unit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnit, self.setUnit,
                      undoArgs=(currentValue,), redoArgs=(value,))

  setWidth = Axis.setWidth

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedResonances = Axis.sortedResonances

  sortedStripAxes = Axis.sortedStripAxes

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className
  
  code = property(getCode, setCode, None,
  r"""
  """)

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  position = Axis.position

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  regions = Axis.regions

  resonanceSerials = Axis.resonanceSerials

  stripSerial = Axis.stripSerial
  
  unit = property(getUnit, setUnit, None,
  r"""
  """)

  width = Axis.width

  axisPositionGroup = Axis.axisPositionGroup

  axisWidthGroup = Axis.axisWidthGroup

  parent = Axis.parent

  resonances = Axis.resonances

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  spectrumDisplay = Axis.spectrumDisplay

  stripAxes = Axis.stripAxes

  strips = Axis.strips

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.FrequencyAxis', FrequencyAxis)

###############################################################################
class GenericModule(Module):
  r"""
  """
  #   from data model element ccpnmr.gui.Task.GenericModule
  _metaclass = metaPackage.getElement('GenericModule')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'moduleType', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'windowId', 'guiTask', 'parameters', 'parent', 'root', 'topObject', 'window',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.GenericModule
    """
    dataDict = self.__dict__
    dataDict['guiTask'] = parent
    if (not isinstance(parent, GuiTask)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['moduleType'] = None
      dataDict['name'] = None
      dataDict['windowId'] = None
      dataDict['parameters'] = {}
      dataDict['window'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.GenericModule', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.GenericModule.__init__")
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('modules')
        objKey = dataDict.get('name')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['name'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.GenericModule:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    parameters = dataDict.get('parameters').values()
    for parameter in parameters:
      if (not (parameter in objsToBeDeleted)):
        objsToBeDeleted.add(parameter)
        objsToBeChecked.append(parameter)

    window = dataDict.get('window')
    if (window is not None):
      topObject = window.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.GenericModule:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    window = dataDict.get('window')
    if ((window is not None and not (window in objsToBeDeleted))):
      modules = window.__dict__.get('modules')
      modules.remove(self)

    guiTask = dataDict.get('guiTask')
    if (not (guiTask in objsToBeDeleted)):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = guiTask.__dict__.get('modules')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.GenericModule:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    guiTask = dataDict.get('guiTask')

    childrenDict = guiTask.__dict__.get('modules')
    objKey = dataDict.get('name')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['name'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    window = dataDict.get('window')
    if ((window is not None and not (window in objsToBeUnDeleted))):
      modules = window.__dict__.get('modules')
      modules.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.GenericModule
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('parameters').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.GenericModule
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('guiTask')
        dd = value.__dict__.get('modules')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'guiTask' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('moduleType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: moduleType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('name')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: name:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('windowId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: windowId:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: windowId:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      value = dataDict.get('guiTask')
      if (not isinstance(value, GuiTask)):
        raise ApiError("""%s.checkValid: guiTask:
         value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('parameters').values()
      for value in values:
        if (not isinstance(value, Parameter)):
          raise ApiError("""%s.checkValid: parameters:
           value is not of class ccpnmr.gui.Task.Parameter""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('module')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: parameters:
           non-reciprocal link parameters from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('window')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccpnmr.gui.Window import Window as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: window:
           value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('modules')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: window:
           non-reciprocal link window from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('moduleType')
    if (value is None):
      raise ApiError("""%s.checkValid: moduleType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('name')
    if (value is None):
      raise ApiError("""%s.checkValid: name:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('windowId')
    # check roles
    value = dataDict.get('guiTask')
    if (value is None):
      raise ApiError("""%s.checkValid: guiTask:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('parameters').values()
    value = dataDict.get('window')
    if (value is not None):
      if (not (value.guiTask is self.guiTask)):
        raise ApiError("""%s.checkValid: window:
         window constraint all_window_modules_must_belong_to_window_task violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

  def copyToTask(self, newTask, nmrProject):
    """
    NOT IMPLEMENTED. These functoins are not in use.
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.copyToTask:
       called on deleted object""" % self.qualifiedName
      )

    raise NotImplementedError("copyToTask function is not in use")

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete
  
  def disconnect(self):
    """
    NOT IMPLEMENTED, these functions are not used.
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.disconnect:
       called on deleted object""" % self.qualifiedName
      )

    raise NotImplementedError("disconnect function is not in use")

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllParameters = Module.findAllParameters

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstParameter = Module.findFirstParameter
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.GenericModule
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.GenericModule
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.GenericModule'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.GenericModule'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('modules').get(objKey)
      if (isinstance(obj2, GenericModule)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getDetails = Module.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = Module.getFullKey

  getGuiTask = Module.getGuiTask

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = Module.getLocalKey

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getModuleType(self):
    """
    Get for ccpnmr.gui.Task.GenericModule.moduleType
    """
    dataDict = self.__dict__
    result = dataDict.get('moduleType')
    return result

  getName = Module.getName

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParameters = Module.getParameters

  getParent = Module.getParent

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getWindow = Module.getWindow

  getWindowId = Module.getWindowId

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newParameter = Module.newParameter
  
  def reconnect(self, window):
    """
    NOT IMPLEMENTED, these functions are not used.
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.reconnect:
       called on deleted object""" % self.qualifiedName
      )

    raise NotImplementedError("reconnect function is not in use")

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.GenericModule
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setDetails = Module.setDetails
  
  def setModuleType(self, value):
    """
    Set for ccpnmr.gui.Task.GenericModule.moduleType
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setModuleType:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setModuleType:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setModuleType:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setModuleType:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('moduleType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setModuleType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setModuleType:
         cannot set moduleType, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setModuleType:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['moduleType'] = value

    # doNotifies

  setName = Module.setName

  setWindow = Module.setWindow

  setWindowId = Module.setWindowId

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedParameters = Module.sortedParameters

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = Module.details

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  moduleType = property(getModuleType, setModuleType, None,
  r"""Type of module represented by Object.Defines the graphical 
  implementaiton to use to display it.
  """)

  name = Module.name

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  windowId = Module.windowId

  guiTask = Module.guiTask

  parameters = Module.parameters

  parent = Module.parent

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  window = Module.window

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.GenericModule', GenericModule)

###############################################################################
class SpectrumDisplay(Module):
  r"""Abstract superclass for All SpectrumDisplay.
Either resonancGroup or 
resonanceGroupSerial can be passed in at creation time
  """
  #   from data model element ccpnmr.gui.Task.SpectrumDisplay
  _metaclass = metaPackage.getElement('SpectrumDisplay')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'is1d', 'isDeleted', 'metaclass', 'moduleType', 'name', 'packageName', 'packageShortName', 'positions', 'qualifiedName', 'resonanceGroupSerial', 'stripCount', 'stripDirection', 'stripType', 'units', 'widths', 'windowId', 'axes', 'guiTask', 'orderedAxes', 'orderedStrips', 'parameters', 'parent', 'resonanceGroup', 'root', 'spectrumViews', 'strips', 'topObject', 'window',)

  __init__ = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.__init__

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addOrderedAxis(self, value):
    """
    Add for ccpnmr.gui.Task.SpectrumDisplay.orderedAxes
    """
    dataDict = self.__dict__
    if (not isinstance(value, Axis)):
      raise ApiError("""%s.addOrderedAxis:
       value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedAxes()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addOrderedAxis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addOrderedAxis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addOrderedAxis:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addOrderedAxis:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setOrderedAxes(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addOrderedAxis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedAxes, self.addOrderedAxis,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addOrderedStrip(self, value):
    """
    Add for ccpnmr.gui.Task.SpectrumDisplay.orderedStrips
    """
    dataDict = self.__dict__
    if (not isinstance(value, Strip)):
      raise ApiError("""%s.addOrderedStrip:
       value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedStrips()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addOrderedStrip:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addOrderedStrip:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addOrderedStrip:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addOrderedStrip:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setOrderedStrips(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addOrderedStrip')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedStrips, self.addOrderedStrip,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addPosition(self, value):
    """
    Add for ccpnmr.gui.Task.SpectrumDisplay.positions
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.addPosition:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.addPosition:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getPositions()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addPosition:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addPosition:
       called on deleted object""" % self.qualifiedName
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setPositions(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addPosition')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositions, self.addPosition,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addUnit(self, value):
    """
    Add for ccpnmr.gui.Task.SpectrumDisplay.units
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.addUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.addUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.addUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.addUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getUnits()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addUnit:
       called on deleted object""" % self.qualifiedName
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setUnits(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnits, self.addUnit,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def addWidth(self, value):
    """
    Add for ccpnmr.gui.Task.SpectrumDisplay.widths
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.addWidth:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.addWidth:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getWidths()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addWidth:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addWidth:
       called on deleted object""" % self.qualifiedName
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setWidths(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addWidth')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWidths, self.addWidth,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  checkAllValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkAllValid

  checkValid = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.checkValid
  
  def copyToTask(self, newTask, nmrProject):
    """
    Copy Module to target task.  NOT IN USE
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.copyToTask:
       called on deleted object""" % self.qualifiedName
      )

    from ccpnmodel.ccpncore.lib import CopyData
    # 
    newModule = CopyData.copySubTree(self, newTask)
    
    # remove links that cannot be fixed
    newModule.resonanceGroupSerial = 0
    for axis in newModule.axes:
      axis.resonanceSerials = ()
    for spectrumView in newModule.spectrumViews:
      for peakListView in spectrumView.peakListViews:
        for peakView in peakListView.peakViews:
          peakView.delete()
    
    # reconnect where possible
    for spectrumView in newModule.sortedSpectrumViews:
      newExperiment = nmrProject.findFirstExperiment(name=spectrumView.experimentName)
      if newExperiment is not None:
        newDataSource = newExperiment.findFirstDataSource(serial=self.dataSourceSerial)
        if newDataSource is None:
          # Assume that the serials are different, and take the first DataSource you find
          # NBNB TBD Heuristic, will break for multiple DataSources
          newDataSource = newExperiment.findFirstDataSource()
          if newDataSource is not None:
            oldSpectrumView = spectrumView
            spectrumView = CopyData.copySubTree(spectrumView, newTask, topObjectParameters={'dataSourceSerial':newDataSource.serial})
            oldSpectrumView.delete()
            peakListViews = spectrumView.sortedPeakListViews()
            peakLists = newDataSource.sortedPeakLists()
            if any(x for x in peakListViews if newDataSource.findFirstPeakList(x.peakListSerial) is None):
              # Peak list serials do not match 
              if peakLists and len(peakListViews) == 1:
                # This is the only case we want to deal with for now
                newPeakListView = CopyData.copySubTree(peakListViews[0], spectrumView, topObjectParameters={'peakListSerial':peakLists[0].serial})

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete
  
  def disconnect(self):
    """
    Disconnect module from NmrProject and windows, for inactivation,
    storage, and exchange. NOT IN USE
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.disconnect:
       called on deleted object""" % self.qualifiedName
      )

    # disconnect windows
    window = self.window
    if window is not None:
      self.windowId= window.serial
      self.window = None
    
    # disconnect resonanceGroup
    resonanceGroup = self.resonanceGroup
    if resonanceGroup is not None:
      self.resonanceGroupSerial = resonanceGroup.serial
    self.resonanceGroup = None
    
    # disconnect Axis.resonances
    for axis in self.axes:
      axis.resonanceSerials = [x.serial for x in axis.resonances]
      axis.resonances = ()
    
    # Disconnect SpectrumView and descendants
    for spectrumView in self.spectrumViews:
      dataSource = spectrumView.dataSource
      spectrumView.__dict__['dataSource'] = None
      if dataSource is not None:
        spectrumView.experimentType = dataSource.experiment.experimentType
      
      for peakListView in spectrumView.peakListViews:
        peakListView.peakList = None
        for peakView in peakListView.peakViews:
          peakView.delete()
    
    undo = self.root._undo
    if undo is not None:
       undo.newItem(self.reconnect, self.disconnect, undoArgs=(window,))

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData
  
  def findAllAxes(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumDisplay.axes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('axes').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('axes').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllOrderedAxes(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumDisplay.orderedAxes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedAxes()
      result = list(currentValues)

    else:
      currentValues = self.getOrderedAxes()
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result
  
  def findAllOrderedStrips(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumDisplay.orderedStrips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedStrips()
      result = list(currentValues)

    else:
      currentValues = self.getOrderedStrips()
      result = list()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.append(v)

    return result

  findAllParameters = Module.findAllParameters
  
  def findAllSpectrumViews(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumDisplay.spectrumViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('spectrumViews').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('spectrumViews').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'displayNegativeContours', 'displayPositiveContours', 'experimentType', 'isDisplayed', 'negativeContourBase', 'negativeContourColour', 'negativeContourCount', 'negativeContourFactor', 'positiveContourBase', 'positiveContourColour', 'positiveContourCount', 'positiveContourFactor', 'sliceColour', 'spectrumName', 'stripSerial', 'dataSource', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result
  
  def findAllStrips(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.SpectrumDisplay.strips
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findAllStrips:
     findAllStrips should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def findAxis(self, value):
    """
    Find connected axis that has exactly the input axis code.
    """
    dataDict = self.__dict__
    try:
      index = self.axisOrder.index(value)
      result = self.orderedAxes[index]
    except ValueError:
      result = None
    return result

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAxis(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumDisplay.axes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('axes').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      ll = list()
      objKey = conditions.get('code')
      ll.append(objKey)
      if (objKey is not None):
        objKey = conditions.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is not None):
        result = dataDict.get('axes').get(objKey)

        if (nConditions <= 2):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('axes').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstOrderedAxis(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumDisplay.orderedAxes
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedAxes()
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = self.getOrderedAxes()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'code', 'position', 'stripSerial', 'unit', 'width', 'axisPositionGroup', 'axisWidthGroup', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstOrderedStrip(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumDisplay.orderedStrips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedStrips()
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = self.getOrderedStrips()
      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result

  findFirstParameter = Module.findFirstParameter
  
  def findFirstSpectrumView(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumDisplay.spectrumViews
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('spectrumViews').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      ll = list()
      objKey = conditions.get('spectrumName')
      ll.append(objKey)
      if (objKey is not None):
        objKey = conditions.get('stripSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      if (objKey is not None):
        result = dataDict.get('spectrumViews').get(objKey)

        if (nConditions <= 2):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('spectrumViews').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'displayNegativeContours', 'displayPositiveContours', 'experimentType', 'isDisplayed', 'negativeContourBase', 'negativeContourColour', 'negativeContourCount', 'negativeContourFactor', 'positiveContourBase', 'positiveContourColour', 'positiveContourCount', 'positiveContourFactor', 'sliceColour', 'spectrumName', 'stripSerial', 'dataSource', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def findFirstStrip(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.SpectrumDisplay.strips
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findFirstStrip:
     findFirstStrip should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxes(self):
    """
    Get for ccpnmr.gui.Task.SpectrumDisplay.axes
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('axes').values()
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.SpectrumDisplay
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.SpectrumDisplay'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.SpectrumDisplay'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('modules').get(objKey)
      if (isinstance(obj2, SpectrumDisplay)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getDetails = Module.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = Module.getFullKey

  getGuiTask = Module.getGuiTask

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor
  
  def getIs1d(self):
    """
    getter for derived attribute is1d
    """
    dataDict = self.__dict__
    result = (self.axisCodes and self.axisCodes[1] == 'intensity')
    return result

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = Module.getLocalKey

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass
  
  def getModuleType(self):
    """
    Get for ccpnmr.gui.Task.SpectrumDisplay.moduleType
    """
    dataDict = self.__dict__
    result = dataDict.get('moduleType')
    return result

  getName = Module.getName
  
  def getOrderedAxes(self):
    """
    getter for derived link orderedAxes
    """
    dataDict = self.__dict__
    axisOrder = self.axisOrder
    stripDirection = self.stripDirection
    if stripDirection is None:
      result = tuple(self.findFirstAxis(code=x) for x in axisOrder)
    else:
      result = []
      stripSerial = self.findFirstStrip(index=0).serial
      index = 'XY'.index(stripDirection)
      for ii,code in enumerate(axisOrder):
        if ii == index:
          result.append(self.findFirstAxis(code=code))
        else:
          result.append(self.findFirstAxis(code=code, stripSerial=stripSerial))
      result = tuple(result)
    return result
  
  def getOrderedStrips(self):
    """
    getter for derived link orderedStrips
    """
    dataDict = self.__dict__
    dd = dict((x.index, x) for x in self.strips)
    result = tuple(dd[x] for x in sorted(dd))
    return result

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParameters = Module.getParameters

  getParent = Module.getParent
  
  def getPositions(self):
    """
    getter for derived attribute positions
    """
    dataDict = self.__dict__
    result = tuple(x.position for x in self.orderedAxes)
    return result

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName
  
  def getResonanceGroup(self):
    """
    Get for ccpnmr.gui.Task.SpectrumDisplay.resonanceGroup
    """
    dataDict = self.__dict__
    result = dataDict.get('resonanceGroup')
    return result
  
  def getResonanceGroupSerial(self):
    """
    Get for ccpnmr.gui.Task.SpectrumDisplay.resonanceGroupSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('resonanceGroupSerial')
    return result

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot
  
  def getSpectrumViews(self):
    """
    Get for ccpnmr.gui.Task.SpectrumDisplay.spectrumViews
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('spectrumViews').values()
    result = frozenset(tempVar)
    return result
  
  def getStripCount(self):
    """
    getter for derived attribute stripCount
    """
    dataDict = self.__dict__
    result = len(self.strips)
    return result
  
  def getStripDirection(self):
    """
    Get for ccpnmr.gui.Task.SpectrumDisplay.stripDirection
    """
    dataDict = self.__dict__
    result = dataDict.get('stripDirection')
    return result
  
  def getStripType(self):
    """
    Get for ccpnmr.gui.Task.SpectrumDisplay.stripType
    """
    dataDict = self.__dict__
    result = dataDict.get('stripType')
    return result
  
  def getStrips(self):
    """
    Get for ccpnmr.gui.Task.SpectrumDisplay.strips
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getStrips:
     getStrips should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject
  
  def getUnits(self):
    """
    getter for derived attribute units
    """
    dataDict = self.__dict__
    result = tuple(x.unit for x in self.orderedAxes)
    return result
  
  def getWidths(self):
    """
    getter for derived attribute widths
    """
    dataDict = self.__dict__
    result = tuple(x.width for x in self.orderedAxes)
    return result

  getWindow = Module.getWindow

  getWindowId = Module.getWindowId

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newFidAxis(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.FidAxis
    """
    return FidAxis(self, **attrlinks)
  
  def newFrequencyAxis(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.FrequencyAxis
    """
    return FrequencyAxis(self, **attrlinks)
  
  def newIntensityAxis(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.IntensityAxis
    """
    return IntensityAxis(self, **attrlinks)

  newParameter = Module.newParameter
  
  def newSampledAxis(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.SampledAxis
    """
    return SampledAxis(self, **attrlinks)
  
  def newSpectrumView(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.SpectrumView
    """
    return SpectrumView(self, **attrlinks)
  
  def reconnect(self, window):
    """
    Reconnect Module to Nmr data and window, assuming that the NmrProject
    data fit. Data that do not fit are removed (except for SpectrumViews)  
    NOT IN USE
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.reconnect:
       called on deleted object""" % self.qualifiedName
      )

    # Reset window ID.
    self.windowId = window.serial
    
    # Reconnect NMR data
    nmrProject = self.task.nmrProject
    
    resonanceGroup = nmrProject.findFirstResonanceGroup(serial=self.resonanceGroupSerial)
    if resonanceGroup is None:
      self.resonanceGroupSerial = None
    
    for axis in self.axes:
      ll = [nmrProject.findFirstResonance(serial=x) for x in axis.resonanceSerials]
      resonances = [x for x in ll if x is not None]
      axis.resonances = resonances
      axis.resonanceSerials = [x.serial for x in resonances]
    
    for spectrumView in self.spectrumViews:
      for experiment in nmrProject.sortedExperiments():
        dataSources = experiment.findAllDataSources(name=spectrumView.spectrumName)
        if dataSources:
          dataSource = list(dataSources)[0]
          spectrumView.dataSource = dataSource
          break
      else:
        experiment = nmrProject.findFirstExperiment(experimentType=spectrumView.experimentType)
        if experiment is not None:
          dataSource = experiment.findFirstDataSource()
          spectrumView.__dict__['dataSource'] = dataSource
    
          # NBNB TBD We must remap dimensionOrdering, 
          # in case dimensions are ordered differnetly in the dataSource
    
      for peakListView in spectrumView.peakListViews:
        peakList = dataSource.findFirstPeakList(serial=peakListView.peakListSerial)
        if peakList is None:
          peakListView.delete()
        else:
          peakListView.peakList = peakList
    
    undo = self.root._undo
    if undo is not None:
       undo.newItem(self.disconnect, self.reconnect, redoArgs=(window,))

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeOrderedAxis(self, value):
    """
    Remove for ccpnmr.gui.Task.SpectrumDisplay.orderedAxes
    """
    dataDict = self.__dict__
    if (not isinstance(value, Axis)):
      raise ApiError("""%s.removeOrderedAxis:
       value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedAxes()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeOrderedAxis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeOrderedAxis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeOrderedAxis:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeOrderedAxis:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setOrderedAxes(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeOrderedAxis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedAxes, self.removeOrderedAxis,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeOrderedStrip(self, value):
    """
    Remove for ccpnmr.gui.Task.SpectrumDisplay.orderedStrips
    """
    dataDict = self.__dict__
    if (not isinstance(value, Strip)):
      raise ApiError("""%s.removeOrderedStrip:
       value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedStrips()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeOrderedStrip:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeOrderedStrip:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeOrderedStrip:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeOrderedStrip:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setOrderedStrips(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeOrderedStrip')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedStrips, self.removeOrderedStrip,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removePosition(self, value):
    """
    Remove for ccpnmr.gui.Task.SpectrumDisplay.positions
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.removePosition:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.removePosition:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getPositions()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removePosition:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removePosition:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removePosition:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setPositions(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removePosition')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositions, self.removePosition,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeUnit(self, value):
    """
    Remove for ccpnmr.gui.Task.SpectrumDisplay.units
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeUnit:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.removeUnit:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.removeUnit:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.removeUnit:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getUnits()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeUnit:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeUnit:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setUnits(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnits, self.removeUnit,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def removeWidth(self, value):
    """
    Remove for ccpnmr.gui.Task.SpectrumDisplay.widths
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
      pass
    elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.removeWidth:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.removeWidth:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getWidths()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeWidth:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeWidth:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeWidth:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setWidths(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeWidth')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWidths, self.removeWidth,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  def resetAxisOrder(self):
    """
    Reset axisOrder to original value
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.resetAxisOrder:
       called on deleted object""" % self.qualifiedName
      )

    self.axisOrder = self.axisCodes

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setDetails = Module.setDetails
  
  def setModuleType(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumDisplay.moduleType
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setModuleType:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setModuleType:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setModuleType:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setModuleType:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('moduleType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setModuleType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setModuleType:
         cannot set moduleType, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setModuleType:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['moduleType'] = value

    # doNotifies

  setName = Module.setName
  
  def setOrderedAxes(self, values):
    """
    setter for derived link orderedAxes
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setOrderedAxes:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, Axis)):
        raise ApiError("""%s.setOrderedAxes:
         value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedAxes()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOrderedAxes:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOrderedAxes:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setOrderedAxes:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      erroneous = list(x for x in values if x.spectrumDisplay is not self)
      if erroneous:
        raise ValueError("Axes %s do not belong to %s" % (erroneous, self))
      else:
        self.axisOrder = [x.code for x in values]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOrderedAxes')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedAxes, self.setOrderedAxes,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setOrderedStrips(self, values):
    """
    setter for derived link orderedStrips
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setOrderedStrips:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, Strip)):
        raise ApiError("""%s.setOrderedStrips:
         value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedStrips()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOrderedStrips:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOrderedStrips:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setOrderedStrips:
         an object in values is deleted""" % self.qualifiedName
        )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      stripCount = self.stripCount
      if len(value) != stripCount or len(set(value)) != stripCount:
        raise ValueError("Number of orderedStrips %s differs from number of strips %s" % (len(value), stripCount))
      for ii, strip in enumerate(value):
        strip.__dict__['index'] = ii
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOrderedStrips')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setOrderedStrips, self.setOrderedStrips,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setPositions(self, values):
    """
    setter for derived attribute positions
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        replaceIndex = values.index(value)
        values[replaceIndex] = castValue
        value = castValue
      else:
        raise ApiError("""%s.setPositions:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setPositions:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getPositions()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPositions:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPositions:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      for ii,axis in enumerate(self.orderedAxes):
        axis.position = values[ii]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPositions')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setPositions, self.setPositions,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setResonanceGroup(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumDisplay.resonanceGroup
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import ResonanceGroup as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setResonanceGroup:
         value is not of class ccp.nmr.Nmr.ResonanceGroup""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonanceGroup')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      if (value is not None):
        topObject = value.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      if (currentValue is not None):
        topObject = currentValue.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonanceGroup:
         called with deleted value""" % self.qualifiedName
        )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.setResonanceGroup:
           Link resonanceGroup between objects from separate partitions
           - ccpnmr.gui.Task.GuiTask.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('spectrumDisplays')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonanceGroup:
         Read link 'resonanceGroup' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('spectrumDisplays')
      newSelves.add(self)

    dataDict['resonanceGroup'] = value
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceGroup, self.setResonanceGroup,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setResonanceGroupSerial(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumDisplay.resonanceGroupSerial
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.setResonanceGroupSerial:
         memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setResonanceGroupSerial:
         PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonanceGroupSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceGroupSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceGroupSerial:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      pass

    dataDict['resonanceGroupSerial'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceGroupSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setResonanceGroupSerial, self.setResonanceGroupSerial,
                      undoArgs=(currentValue,), redoArgs=(value,))

  def setStripDirection(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumDisplay.stripDirection
    """
    dataDict = self.__dict__
    if (not (value in ['X', 'Y'])):
      raise ApiError("""%s.setStripDirection:
       ccpnmr.gui.Task.StripDirection input is not in enumeration ['X', 'Y']""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setStripDirection:
       StripDirection constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('stripDirection')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStripDirection:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setStripDirection:
         cannot set stripDirection, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setStripDirection:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['stripDirection'] = value

    # doNotifies
  
  def setStripType(self, value):
    """
    Set for ccpnmr.gui.Task.SpectrumDisplay.stripType
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setStripType:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setStripType:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setStripType:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setStripType:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('stripType')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStripType:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (value == currentValue):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setStripType:
         cannot set stripType, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setStripType:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['stripType'] = value

    # doNotifies
  
  def setUnits(self, values):
    """
    setter for derived link units
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setUnits:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setUnits:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setUnits:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setUnits:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getUnits()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUnits:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnits:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      for ii,axis in enumerate(self.orderedAxes):
        axis.unit = values[ii]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUnits')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setUnits, self.setUnits,
                      undoArgs=(currentValues,), redoArgs=(values,))

  def setWidths(self, values):
    """
    setter for derived attribute widths
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
        pass
      elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
        replaceIndex = values.index(value)
        values[replaceIndex] = castValue
        value = castValue
      else:
        raise ApiError("""%s.setWidths:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setWidths:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getWidths()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWidths:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWidths:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      for ii,axis in enumerate(self.orderedAxes):
        axis.width = values[ii]
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWidths')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setWidths, self.setWidths,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setWindow = Module.setWindow

  setWindowId = Module.setWindowId

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID
  
  def sortedAxes(self):
    """
    Sorted for ccpnmr.gui.Task.SpectrumDisplay.axes
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('axes')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedParameters = Module.sortedParameters
  
  def sortedSpectrumViews(self):
    """
    Sorted for ccpnmr.gui.Task.SpectrumDisplay.spectrumViews
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('spectrumViews')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedStrips(self):
    """
    Sorted for ccpnmr.gui.Task.SpectrumDisplay.strips
    """
    dataDict = self.__dict__
    raise ApiError("""%s.sortedStrips:
     sortedStrips should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = Module.details

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor
  
  is1d = property(getIs1d, None, None,
  r"""Is this a 1D display?
  """)

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass
  
  moduleType = property(getModuleType, setModuleType, None,
  r"""
  """)

  name = Module.name

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName
  
  positions = property(getPositions, setPositions, None,
  r"""Axis positions in axis order
  """)

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName
  
  resonanceGroupSerial = property(getResonanceGroupSerial, setResonanceGroupSerial, None,
  r"""Serial number of attached resonanceGroup. Used to store resonanceGroup 
  liink while the task is detached.
  """)
  
  stripCount = property(getStripCount, None, None,
  r"""Numbre of current strips
  """)
  
  stripDirection = property(getStripDirection, setStripDirection, None,
  r"""Strip Direction (if value is 'X' strips are wide and low, if value is 
  'Y', strips are tall and thin.). Value must be either 'X', 'Y'.
  """)
  
  stripType = property(getStripType, setStripType, None,
  r"""Strip type ('Free', or 'Bound')
  """)
  
  units = property(getUnits, setUnits, None,
  r"""Axis units in axis order
  """)
  
  widths = property(getWidths, setWidths, None,
  r"""Axis widths in axis order
  """)

  windowId = Module.windowId
  
  axes = property(getAxes,  None, None,
  r"""child link to class Axis
  """)

  guiTask = Module.guiTask
  
  orderedAxes = property(getOrderedAxes, setOrderedAxes, None,
  r"""
  """)
  
  orderedStrips = property(getOrderedStrips, setOrderedStrips, None,
  r"""Strips in current display order
  """)

  parameters = Module.parameters

  parent = Module.parent
  
  resonanceGroup = property(getResonanceGroup, setResonanceGroup, None,
  r"""ResonanceGroup attached to SpectrumDisplay
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  spectrumViews = property(getSpectrumViews,  None, None,
  r"""child link to class SpectrumView
  """)
  
  strips = property(getStrips,  None, None,
  r"""child link to class Strip
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  window = Module.window

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.SpectrumDisplay', SpectrumDisplay)

###############################################################################
class FreeStrip(Strip):
  r"""Abstract superclass of FreeStrip1d and FreeStripNd
  """
  #   from data model element ccpnmr.gui.Task.FreeStrip
  _metaclass = metaPackage.getElement('FreeStrip')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'axisCodes', 'axisOrder', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'index', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'positions', 'qualifiedName', 'serial', 'units', 'widths', 'orderedAxes', 'parent', 'root', 'spectrumDisplay', 'spectrumViews', 'stripAxes', 'stripSpectrumViews', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.FreeStrip
    """
    dataDict = self.__dict__
    dataDict['spectrumDisplay'] = parent
    if (not isinstance(parent, FreeDisplay)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.FreeDisplay""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['axisCodes'] = list()
      dataDict['axisOrder'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['index'] = None
      dataDict['serial'] = None
      dataDict['stripAxes'] = {}
      dataDict['stripSpectrumViews'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.FreeStrip', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.FreeStrip.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccpnmr.gui.Task.FreeStrip')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('strips')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        
        
        # NB, len(parent.strips) is the number INCLUDING the present one at the poinit the code is executed.
        dataDict['index'] = len(parent.strips) - 1

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      _undo = root._undo
      if _undo is not None:
        _undo.increaseBlocking()
      try:
        for axis in self.spectrumDisplay.axes:
          if axis.stripSerial in (0, self.serial):
            sa = self.newStripAxis(axis=axis)
            objectsCreated.add(sa)
      finally:
        if _undo is not None:
          _undo.decreaseBlocking()

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.FreeStrip:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    spectrumDisplay = self.spectrumDisplay
    if len(spectrumDisplay.strips) <= 1 and spectrumDisplay not in objsToBeDeleted:
      raise ApiError("Cannot delete last strip from a Display")
    else:
      # reset strip indices
      index = self.index
      ii = 0
      for strip in self.spectrumDisplay.orderedStrips:
        if strip is not self:
          strip.__dict__['index'] = ii
          ii += 1
    
      # delete strip-specific objects
      for axis in spectrumDisplay.findAllAxes(stripSerial=self.serial):
        objsToBeChecked.append(axis)
      for view in spectrumDisplay.findAllSpectrumViews(stripSerial=self.serial):
        objsToBeChecked.append(view)
    stripAxes = dataDict.get('stripAxes').values()
    for stripAxis in stripAxes:
      if (not (stripAxis in objsToBeDeleted)):
        objsToBeDeleted.add(stripAxis)
        objsToBeChecked.append(stripAxis)

    stripSpectrumViews = dataDict.get('stripSpectrumViews').values()
    for stripSpectrumView in stripSpectrumViews:
      if (not (stripSpectrumView in objsToBeDeleted)):
        objsToBeDeleted.add(stripSpectrumView)
        objsToBeChecked.append(stripSpectrumView)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.FreeStrip:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = spectrumDisplay.__dict__.get('strips')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.FreeStrip:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeUnDeleted)):

      childrenDict = spectrumDisplay.__dict__.get('strips')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addAxisOrderItem(self, value):
    """
    Add for ccpnmr.gui.Task.FreeStrip.axisOrder
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.addAxisOrderItem:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axisOrder')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAxisOrderItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAxisOrderItem:
       called on deleted object""" % self.qualifiedName
      )

    if (notOverride):
      if (notInConstructor):
        if (value is not None):
          if (not (value in self.axisCodes)):
            raise ApiError("""%s.addAxisOrderItem:
             axisOrder constraint free_axis_order_codes_contained_in_axis_codes violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    undoValues = list(currentValues)
    currentValues.append(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAxisOrderItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.addAxisOrderItem,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  addPosition = Strip.addPosition

  addUnit = Strip.addUnit

  addWidth = Strip.addWidth
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.FreeStrip
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('stripAxes').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('stripSpectrumViews').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.FreeStrip
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('spectrumDisplay')
        dd = value.__dict__.get('strips')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'spectrumDisplay' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('axisCodes')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: axisCodes:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('axisOrder')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: axisOrder:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('index')
      if (value is None):
        raise ApiError("""%s.checkValid: index:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: index:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getPositions()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: positions:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: positions:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: positions:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getUnits()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: units:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: units:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = self.getWidths()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: widths:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: widths:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: widths:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      values = self.getOrderedAxes()
      for value in values:
        if (not isinstance(value, Axis)):
          raise ApiError("""%s.checkValid: orderedAxes:
           value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getStrips()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: orderedAxes:
           non-reciprocal link orderedAxes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedAxes:
           Link orderedAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('spectrumDisplay')
      if (not isinstance(value, FreeDisplay)):
        raise ApiError("""%s.checkValid: spectrumDisplay:
         value is not of class ccpnmr.gui.Task.FreeDisplay""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getSpectrumViews()
      for value in values:
        if (not isinstance(value, SpectrumView)):
          raise ApiError("""%s.checkValid: spectrumViews:
           value is not of class ccpnmr.gui.Task.SpectrumView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getStrips()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: spectrumViews:
           non-reciprocal link spectrumViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: spectrumViews:
           Link spectrumViews between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('stripAxes').values()
      for value in values:
        if (not isinstance(value, StripAxis)):
          raise ApiError("""%s.checkValid: stripAxes:
           value is not of class ccpnmr.gui.Task.StripAxis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('strip')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripAxes:
           non-reciprocal link stripAxes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('stripSpectrumViews').values()
      for value in values:
        if (not isinstance(value, StripSpectrumView)):
          raise ApiError("""%s.checkValid: stripSpectrumViews:
           value is not of class ccpnmr.gui.Task.StripSpectrumView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('strip')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripSpectrumViews:
           non-reciprocal link stripSpectrumViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    if (not (not (self.index and self.spectrumDisplay.stripDirection is None))):
      raise ApiError("""%s.checkValid:
       constraint only_one_strip_in_non_strip_displays violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('axisCodes')
    if (len(values) < 2):
      raise ApiError("""%s.checkValid: axisCodes:
       locard: values must be of length >= 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('axisOrder')
    if (len(values) < 2):
      raise ApiError("""%s.checkValid: axisOrder:
       locard: values must be of length >= 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not (value in self.axisCodes)):
        raise ApiError("""%s.checkValid: axisOrder:
         axisOrder constraint free_axis_order_codes_contained_in_axis_codes violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('spectrumDisplay')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumDisplay:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripAxes').values()
    values = dataDict.get('stripSpectrumViews').values()

  clone = Strip.clone

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllOrderedAxes = Strip.findAllOrderedAxes

  findAllSpectrumViews = Strip.findAllSpectrumViews

  findAllStripAxes = Strip.findAllStripAxes

  findAllStripSpectrumViews = Strip.findAllStripSpectrumViews

  findAxis = Strip.findAxis

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedAxis = Strip.findFirstOrderedAxis

  findFirstSpectrumView = Strip.findFirstSpectrumView

  findFirstStripAxis = Strip.findFirstStripAxis

  findFirstStripSpectrumView = Strip.findFirstStripSpectrumView
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.FreeStrip
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxisCodes(self):
    """
    Get for ccpnmr.gui.Task.FreeStrip.axisCodes
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('axisCodes')
    result = tuple(tempVar)
    return result
  
  def getAxisOrder(self):
    """
    Get for ccpnmr.gui.Task.FreeStrip.axisOrder
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('axisOrder')
    result = tuple(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.FreeStrip
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.FreeStrip'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.FreeStrip'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('strips').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.FreeStrip
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIndex = Strip.getIndex

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.FreeStrip
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getOrderedAxes = Strip.getOrderedAxes

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.FreeStrip.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumDisplay')
    return result

  getPositions = Strip.getPositions

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = Strip.getSerial
  
  def getSpectrumDisplay(self):
    """
    Get for ccpnmr.gui.Task.FreeStrip.spectrumDisplay
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumDisplay')
    return result

  getSpectrumViews = Strip.getSpectrumViews

  getStripAxes = Strip.getStripAxes

  getStripSpectrumViews = Strip.getStripSpectrumViews

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnits = Strip.getUnits

  getWidths = Strip.getWidths

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  moveTo = Strip.moveTo

  newStripAxis = Strip.newStripAxis

  newStripSpectrumView = Strip.newStripSpectrumView

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeAxisOrderItem(self, value):
    """
    Remove for ccpnmr.gui.Task.FreeStrip.axisOrder
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.removeAxisOrderItem:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axisOrder')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAxisOrderItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAxisOrderItem:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAxisOrderItem:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (2 + 1)):
        raise ApiError("""%s.removeAxisOrderItem:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    undoValues = list(currentValues)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAxisOrderItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.removeAxisOrderItem,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  removePosition = Strip.removePosition

  removeUnit = Strip.removeUnit

  removeWidth = Strip.removeWidth

  resetAxisOrder = Strip.resetAxisOrder
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.FreeStrip
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxisCodes(self, values):
    """
    Set for ccpnmr.gui.Task.FreeStrip.axisCodes
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setAxisCodes:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setAxisCodes:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setAxisCodes:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setAxisCodes:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axisCodes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisCodes:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setAxisCodes:
         cannot set axisCodes, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (len(values) < 2):
        raise ApiError("""%s.setAxisCodes:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['axisCodes'] = values

    # doNotifies
  
  def setAxisOrder(self, values):
    """
    Custom setter for axisOrder, to ensure strip axis is not changed for
    multstrip plots
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setAxisOrder:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axisOrder')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAxisOrder:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisOrder:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (len(values) < 2):
        raise ApiError("""%s.setAxisOrder:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        for value in values:
          if (not (value in self.axisCodes)):
            raise ApiError("""%s.setAxisOrder:
             axisOrder constraint free_axis_order_codes_contained_in_axis_codes violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      if len(self.strips) > 1:
        index = 'XY'.index(self.spectrumDisplay.stripDirection)
        if values[index] != self.axisCodes[index]:
          raise ValueError("Cannot change strip axis for multistip display while reordering axes")
      dataDict['axisOrder'] = values
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAxisOrder')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.setAxisOrder,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setIndex = Strip.setIndex

  setOrderedAxes = Strip.setOrderedAxes

  setPositions = Strip.setPositions

  setSerial = Strip.setSerial

  setUnits = Strip.setUnits

  setWidths = Strip.setWidths

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedSpectrumViews = Strip.sortedSpectrumViews

  sortedStripAxes = Strip.sortedStripAxes

  sortedStripSpectrumViews = Strip.sortedStripSpectrumViews

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData
  
  axisCodes = property(getAxisCodes, setAxisCodes, None,
  r"""
  """)
  
  axisOrder = property(getAxisOrder, setAxisOrder, None,
  r"""
  """)

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  index = Strip.index

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  positions = Strip.positions

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = Strip.serial

  units = Strip.units

  widths = Strip.widths

  orderedAxes = Strip.orderedAxes
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for spectrumDisplay
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  spectrumDisplay = property(getSpectrumDisplay,  None, None,
  r"""parent link
  """)

  spectrumViews = Strip.spectrumViews

  stripAxes = Strip.stripAxes

  stripSpectrumViews = Strip.stripSpectrumViews

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.FreeStrip', FreeStrip)

###############################################################################
class BoundStrip(Strip):
  r"""Bound strip for display
  """
  #   from data model element ccpnmr.gui.Task.BoundStrip
  _metaclass = metaPackage.getElement('BoundStrip')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'axisCodes', 'axisOrder', 'ccpnInternalData', 'className', 'fieldNames', 'inConstructor', 'index', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'positions', 'qualifiedName', 'serial', 'units', 'widths', 'orderedAxes', 'parent', 'root', 'spectrumDisplay', 'spectrumViews', 'stripAxes', 'stripSpectrumViews', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.BoundStrip
    """
    dataDict = self.__dict__
    dataDict['spectrumDisplay'] = parent
    if (not isinstance(parent, BoundDisplay)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.BoundDisplay""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['index'] = None
      dataDict['serial'] = None
      dataDict['stripAxes'] = {}
      dataDict['stripSpectrumViews'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.BoundStrip', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.BoundStrip.__init__")
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccpnmr.gui.Task.BoundStrip')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('strips')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        
        
        # NB, len(parent.strips) is the number INCLUDING the present one at the poinit the code is executed.
        dataDict['index'] = len(parent.strips) - 1

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notIsReading):
      
      
      _undo = root._undo
      if _undo is not None:
        _undo.increaseBlocking()
      try:
        for axis in self.spectrumDisplay.axes:
          if axis.stripSerial in (0, self.serial):
            sa = self.newStripAxis(axis=axis)
            objectsCreated.add(sa)
        for view in self.spectrumDisplay.spectrumViews:
          if view.stripSerial in (0, self.serial):
            ssv = self.newStripSpectrumView(spectrumView=view)
            objectsCreated.add(ssv)
      finally:
        if _undo is not None:
          _undo.decreaseBlocking()

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.BoundStrip:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    
    
    spectrumDisplay = self.spectrumDisplay
    if len(spectrumDisplay.strips) <= 1 and spectrumDisplay not in objsToBeDeleted:
      raise ApiError("Cannot delete last strip from a Display")
    else:
      # reset strip indices
      index = self.index
      ii = 0
      for strip in self.spectrumDisplay.orderedStrips:
        if strip is not self:
          strip.__dict__['index'] = ii
          ii += 1
    
      # delete strip-specific objects
      for axis in spectrumDisplay.findAllAxes(stripSerial=self.serial):
        objsToBeChecked.append(axis)
      for view in spectrumDisplay.findAllSpectrumViews(stripSerial=self.serial):
        objsToBeChecked.append(view)
    stripAxes = dataDict.get('stripAxes').values()
    for stripAxis in stripAxes:
      if (not (stripAxis in objsToBeDeleted)):
        objsToBeDeleted.add(stripAxis)
        objsToBeChecked.append(stripAxis)

    stripSpectrumViews = dataDict.get('stripSpectrumViews').values()
    for stripSpectrumView in stripSpectrumViews:
      if (not (stripSpectrumView in objsToBeDeleted)):
        objsToBeDeleted.add(stripSpectrumView)
        objsToBeChecked.append(stripSpectrumView)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.BoundStrip:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = spectrumDisplay.__dict__.get('strips')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.BoundStrip:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    spectrumDisplay = dataDict.get('spectrumDisplay')
    if (not (spectrumDisplay in objsToBeUnDeleted)):

      childrenDict = spectrumDisplay.__dict__.get('strips')
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleUnDelete:
         Key attribute or link not set (from ['serial'])""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        if (childrenDict.get(objKey) is None):
          childrenDict[objKey] = self
        else:
          raise ApiError("""%s._singleUnDelete:
           Could not create, pre-existing object had same key""" % self.qualifiedName
           + ": %s" % (self,)
          )

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addAxisOrderItem(self, value):
    """
    Add for ccpnmr.gui.Task.BoundStrip.axisOrder
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.addAxisOrderItem:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getAxisOrder()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAxisOrderItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAxisOrderItem:
       called on deleted object""" % self.qualifiedName
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setAxisOrder(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAxisOrderItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.addAxisOrderItem,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  addPosition = Strip.addPosition

  addUnit = Strip.addUnit

  addWidth = Strip.addWidth
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.BoundStrip
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('stripAxes').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('stripSpectrumViews').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.BoundStrip
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('spectrumDisplay')
        dd = value.__dict__.get('strips')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'spectrumDisplay' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = self.getAxisCodes()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: axisCodes:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: axisCodes:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = self.getAxisOrder()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: axisOrder:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: axisOrder:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('index')
      if (value is None):
        raise ApiError("""%s.checkValid: index:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: index:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getPositions()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: positions:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: positions:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: positions:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getUnits()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: units:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: units:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = self.getWidths()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: widths:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: widths:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: widths:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      values = self.getOrderedAxes()
      for value in values:
        if (not isinstance(value, Axis)):
          raise ApiError("""%s.checkValid: orderedAxes:
           value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getStrips()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: orderedAxes:
           non-reciprocal link orderedAxes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedAxes:
           Link orderedAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('spectrumDisplay')
      if (not isinstance(value, BoundDisplay)):
        raise ApiError("""%s.checkValid: spectrumDisplay:
         value is not of class ccpnmr.gui.Task.BoundDisplay""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getSpectrumViews()
      for value in values:
        if (not isinstance(value, SpectrumView)):
          raise ApiError("""%s.checkValid: spectrumViews:
           value is not of class ccpnmr.gui.Task.SpectrumView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.getStrips()
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: spectrumViews:
           non-reciprocal link spectrumViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: spectrumViews:
           Link spectrumViews between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('stripAxes').values()
      for value in values:
        if (not isinstance(value, StripAxis)):
          raise ApiError("""%s.checkValid: stripAxes:
           value is not of class ccpnmr.gui.Task.StripAxis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('strip')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripAxes:
           non-reciprocal link stripAxes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('stripSpectrumViews').values()
      for value in values:
        if (not isinstance(value, StripSpectrumView)):
          raise ApiError("""%s.checkValid: stripSpectrumViews:
           value is not of class ccpnmr.gui.Task.StripSpectrumView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('strip')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: stripSpectrumViews:
           non-reciprocal link stripSpectrumViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    if (not (self.axisCodes == self.spectrumDisplay.axisCodes)):
      raise ApiError("""%s.checkValid:
       constraint axiscodes_same_as_parent_display violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (not (self.index and self.spectrumDisplay.stripDirection is None))):
      raise ApiError("""%s.checkValid:
       constraint only_one_strip_in_non_strip_displays violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check roles
    value = dataDict.get('spectrumDisplay')
    if (value is None):
      raise ApiError("""%s.checkValid: spectrumDisplay:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('stripAxes').values()
    values = dataDict.get('stripSpectrumViews').values()

  clone = Strip.clone

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllOrderedAxes = Strip.findAllOrderedAxes

  findAllSpectrumViews = Strip.findAllSpectrumViews

  findAllStripAxes = Strip.findAllStripAxes

  findAllStripSpectrumViews = Strip.findAllStripSpectrumViews

  findAxis = Strip.findAxis

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedAxis = Strip.findFirstOrderedAxis

  findFirstSpectrumView = Strip.findFirstSpectrumView

  findFirstStripAxis = Strip.findFirstStripAxis

  findFirstStripSpectrumView = Strip.findFirstStripSpectrumView
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.BoundStrip
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData
  
  def getAxisCodes(self):
    """
    getter for derived attribute axisCodes
    """
    dataDict = self.__dict__
    result = self.spectrumDisplay.axisCodes
    return result
  
  def getAxisOrder(self):
    """
    getter for derived attribute axisOrder
    """
    dataDict = self.__dict__
    result = self.spectrumDisplay.axisOrder
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.BoundStrip
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.BoundStrip'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.BoundStrip'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('modules').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('strips').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccpnmr.gui.Task.BoundStrip
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('spectrumDisplay')
    obj1 = obj2.__dict__.get('guiTask')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('nameSpace'))
      result.append(obj1.__dict__.get('name'))

    result.append(obj2.__dict__.get('name'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIndex = Strip.getIndex

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccpnmr.gui.Task.BoundStrip
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getOrderedAxes = Strip.getOrderedAxes

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccpnmr.gui.Task.BoundStrip.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumDisplay')
    return result

  getPositions = Strip.getPositions

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSerial = Strip.getSerial
  
  def getSpectrumDisplay(self):
    """
    Get for ccpnmr.gui.Task.BoundStrip.spectrumDisplay
    """
    dataDict = self.__dict__
    result = dataDict.get('spectrumDisplay')
    return result

  getSpectrumViews = Strip.getSpectrumViews

  getStripAxes = Strip.getStripAxes

  getStripSpectrumViews = Strip.getStripSpectrumViews

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnits = Strip.getUnits

  getWidths = Strip.getWidths

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  moveTo = Strip.moveTo

  newStripAxis = Strip.newStripAxis

  newStripSpectrumView = Strip.newStripSpectrumView

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeAxisOrderItem(self, value):
    """
    Remove for ccpnmr.gui.Task.BoundStrip.axisOrder
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.removeAxisOrderItem:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getAxisOrder()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAxisOrderItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAxisOrderItem:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAxisOrderItem:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setAxisOrder(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAxisOrderItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.removeAxisOrderItem,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  removePosition = Strip.removePosition

  removeUnit = Strip.removeUnit

  removeWidth = Strip.removeWidth

  resetAxisOrder = Strip.resetAxisOrder
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.BoundStrip
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxisOrder(self, values):
    """
    setter for derived attribute axisOrder
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setAxisOrder:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getAxisOrder()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAxisOrder:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisOrder:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.spectrumDisplay.axisOrder = values
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAxisOrder')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.setAxisOrder,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setIndex = Strip.setIndex

  setOrderedAxes = Strip.setOrderedAxes

  setPositions = Strip.setPositions

  setSerial = Strip.setSerial

  setUnits = Strip.setUnits

  setWidths = Strip.setWidths

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedSpectrumViews = Strip.sortedSpectrumViews

  sortedStripAxes = Strip.sortedStripAxes

  sortedStripSpectrumViews = Strip.sortedStripSpectrumViews

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData
  
  axisCodes = property(getAxisCodes, None, None,
  r"""
  """)
  
  axisOrder = property(getAxisOrder, setAxisOrder, None,
  r"""
  """)

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  index = Strip.index

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  positions = Strip.positions

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  serial = Strip.serial

  units = Strip.units

  widths = Strip.widths

  orderedAxes = Strip.orderedAxes
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for spectrumDisplay
  """)

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root
  
  spectrumDisplay = property(getSpectrumDisplay,  None, None,
  r"""parent link
  """)

  spectrumViews = Strip.spectrumViews

  stripAxes = Strip.stripAxes

  stripSpectrumViews = Strip.stripSpectrumViews

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.BoundStrip', BoundStrip)

###############################################################################
class BoundDisplay(SpectrumDisplay):
  r"""Superclass for non-free contour displays
  """
  #   from data model element ccpnmr.gui.Task.BoundDisplay
  _metaclass = metaPackage.getElement('BoundDisplay')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'axisCodes', 'axisOrder', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'is1d', 'isDeleted', 'metaclass', 'moduleType', 'name', 'packageName', 'packageShortName', 'positions', 'qualifiedName', 'resonanceGroupSerial', 'stripCount', 'stripDirection', 'stripType', 'units', 'widths', 'windowId', 'axes', 'guiTask', 'orderedAxes', 'orderedStrips', 'parameters', 'parent', 'resonanceGroup', 'root', 'spectrumViews', 'strips', 'topObject', 'window',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.BoundDisplay
    """
    dataDict = self.__dict__
    dataDict['guiTask'] = parent
    if (not isinstance(parent, GuiTask)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['axisCodes'] = list()
      dataDict['axisOrder'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['moduleType'] = 'SpectrumDisplay'
      dataDict['name'] = None
      dataDict['resonanceGroupSerial'] = None
      dataDict['stripDirection'] = 'Y'
      dataDict['stripType'] = None
      dataDict['windowId'] = None
      dataDict['axes'] = {}
      dataDict['parameters'] = {}
      dataDict['resonanceGroup'] = None
      dataDict['spectrumViews'] = {}
      dataDict['strips'] = {}
      dataDict['window'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.BoundDisplay', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.BoundDisplay.__init__")
        del dataDict['inConstructor']
        raise

      serialDict = {}
      serialDict['strips'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('modules')
        objKey = dataDict.get('name')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['name'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        
        
        dataDict['stripType'] = 'Bound'
        if self.resonanceGroup is None:
          nmrProject = self.topObject.nmrProject
          if nmrProject is not None:
            self.resonanceGroup = nmrProject.findFirstResonanceGroup(serial=self.resonanceGroupSerial)
        else:
          self.resonanceGroupSerial = self.resonanceGroup.serial

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.BoundDisplay:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    axes = dataDict.get('axes').values()
    for axis in axes:
      if (not (axis in objsToBeDeleted)):
        objsToBeDeleted.add(axis)
        objsToBeChecked.append(axis)

    parameters = dataDict.get('parameters').values()
    for parameter in parameters:
      if (not (parameter in objsToBeDeleted)):
        objsToBeDeleted.add(parameter)
        objsToBeChecked.append(parameter)

    resonanceGroup = dataDict.get('resonanceGroup')
    if (resonanceGroup is not None):
      topObject = resonanceGroup.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    spectrumViews = dataDict.get('spectrumViews').values()
    for spectrumView in spectrumViews:
      if (not (spectrumView in objsToBeDeleted)):
        objsToBeDeleted.add(spectrumView)
        objsToBeChecked.append(spectrumView)

    strips = dataDict.get('strips').values()
    for strip in strips:
      if (not (strip in objsToBeDeleted)):
        objsToBeDeleted.add(strip)
        objsToBeChecked.append(strip)

    window = dataDict.get('window')
    if (window is not None):
      topObject = window.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.BoundDisplay:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    resonanceGroup = dataDict.get('resonanceGroup')
    if ((resonanceGroup is not None and not (resonanceGroup in objsToBeDeleted))):
      spectrumDisplays = resonanceGroup.__dict__.get('spectrumDisplays')
      spectrumDisplays.remove(self)

    window = dataDict.get('window')
    if ((window is not None and not (window in objsToBeDeleted))):
      modules = window.__dict__.get('modules')
      modules.remove(self)

    guiTask = dataDict.get('guiTask')
    if (not (guiTask in objsToBeDeleted)):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = guiTask.__dict__.get('modules')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.BoundDisplay:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    guiTask = dataDict.get('guiTask')

    childrenDict = guiTask.__dict__.get('modules')
    objKey = dataDict.get('name')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['name'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    resonanceGroup = dataDict.get('resonanceGroup')
    if ((resonanceGroup is not None and not (resonanceGroup in objsToBeUnDeleted))):
      spectrumDisplays = resonanceGroup.__dict__.get('spectrumDisplays')
      spectrumDisplays.add(self)

    window = dataDict.get('window')
    if ((window is not None and not (window in objsToBeUnDeleted))):
      modules = window.__dict__.get('modules')
      modules.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addAxisOrderItem(self, value):
    """
    Add for ccpnmr.gui.Task.BoundDisplay.axisOrder
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.addAxisOrderItem:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axisOrder')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAxisOrderItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAxisOrderItem:
       called on deleted object""" % self.qualifiedName
      )

    if (notOverride):
      if (notInConstructor):
        if (value is not None):
          if (not (value in self.axisCodes)):
            raise ApiError("""%s.addAxisOrderItem:
             axisOrder constraint bound_axis_order_is_contained_in_axis_codes violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    undoValues = list(currentValues)
    currentValues.append(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAxisOrderItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.addAxisOrderItem,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  addOrderedAxis = SpectrumDisplay.addOrderedAxis

  addOrderedStrip = SpectrumDisplay.addOrderedStrip

  addPosition = SpectrumDisplay.addPosition

  addUnit = SpectrumDisplay.addUnit

  addWidth = SpectrumDisplay.addWidth
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.BoundDisplay
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('axes').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('parameters').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('spectrumViews').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('strips').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.BoundDisplay
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('guiTask')
        dd = value.__dict__.get('modules')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'guiTask' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('axisCodes')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: axisCodes:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('axisOrder')
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: axisOrder:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getIs1d()
      if (value is None):
        raise ApiError("""%s.checkValid: is1d:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: is1d:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('moduleType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: moduleType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('name')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: name:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getPositions()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: positions:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: positions:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: positions:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('resonanceGroupSerial')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: resonanceGroupSerial:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: resonanceGroupSerial:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getStripCount()
      if (value is None):
        raise ApiError("""%s.checkValid: stripCount:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripCount:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('stripDirection')
      if (not (value in ['X', 'Y'])):
        raise ApiError("""%s.checkValid: stripDirection:
         ccpnmr.gui.Task.StripDirection input is not in enumeration ['X', 'Y']""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: stripDirection:
         StripDirection constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('stripType')
      if (value is None):
        raise ApiError("""%s.checkValid: stripType:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: stripType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: stripType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: stripType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getUnits()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: units:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: units:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = self.getWidths()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: widths:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: widths:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: widths:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('windowId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: windowId:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: windowId:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      values = dataDict.get('axes').values()
      for value in values:
        if (not isinstance(value, Axis)):
          raise ApiError("""%s.checkValid: axes:
           value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('spectrumDisplay')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: axes:
           non-reciprocal link axes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('guiTask')
      if (not isinstance(value, GuiTask)):
        raise ApiError("""%s.checkValid: guiTask:
         value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getOrderedAxes()
      for value in values:
        if (not isinstance(value, Axis)):
          raise ApiError("""%s.checkValid: orderedAxes:
           value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedAxes:
           Link orderedAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedStrips()
      for value in values:
        if (not isinstance(value, Strip)):
          raise ApiError("""%s.checkValid: orderedStrips:
           value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedStrips:
           Link orderedStrips between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('parameters').values()
      for value in values:
        if (not isinstance(value, Parameter)):
          raise ApiError("""%s.checkValid: parameters:
           value is not of class ccpnmr.gui.Task.Parameter""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('module')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: parameters:
           non-reciprocal link parameters from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('resonanceGroup')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import ResonanceGroup as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: resonanceGroup:
           value is not of class ccp.nmr.Nmr.ResonanceGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('spectrumDisplays')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonanceGroup:
           non-reciprocal link resonanceGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('spectrumViews').values()
      for value in values:
        if (not isinstance(value, SpectrumView)):
          raise ApiError("""%s.checkValid: spectrumViews:
           value is not of class ccpnmr.gui.Task.SpectrumView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('spectrumDisplay')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: spectrumViews:
           non-reciprocal link spectrumViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('strips').values()
      for value in values:
        if (not isinstance(value, BoundStrip)):
          raise ApiError("""%s.checkValid: strips:
           value is not of class ccpnmr.gui.Task.BoundStrip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('spectrumDisplay')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: strips:
           non-reciprocal link strips from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('window')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccpnmr.gui.Window import Window as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: window:
           value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('modules')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: window:
           non-reciprocal link window from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    axisCodes = self.axisCodes
    isValid = ('intensity' not in axisCodes[:1] and 'intensity' not in axisCodes[2:])
    if (not (isValid)):
      raise ApiError("""%s.checkValid:
       constraint only_Y_axis_can_be_intensity violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('axisCodes')
    if (len(values) < 2):
      raise ApiError("""%s.checkValid: axisCodes:
       locard: values must be of length >= 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('axisOrder')
    if (len(values) < 2):
      raise ApiError("""%s.checkValid: axisOrder:
       locard: values must be of length >= 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not (value in self.axisCodes)):
        raise ApiError("""%s.checkValid: axisOrder:
         axisOrder constraint bound_axis_order_is_contained_in_axis_codes violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('moduleType')
    if (value is None):
      raise ApiError("""%s.checkValid: moduleType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('name')
    if (value is None):
      raise ApiError("""%s.checkValid: name:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('resonanceGroupSerial')
    value = dataDict.get('stripDirection')
    if (value is None):
      raise ApiError("""%s.checkValid: stripDirection:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('windowId')
    # check roles
    values = dataDict.get('axes').values()
    value = dataDict.get('guiTask')
    if (value is None):
      raise ApiError("""%s.checkValid: guiTask:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('parameters').values()
    value = dataDict.get('resonanceGroup')
    values = dataDict.get('spectrumViews').values()
    values = dataDict.get('strips').values()
    value = dataDict.get('window')
    if (value is not None):
      if (not (value.guiTask is self.guiTask)):
        raise ApiError("""%s.checkValid: window:
         window constraint all_window_modules_must_belong_to_window_task violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

  copyToTask = SpectrumDisplay.copyToTask

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  disconnect = SpectrumDisplay.disconnect

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllAxes = SpectrumDisplay.findAllAxes

  findAllOrderedAxes = SpectrumDisplay.findAllOrderedAxes

  findAllOrderedStrips = SpectrumDisplay.findAllOrderedStrips

  findAllParameters = Module.findAllParameters

  findAllSpectrumViews = SpectrumDisplay.findAllSpectrumViews
  
  def findAllStrips(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.BoundDisplay.strips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('strips').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('strips').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAxis = SpectrumDisplay.findAxis

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstAxis = SpectrumDisplay.findFirstAxis

  findFirstOrderedAxis = SpectrumDisplay.findFirstOrderedAxis

  findFirstOrderedStrip = SpectrumDisplay.findFirstOrderedStrip

  findFirstParameter = Module.findFirstParameter

  findFirstSpectrumView = SpectrumDisplay.findFirstSpectrumView
  
  def findFirstStrip(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.BoundDisplay.strips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('strips').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('strips').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('strips').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.BoundDisplay
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData

  getAxes = SpectrumDisplay.getAxes
  
  def getAxisCodes(self):
    """
    Get for ccpnmr.gui.Task.BoundDisplay.axisCodes
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('axisCodes')
    result = tuple(tempVar)
    return result
  
  def getAxisOrder(self):
    """
    Get for ccpnmr.gui.Task.BoundDisplay.axisOrder
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('axisOrder')
    result = tuple(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.BoundDisplay
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.BoundDisplay'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.BoundDisplay'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('modules').get(objKey)
      if (isinstance(obj2, BoundDisplay)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getDetails = Module.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = Module.getFullKey

  getGuiTask = Module.getGuiTask

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIs1d = SpectrumDisplay.getIs1d

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = Module.getLocalKey

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getModuleType = SpectrumDisplay.getModuleType

  getName = Module.getName

  getOrderedAxes = SpectrumDisplay.getOrderedAxes

  getOrderedStrips = SpectrumDisplay.getOrderedStrips

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParameters = Module.getParameters

  getParent = Module.getParent

  getPositions = SpectrumDisplay.getPositions

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getResonanceGroup = SpectrumDisplay.getResonanceGroup

  getResonanceGroupSerial = SpectrumDisplay.getResonanceGroupSerial

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSpectrumViews = SpectrumDisplay.getSpectrumViews

  getStripCount = SpectrumDisplay.getStripCount

  getStripDirection = SpectrumDisplay.getStripDirection

  getStripType = SpectrumDisplay.getStripType
  
  def getStrips(self):
    """
    Get for ccpnmr.gui.Task.BoundDisplay.strips
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('strips').values()
    result = frozenset(tempVar)
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnits = SpectrumDisplay.getUnits

  getWidths = SpectrumDisplay.getWidths

  getWindow = Module.getWindow

  getWindowId = Module.getWindowId

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID
  
  def newBoundStrip(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.BoundStrip
    """
    return BoundStrip(self, **attrlinks)

  newFidAxis = SpectrumDisplay.newFidAxis

  newFrequencyAxis = SpectrumDisplay.newFrequencyAxis

  newIntensityAxis = SpectrumDisplay.newIntensityAxis

  newParameter = Module.newParameter

  newSampledAxis = SpectrumDisplay.newSampledAxis

  newSpectrumView = SpectrumDisplay.newSpectrumView

  reconnect = SpectrumDisplay.reconnect

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeAxisOrderItem(self, value):
    """
    Remove for ccpnmr.gui.Task.BoundDisplay.axisOrder
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.removeAxisOrderItem:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axisOrder')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAxisOrderItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAxisOrderItem:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAxisOrderItem:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (2 + 1)):
        raise ApiError("""%s.removeAxisOrderItem:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    undoValues = list(currentValues)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAxisOrderItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.removeAxisOrderItem,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  removeOrderedAxis = SpectrumDisplay.removeOrderedAxis

  removeOrderedStrip = SpectrumDisplay.removeOrderedStrip

  removePosition = SpectrumDisplay.removePosition

  removeUnit = SpectrumDisplay.removeUnit

  removeWidth = SpectrumDisplay.removeWidth

  resetAxisOrder = SpectrumDisplay.resetAxisOrder
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.BoundDisplay
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxisCodes(self, values):
    """
    Set for ccpnmr.gui.Task.BoundDisplay.axisCodes
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setAxisCodes:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setAxisCodes:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setAxisCodes:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setAxisCodes:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axisCodes')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisCodes:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setAxisCodes:
         cannot set axisCodes, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (len(values) < 2):
        raise ApiError("""%s.setAxisCodes:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['axisCodes'] = values

    # doNotifies
  
  def setAxisOrder(self, values):
    """
    Custom setter for axisOrder, to ensure strip axis is not changed for
    multstrip plots
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setAxisOrder:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('axisOrder')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAxisOrder:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisOrder:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    if (notOverride):
      if (len(values) < 2):
        raise ApiError("""%s.setAxisOrder:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (notInConstructor):
        for value in values:
          if (not (value in self.axisCodes)):
            raise ApiError("""%s.setAxisOrder:
             axisOrder constraint bound_axis_order_is_contained_in_axis_codes violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      if len(self.strips) > 1:
        index = 'XY'.index(self.stripDirection)
        if values[index] != self.axisCodes[index]:
          raise ValueError("Cannot change strip axis for multistip display while reordering axes")
      dataDict['axisOrder'] = values
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAxisOrder')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.setAxisOrder,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setDetails = Module.setDetails

  setModuleType = SpectrumDisplay.setModuleType

  setName = Module.setName

  setOrderedAxes = SpectrumDisplay.setOrderedAxes

  setOrderedStrips = SpectrumDisplay.setOrderedStrips

  setPositions = SpectrumDisplay.setPositions

  setResonanceGroup = SpectrumDisplay.setResonanceGroup

  setResonanceGroupSerial = SpectrumDisplay.setResonanceGroupSerial

  setStripDirection = SpectrumDisplay.setStripDirection

  setStripType = SpectrumDisplay.setStripType

  setUnits = SpectrumDisplay.setUnits

  setWidths = SpectrumDisplay.setWidths

  setWindow = Module.setWindow

  setWindowId = Module.setWindowId

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedAxes = SpectrumDisplay.sortedAxes

  sortedParameters = Module.sortedParameters

  sortedSpectrumViews = SpectrumDisplay.sortedSpectrumViews
  
  def sortedStrips(self):
    """
    Sorted for ccpnmr.gui.Task.BoundDisplay.strips
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('strips')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData
  
  axisCodes = property(getAxisCodes, setAxisCodes, None,
  r"""Axis codes for display, in original (frozen) order
  """)
  
  axisOrder = property(getAxisOrder, setAxisOrder, None,
  r"""Axis codes for display in current display order
  """)

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = Module.details

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  is1d = SpectrumDisplay.is1d

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  moduleType = SpectrumDisplay.moduleType

  name = Module.name

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  positions = SpectrumDisplay.positions

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  resonanceGroupSerial = SpectrumDisplay.resonanceGroupSerial

  stripCount = SpectrumDisplay.stripCount

  stripDirection = SpectrumDisplay.stripDirection

  stripType = SpectrumDisplay.stripType

  units = SpectrumDisplay.units

  widths = SpectrumDisplay.widths

  windowId = Module.windowId

  axes = SpectrumDisplay.axes

  guiTask = Module.guiTask

  orderedAxes = SpectrumDisplay.orderedAxes

  orderedStrips = SpectrumDisplay.orderedStrips

  parameters = Module.parameters

  parent = Module.parent

  resonanceGroup = SpectrumDisplay.resonanceGroup

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  spectrumViews = SpectrumDisplay.spectrumViews
  
  strips = property(getStrips,  None, None,
  r"""child link to class BoundStrip
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  window = Module.window

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.BoundDisplay', BoundDisplay)

###############################################################################
class FreeDisplay(SpectrumDisplay):
  r"""Abstract strip display with independent spectrum display and axis 
settings for each strip
  """
  #   from data model element ccpnmr.gui.Task.FreeDisplay
  _metaclass = metaPackage.getElement('FreeDisplay')
  _packageName = 'ccpnmr.gui.Task'
  _packageShortName = 'GUIT'
  _fieldNames = ('_ID', 'applicationData', 'axisCodes', 'axisOrder', 'ccpnInternalData', 'className', 'details', 'fieldNames', 'inConstructor', 'is1d', 'isDeleted', 'metaclass', 'moduleType', 'name', 'packageName', 'packageShortName', 'positions', 'qualifiedName', 'resonanceGroupSerial', 'stripCount', 'stripDirection', 'stripType', 'units', 'widths', 'windowId', 'axes', 'guiTask', 'orderedAxes', 'orderedStrips', 'parameters', 'parent', 'resonanceGroup', 'root', 'spectrumViews', 'strips', 'topObject', 'window',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccpnmr.gui.Task.FreeDisplay
    """
    dataDict = self.__dict__
    dataDict['guiTask'] = parent
    if (not isinstance(parent, GuiTask)):
      raise ApiError("""%s.__init__:
       value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    objectsCreated = set((self,))
    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['_ID'] = None
      dataDict['applicationData'] = list()
      dataDict['ccpnInternalData'] = None
      dataDict['details'] = None
      dataDict['moduleType'] = 'SpectrumDisplay'
      dataDict['name'] = None
      dataDict['resonanceGroupSerial'] = None
      dataDict['stripDirection'] = 'Y'
      dataDict['stripType'] = None
      dataDict['windowId'] = None
      dataDict['axes'] = {}
      dataDict['parameters'] = {}
      dataDict['resonanceGroup'] = None
      dataDict['spectrumViews'] = {}
      dataDict['strips'] = {}
      dataDict['window'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in sorted(attrlinks.items()):
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        if (dataDict.get('_ID') is None):
          self.set_ID(-1)
        else:
          raise ApiError("""%s.__init__:
           Class %s - set explicit _ID %s when not reading""" % self.qualifiedName
           + ": %s:%s" % ('ccpnmr.gui.Task.FreeDisplay', value)
          )

        del dataDict['inConstructor']
      except:
        self.root._logger.debug("in ccpnmr.gui.Task.FreeDisplay.__init__")
        del dataDict['inConstructor']
        raise

      serialDict = {}
      serialDict['strips'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('modules')
        objKey = dataDict.get('name')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['name'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        
        
        dataDict['stripType']  = 'Free'
        
        if self.resonanceGroup is None:
          nmrProject = self.topObject.nmrProject
          if nmrProject is not None:
            self.resonanceGroup = nmrProject.findFirstResonanceGroup(serial=self.resonanceGroupSerial)
        else:
          self.resonanceGroupSerial = self.resonanceGroup.serial

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        self.root._logger.debug('''WARNING Error in clean-up of incorrectly created object.
        Data may be left in an illegal state''')
        del dataDict['inConstructor']
      raise exc_info[0](exc_info[1])

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

    if (notIsReading):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(_deleteAllApiObjects, root._unDelete, undoArgs=(objectsCreated,),
                      redoArgs=(objectsCreated, set(x.topObject for x in objectsCreated)))

    if (notOverride):
      
      ll = self.__class__._notifies.get('postInit')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccpnmr.gui.Task.FreeDisplay:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    axes = dataDict.get('axes').values()
    for axis in axes:
      if (not (axis in objsToBeDeleted)):
        objsToBeDeleted.add(axis)
        objsToBeChecked.append(axis)

    parameters = dataDict.get('parameters').values()
    for parameter in parameters:
      if (not (parameter in objsToBeDeleted)):
        objsToBeDeleted.add(parameter)
        objsToBeChecked.append(parameter)

    resonanceGroup = dataDict.get('resonanceGroup')
    if (resonanceGroup is not None):
      topObject = resonanceGroup.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    spectrumViews = dataDict.get('spectrumViews').values()
    for spectrumView in spectrumViews:
      if (not (spectrumView in objsToBeDeleted)):
        objsToBeDeleted.add(spectrumView)
        objsToBeChecked.append(spectrumView)

    strips = dataDict.get('strips').values()
    for strip in strips:
      if (not (strip in objsToBeDeleted)):
        objsToBeDeleted.add(strip)
        objsToBeChecked.append(strip)

    window = dataDict.get('window')
    if (window is not None):
      topObject = window.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccpnmr.gui.Task.FreeDisplay:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    resonanceGroup = dataDict.get('resonanceGroup')
    if ((resonanceGroup is not None and not (resonanceGroup in objsToBeDeleted))):
      spectrumDisplays = resonanceGroup.__dict__.get('spectrumDisplays')
      spectrumDisplays.remove(self)

    window = dataDict.get('window')
    if ((window is not None and not (window in objsToBeDeleted))):
      modules = window.__dict__.get('modules')
      modules.remove(self)

    guiTask = dataDict.get('guiTask')
    if (not (guiTask in objsToBeDeleted)):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = guiTask.__dict__.get('modules')
        if (self is dd.get(objKey)):
          del dd[objKey]

  def _singleUnDelete(self, objsToBeUnDeleted):
    """
    singleUnDelete for ccpnmr.gui.Task.FreeDisplay:   undeletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API undo function.
    """
    dataDict = self.__dict__
    del dataDict['isDeleted']
    guiTask = dataDict.get('guiTask')

    childrenDict = guiTask.__dict__.get('modules')
    objKey = dataDict.get('name')
    if (objKey is None):
      raise ApiError("""%s._singleUnDelete:
       Key attribute or link not set (from ['name'])""" % self.qualifiedName
       + ": %s" % (self,)
      )
    else:
      if (childrenDict.get(objKey) is None):
        childrenDict[objKey] = self
      else:
        raise ApiError("""%s._singleUnDelete:
         Could not create, pre-existing object had same key""" % self.qualifiedName
         + ": %s" % (self,)
        )

    resonanceGroup = dataDict.get('resonanceGroup')
    if ((resonanceGroup is not None and not (resonanceGroup in objsToBeUnDeleted))):
      spectrumDisplays = resonanceGroup.__dict__.get('spectrumDisplays')
      spectrumDisplays.add(self)

    window = dataDict.get('window')
    if ((window is not None and not (window in objsToBeUnDeleted))):
      modules = window.__dict__.get('modules')
      modules.add(self)

  addApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.addApplicationData
  
  def addAxisOrderItem(self, value):
    """
    Add for ccpnmr.gui.Task.FreeDisplay.axisOrder
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.addAxisOrderItem:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.addAxisOrderItem:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getAxisOrder()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAxisOrderItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAxisOrderItem:
       called on deleted object""" % self.qualifiedName
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.append(value)
    self.setAxisOrder(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAxisOrderItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.addAxisOrderItem,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  addOrderedAxis = SpectrumDisplay.addOrderedAxis

  addOrderedStrip = SpectrumDisplay.addOrderedStrip

  addPosition = SpectrumDisplay.addPosition

  addUnit = SpectrumDisplay.addUnit

  addWidth = SpectrumDisplay.addWidth
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccpnmr.gui.Task.FreeDisplay
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('axes').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('parameters').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('spectrumViews').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('strips').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccpnmr.gui.Task.FreeDisplay
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('name')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('guiTask')
        dd = value.__dict__.get('modules')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'guiTask' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('_ID')
      if (value is None):
        raise ApiError("""%s.checkValid: _ID:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: _ID:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from ccpnmodel.ccpncore.api.memops.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = self.getAxisCodes()
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: axisCodes:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: axisCodes:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = self.getAxisOrder()
      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: axisOrder:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: axisOrder:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('ccpnInternalData')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Multiple.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: ccpnInternalData:
           memops.Implementation.Multiple input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getIs1d()
      if (value is None):
        raise ApiError("""%s.checkValid: is1d:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: is1d:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('moduleType')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: moduleType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: moduleType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('name')
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: name:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: name:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getPositions()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: positions:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: positions:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: positions:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('resonanceGroupSerial')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: resonanceGroupSerial:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: resonanceGroupSerial:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getStripCount()
      if (value is None):
        raise ApiError("""%s.checkValid: stripCount:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripCount:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('stripDirection')
      if (not (value in ['X', 'Y'])):
        raise ApiError("""%s.checkValid: stripDirection:
         ccpnmr.gui.Task.StripDirection input is not in enumeration ['X', 'Y']""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: stripDirection:
         StripDirection constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('stripType')
      if (value is None):
        raise ApiError("""%s.checkValid: stripType:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: stripType:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: stripType:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: stripType:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: stripType:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getUnits()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: units:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: units:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: units:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = self.getWidths()
      if (len(values) < 2):
        raise ApiError("""%s.checkValid: widths:
         locard: values must be of length >= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Float.PythonType)):
          pass
        elif ([x for x in ccpnmodel.ccpncore.api.memops.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          castValue = ccpnmodel.ccpncore.api.memops.Implementation.Float.create(value)
          replaceIndex = values.index(value)
          values[replaceIndex] = castValue
          value = castValue
        else:
          raise ApiError("""%s.checkValid: widths:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: widths:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('windowId')
      if (value is not None):
        if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.Int.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: windowId:
           memops.Implementation.PositiveInt input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: windowId:
           PositiveInt constraint int_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      values = dataDict.get('axes').values()
      for value in values:
        if (not isinstance(value, Axis)):
          raise ApiError("""%s.checkValid: axes:
           value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('spectrumDisplay')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: axes:
           non-reciprocal link axes from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('guiTask')
      if (not isinstance(value, GuiTask)):
        raise ApiError("""%s.checkValid: guiTask:
         value is not of class ccpnmr.gui.Task.GuiTask""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = self.getOrderedAxes()
      for value in values:
        if (not isinstance(value, Axis)):
          raise ApiError("""%s.checkValid: orderedAxes:
           value is not of class ccpnmr.gui.Task.Axis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedAxes:
           Link orderedAxes between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedStrips()
      for value in values:
        if (not isinstance(value, Strip)):
          raise ApiError("""%s.checkValid: orderedStrips:
           value is not of class ccpnmr.gui.Task.Strip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedStrips:
           Link orderedStrips between objects from separate partitions
            - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('parameters').values()
      for value in values:
        if (not isinstance(value, Parameter)):
          raise ApiError("""%s.checkValid: parameters:
           value is not of class ccpnmr.gui.Task.Parameter""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('module')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: parameters:
           non-reciprocal link parameters from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('resonanceGroup')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccp.nmr.Nmr import ResonanceGroup as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: resonanceGroup:
           value is not of class ccp.nmr.Nmr.ResonanceGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('spectrumDisplays')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonanceGroup:
           non-reciprocal link resonanceGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('spectrumViews').values()
      for value in values:
        if (not isinstance(value, SpectrumView)):
          raise ApiError("""%s.checkValid: spectrumViews:
           value is not of class ccpnmr.gui.Task.SpectrumView""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('spectrumDisplay')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: spectrumViews:
           non-reciprocal link spectrumViews from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('strips').values()
      for value in values:
        if (not isinstance(value, FreeStrip)):
          raise ApiError("""%s.checkValid: strips:
           value is not of class ccpnmr.gui.Task.FreeStrip""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('spectrumDisplay')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: strips:
           non-reciprocal link strips from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('window')
      if (value is not None):
        from ccpnmodel.ccpncore.api.ccpnmr.gui.Window import Window as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: window:
           value is not of class ccpnmr.gui.Window.Window""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('modules')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: window:
           non-reciprocal link window from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    axisCodes = self.axisCodes
    isValid = ('intensity' not in axisCodes[:1] and 'intensity' not in axisCodes[2:])
    if (not (isValid)):
      raise ApiError("""%s.checkValid:
       constraint only_Y_axis_can_be_intensity violated""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('ccpnInternalData')
    if (value is not None):
      if (not (value is None or isinstance(value, dict))):
        raise ApiError("""%s.checkValid: ccpnInternalData:
         ccpnInternalData constraint ccpnInternalData_must_be_None_or_dictionary violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('details')
    value = dataDict.get('moduleType')
    if (value is None):
      raise ApiError("""%s.checkValid: moduleType:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('name')
    if (value is None):
      raise ApiError("""%s.checkValid: name:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('resonanceGroupSerial')
    value = dataDict.get('stripDirection')
    if (value is None):
      raise ApiError("""%s.checkValid: stripDirection:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('windowId')
    # check roles
    values = dataDict.get('axes').values()
    value = dataDict.get('guiTask')
    if (value is None):
      raise ApiError("""%s.checkValid: guiTask:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('parameters').values()
    value = dataDict.get('resonanceGroup')
    values = dataDict.get('spectrumViews').values()
    values = dataDict.get('strips').values()
    value = dataDict.get('window')
    if (value is not None):
      if (not (value.guiTask is self.guiTask)):
        raise ApiError("""%s.checkValid: window:
         window constraint all_window_modules_must_belong_to_window_task violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

  copyToTask = SpectrumDisplay.copyToTask

  delete = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.delete

  disconnect = SpectrumDisplay.disconnect

  findAllApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findAllApplicationData

  findAllAxes = SpectrumDisplay.findAllAxes

  findAllOrderedAxes = SpectrumDisplay.findAllOrderedAxes

  findAllOrderedStrips = SpectrumDisplay.findAllOrderedStrips

  findAllParameters = Module.findAllParameters

  findAllSpectrumViews = SpectrumDisplay.findAllSpectrumViews
  
  def findAllStrips(self, **conditions):
    """
    FindAll for ccpnmr.gui.Task.FreeDisplay.strips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('strips').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('strips').values()
      result = set()
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result.add(v)

    return result

  findAxis = SpectrumDisplay.findAxis

  findFirstApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.findFirstApplicationData

  findFirstAxis = SpectrumDisplay.findFirstAxis

  findFirstOrderedAxis = SpectrumDisplay.findFirstOrderedAxis

  findFirstOrderedStrip = SpectrumDisplay.findFirstOrderedStrip

  findFirstParameter = Module.findFirstParameter

  findFirstSpectrumView = SpectrumDisplay.findFirstSpectrumView
  
  def findFirstStrip(self, **conditions):
    """
    FindFirst for ccpnmr.gui.Task.FreeDisplay.strips
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('strips').values()
      if (currentValues):
        result = next(iter(currentValues))
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('strips').get(objKey)

        if (nConditions <= 1):
          return result

        elif (result is None):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('strips').values()

      result = None
      
      items = list(conditions.items())
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('_ID', 'ccpnInternalData', 'index', 'serial', 'spectrumDisplay',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if getattr(v, key, ApiError) == condition:
              # NB ApiError is a dummy object, never equal to condition
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if getattr(v, key, ApiError) != condition:
              # NB ApiError is a dummy object, never equal to condition
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccpnmr.gui.Task.FreeDisplay
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getApplicationData

  getAxes = SpectrumDisplay.getAxes
  
  def getAxisCodes(self):
    """
    getter for derived attribute axisCodes.
    """
    dataDict = self.__dict__
    strip = self.findFirstStrip(index=0)
    result = () if strip is None else strip.axisCodes
    return result
  
  def getAxisOrder(self):
    """
    getter for derived attribute axisOrder
    """
    dataDict = self.__dict__
    result = self.findFirstStrip(index=0).axisOrder
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccpnmr.gui.Task.FreeDisplay
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.FreeDisplay'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      ll = list()
      objKey = fullKey[0]
      ll.append(objKey)
      if (objKey is not None):
        objKey = fullKey[1]
        ll.append(objKey)
        if (objKey is not None):
          objKey = tuple(ll)

      obj1 = obj0.__dict__.get('guiTasks').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccpnmr.gui.Task')
        obj1 = obj0.__dict__.get('guiTasks').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccpnmr.gui.Task.FreeDisplay'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('modules').get(objKey)
      if (isinstance(obj2, FreeDisplay)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getByNavigation

  getCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getCcpnInternalData

  getClassName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getClassName

  getDetails = Module.getDetails

  getExpandedKey = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getExpandedKey

  getFieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getFieldNames

  getFullKey = Module.getFullKey

  getGuiTask = Module.getGuiTask

  getInConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getInConstructor

  getIs1d = SpectrumDisplay.getIs1d

  getIsDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getIsDeleted

  getLocalKey = Module.getLocalKey

  getMetaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getMetaclass

  getModuleType = SpectrumDisplay.getModuleType

  getName = Module.getName

  getOrderedAxes = SpectrumDisplay.getOrderedAxes

  getOrderedStrips = SpectrumDisplay.getOrderedStrips

  getPackageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageName

  getPackageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getPackageShortName

  getParameters = Module.getParameters

  getParent = Module.getParent

  getPositions = SpectrumDisplay.getPositions

  getQualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.getQualifiedName

  getResonanceGroup = SpectrumDisplay.getResonanceGroup

  getResonanceGroupSerial = SpectrumDisplay.getResonanceGroupSerial

  getRoot = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.getRoot

  getSpectrumViews = SpectrumDisplay.getSpectrumViews

  getStripCount = SpectrumDisplay.getStripCount

  getStripDirection = SpectrumDisplay.getStripDirection

  getStripType = SpectrumDisplay.getStripType
  
  def getStrips(self):
    """
    Get for ccpnmr.gui.Task.FreeDisplay.strips
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('strips').values()
    result = frozenset(tempVar)
    return result

  getTopObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.getTopObject

  getUnits = SpectrumDisplay.getUnits

  getWidths = SpectrumDisplay.getWidths

  getWindow = Module.getWindow

  getWindowId = Module.getWindowId

  get_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.get_ID

  newFidAxis = SpectrumDisplay.newFidAxis
  
  def newFreeStrip(self, **attrlinks):
    """
    Factory function to create ccpnmr.gui.Task.FreeStrip
    """
    return FreeStrip(self, **attrlinks)

  newFrequencyAxis = SpectrumDisplay.newFrequencyAxis

  newIntensityAxis = SpectrumDisplay.newIntensityAxis

  newParameter = Module.newParameter

  newSampledAxis = SpectrumDisplay.newSampledAxis

  newSpectrumView = SpectrumDisplay.newSpectrumView

  reconnect = SpectrumDisplay.reconnect

  removeApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.removeApplicationData
  
  def removeAxisOrderItem(self, value):
    """
    Remove for ccpnmr.gui.Task.FreeDisplay.axisOrder
    """
    dataDict = self.__dict__
    if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.removeAxisOrderItem:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.removeAxisOrderItem:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getAxisOrder()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAxisOrderItem:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAxisOrderItem:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAxisOrderItem:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    undoValues = list(currentValues)
    newValues = list(currentValues)
    newValues.remove(value)
    self.setAxisOrder(newValues)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAxisOrderItem')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.removeAxisOrderItem,
                      undoArgs=(undoValues,), redoArgs=(value,))
      
  removeOrderedAxis = SpectrumDisplay.removeOrderedAxis

  removeOrderedStrip = SpectrumDisplay.removeOrderedStrip

  removePosition = SpectrumDisplay.removePosition

  removeUnit = SpectrumDisplay.removeUnit

  removeWidth = SpectrumDisplay.removeWidth

  resetAxisOrder = SpectrumDisplay.resetAxisOrder
  
  def set(self, name, value):
    """
    SetAttr for ccpnmr.gui.Task.FreeDisplay
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setApplicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setApplicationData
  
  def setAxisOrder(self, values):
    """
    setter for derived attribute axisOrder
    """
    dataDict = self.__dict__
    values = list(values)
    for value in values:
      if (isinstance(value, ccpnmodel.ccpncore.api.memops.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setAxisOrder:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setAxisOrder:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getAxisOrder()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAxisOrder:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAxisOrder:
       called on deleted object""" % self.qualifiedName
      )

    try:
      if (values == currentValues):
        return

    except ValueError as ex:
      pass
    except TypeError as ex:
      pass
    _undo = root.__dict__.get('_undo')
    if (_undo is not None):
      _undo.increaseBlocking()

    try:
      self.findFirstStrip(index=0).axisOrder = values
    finally:
      if (_undo is not None):
        _undo.decreaseBlocking()

    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAxisOrder')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

    if ((notInConstructor and notIsReading)):
      # register Undo functions
      
      _undo = root._undo
      if _undo is not None:
      
        _undo.newItem(self.setAxisOrder, self.setAxisOrder,
                      undoArgs=(currentValues,), redoArgs=(values,))

  setCcpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.setCcpnInternalData

  setDetails = Module.setDetails

  setModuleType = SpectrumDisplay.setModuleType

  setName = Module.setName

  setOrderedAxes = SpectrumDisplay.setOrderedAxes

  setOrderedStrips = SpectrumDisplay.setOrderedStrips

  setPositions = SpectrumDisplay.setPositions

  setResonanceGroup = SpectrumDisplay.setResonanceGroup

  setResonanceGroupSerial = SpectrumDisplay.setResonanceGroupSerial

  setStripDirection = SpectrumDisplay.setStripDirection

  setStripType = SpectrumDisplay.setStripType

  setUnits = SpectrumDisplay.setUnits

  setWidths = SpectrumDisplay.setWidths

  setWindow = Module.setWindow

  setWindowId = Module.setWindowId

  set_ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.set_ID

  sortedAxes = SpectrumDisplay.sortedAxes

  sortedParameters = Module.sortedParameters

  sortedSpectrumViews = SpectrumDisplay.sortedSpectrumViews
  
  def sortedStrips(self):
    """
    Sorted for ccpnmr.gui.Task.FreeDisplay.strips
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('strips')
    
    ll = list(sortdd.keys())
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.toDetailedString

  _ID = ccpnmodel.ccpncore.api.memops.Implementation.DataObject._ID

  applicationData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.applicationData
  
  axisCodes = property(getAxisCodes, None, None,
  r"""Axis codes for display in original (frozen) order. Derived from values 
  for first strip
  """)
  
  axisOrder = property(getAxisOrder, setAxisOrder, None,
  r"""Axis codes for display in current display order. Derived from values for 
  first strip
  """)

  ccpnInternalData = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.ccpnInternalData

  className = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.className

  details = Module.details

  fieldNames = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.fieldNames

  inConstructor = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.inConstructor

  is1d = SpectrumDisplay.is1d

  isDeleted = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.isDeleted

  metaclass = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.metaclass

  moduleType = SpectrumDisplay.moduleType

  name = Module.name

  packageName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageName

  packageShortName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.packageShortName

  positions = SpectrumDisplay.positions

  qualifiedName = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType.qualifiedName

  resonanceGroupSerial = SpectrumDisplay.resonanceGroupSerial

  stripCount = SpectrumDisplay.stripCount

  stripDirection = SpectrumDisplay.stripDirection

  stripType = SpectrumDisplay.stripType

  units = SpectrumDisplay.units

  widths = SpectrumDisplay.widths

  windowId = Module.windowId

  axes = SpectrumDisplay.axes

  guiTask = Module.guiTask

  orderedAxes = SpectrumDisplay.orderedAxes

  orderedStrips = SpectrumDisplay.orderedStrips

  parameters = Module.parameters

  parent = Module.parent

  resonanceGroup = SpectrumDisplay.resonanceGroup

  root = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject.root

  spectrumViews = SpectrumDisplay.spectrumViews
  
  strips = property(getStrips,  None, None,
  r"""child link to class FreeStrip
  """)

  topObject = ccpnmodel.ccpncore.api.memops.Implementation.DataObject.topObject

  window = Module.window

from ccpnmodel.ccpncore.lib.ApiPath import _addModuleFunctionsToApiClass
_addModuleFunctionsToApiClass('ccpnmr.gui.Task.FreeDisplay', FreeDisplay)
