"""
#######################################################################

CCPN Data Model version 3.0.2

Autogenerated by PyXmlMapWrite on Tue Apr 24 09:49:31 2018
  from data model element memops.Implementation

#######################################################################
======================COPYRIGHT/LICENSE START==========================

Implementation.py: python XML-I/O-mapping for CCPN data model, MetaPackage memops.Implementation

Copyright (C) 2007  (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

A copy of this license can be found in ../../../../../..//LGPL.license

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
"""

from ccpnmodel.ccpncore.memops.metamodel.Constants import baseDataTypeModule as basicDataTypes
NaN = float('NaN')
# 
#  Current package api
import ccpnmodel.ccpncore.api.memops.Implementation

# ApiError import
from ccpnmodel.ccpncore.memops.ApiError import ApiError

def bool2str(value):
  return value and 'true' or 'false'

def str2bool(value):
  if value in ('True', 'true', '1'):
    return True
  elif value in ('False', 'false', '0'):
    return False
  else:
    raise ApiError("String '%s' is not legal for a Boolean" % value)

_globalMapping = {}

def getGlobalMap(oldVersionStr=None):

  from ccpnmodel.ccpncore.memops.Version import currentModelVersion
  newVersionStr = str(currentModelVersion)
  
  if oldVersionStr is None:
    oldVersionStr = newVersionStr

  versionMapping = _globalMapping.get(oldVersionStr)
  if versionMapping is None:
    versionMapping = {}
    _globalMapping[oldVersionStr] = versionMapping
    
    makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.Stereochemistry
    ccpnmodel.ccpncore.xml.ccp.molecule.Stereochemistry.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.DataLocation
    ccpnmodel.ccpncore.xml.ccp.general.DataLocation.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.Template
    ccpnmodel.ccpncore.xml.ccp.general.Template.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.DbRef
    ccpnmodel.ccpncore.xml.ccp.general.DbRef.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.Taxonomy
    ccpnmodel.ccpncore.xml.ccp.general.Taxonomy.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.KeywordDefinition
    ccpnmodel.ccpncore.xml.ccp.general.KeywordDefinition.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.ChemElement
    ccpnmodel.ccpncore.xml.ccp.molecule.ChemElement.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.Affiliation
    ccpnmodel.ccpncore.xml.ccp.general.Affiliation.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.nmr.NmrExpPrototype
    ccpnmodel.ccpncore.xml.ccp.nmr.NmrExpPrototype.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.ChemComp
    ccpnmodel.ccpncore.xml.ccp.molecule.ChemComp.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.Citation
    ccpnmodel.ccpncore.xml.ccp.general.Citation.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.ChemCompCoord
    ccpnmodel.ccpncore.xml.ccp.molecule.ChemCompCoord.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.nmr.NmrReference
    ccpnmodel.ccpncore.xml.ccp.nmr.NmrReference.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.ChemCompLabel
    ccpnmodel.ccpncore.xml.ccp.molecule.ChemCompLabel.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.ChemCompCharge
    ccpnmodel.ccpncore.xml.ccp.molecule.ChemCompCharge.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.Instrument
    ccpnmodel.ccpncore.xml.ccp.general.Instrument.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.Molecule
    ccpnmodel.ccpncore.xml.ccp.molecule.Molecule.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.Method
    ccpnmodel.ccpncore.xml.ccp.general.Method.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.MolSystem
    ccpnmodel.ccpncore.xml.ccp.molecule.MolSystem.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.general.Annotation
    ccpnmodel.ccpncore.xml.ccp.general.Annotation.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.LabeledMolecule
    ccpnmodel.ccpncore.xml.ccp.molecule.LabeledMolecule.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.molsim.AnnealProtocol
    ccpnmodel.ccpncore.xml.molsim.AnnealProtocol.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.Validation
    ccpnmodel.ccpncore.xml.ccp.molecule.Validation.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.Symmetry
    ccpnmodel.ccpncore.xml.ccp.molecule.Symmetry.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.lims.RefSampleComponent
    ccpnmodel.ccpncore.xml.ccp.lims.RefSampleComponent.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.molecule.MolStructure
    ccpnmodel.ccpncore.xml.ccp.molecule.MolStructure.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.lims.Sample
    ccpnmodel.ccpncore.xml.ccp.lims.Sample.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.nmr.Nmr
    ccpnmodel.ccpncore.xml.ccp.nmr.Nmr.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.nmr.NmrConstraint
    ccpnmodel.ccpncore.xml.ccp.nmr.NmrConstraint.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccpnmr.gui.Window
    ccpnmodel.ccpncore.xml.ccpnmr.gui.Window.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.nmr.NmrEntry
    ccpnmodel.ccpncore.xml.ccp.nmr.NmrEntry.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.cambridge.Dangle
    ccpnmodel.ccpncore.xml.cambridge.Dangle.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.utrecht.Haddock
    ccpnmodel.ccpncore.xml.utrecht.Haddock.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccp.nmr.NmrCalc
    ccpnmodel.ccpncore.xml.ccp.nmr.NmrCalc.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.ccpnmr.gui.Task
    ccpnmodel.ccpncore.xml.ccpnmr.gui.Task.makeMapping(versionMapping)

    import ccpnmodel.ccpncore.xml.cambridge.WmsProtocol
    ccpnmodel.ccpncore.xml.cambridge.WmsProtocol.makeMapping(versionMapping)

    # adjust Io map for compatibility considerations
    if oldVersionStr != newVersionStr:
      from ccpnmodel.ccpncore.memops.format.compatibility.Converters1 import modifyIoMap
      # versions are different - compatibility needed
      modifyIoMap(oldVersionStr, versionMapping)
  #
  return versionMapping

def makeMapping(globalMap):
  """
  generates XML I/O mapping for package IMPL, adding it to globalMap
  """

  # Set up global dictionaries
  loadMaps = {}
  globalMap['loadMaps'] = loadMaps
  mapsByGuid = {}
  globalMap['mapsByGuid'] = mapsByGuid

  # IMPL - <MetaPackage: memops.Implementation>: Set up top level dictionaries
  currentMap = {}
  globalMap['IMPL'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'IMPL'
  abstractTypes['.qName'] = 'memops.Implementation'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'IMPL'
  exolinks['.qName'] = 'memops.Implementation'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00025'
  currentMap['.prefix'] = 'IMPL'
  currentMap['.qName'] = 'memops.Implementation'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # STER - <MetaPackage: ccp.molecule.Stereochemistry>: Set up top level dictionaries
  currentMap = {}
  globalMap['STER'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'STER'
  abstractTypes['.qName'] = 'ccp.molecule.Stereochemistry'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'STER'
  exolinks['.qName'] = 'ccp.molecule.Stereochemistry'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00054'
  currentMap['.prefix'] = 'STER'
  currentMap['.qName'] = 'ccp.molecule.Stereochemistry'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # DLOC - <MetaPackage: ccp.general.DataLocation>: Set up top level dictionaries
  currentMap = {}
  globalMap['DLOC'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'DLOC'
  abstractTypes['.qName'] = 'ccp.general.DataLocation'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'DLOC'
  exolinks['.qName'] = 'ccp.general.DataLocation'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-04-03-19:08:10_00001'
  currentMap['.prefix'] = 'DLOC'
  currentMap['.qName'] = 'ccp.general.DataLocation'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # TEMP - <MetaPackage: ccp.general.Template>: Set up top level dictionaries
  currentMap = {}
  globalMap['TEMP'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'TEMP'
  abstractTypes['.qName'] = 'ccp.general.Template'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'TEMP'
  exolinks['.qName'] = 'ccp.general.Template'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-18:19:50_00004'
  currentMap['.prefix'] = 'TEMP'
  currentMap['.qName'] = 'ccp.general.Template'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # DBR - <MetaPackage: ccp.general.DbRef>: Set up top level dictionaries
  currentMap = {}
  globalMap['DBR'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'DBR'
  abstractTypes['.qName'] = 'ccp.general.DbRef'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'DBR'
  exolinks['.qName'] = 'ccp.general.DbRef'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00019'
  currentMap['.prefix'] = 'DBR'
  currentMap['.qName'] = 'ccp.general.DbRef'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # TAXO - <MetaPackage: ccp.general.Taxonomy>: Set up top level dictionaries
  currentMap = {}
  globalMap['TAXO'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'TAXO'
  abstractTypes['.qName'] = 'ccp.general.Taxonomy'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'TAXO'
  exolinks['.qName'] = 'ccp.general.Taxonomy'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-18:19:50_00002'
  currentMap['.prefix'] = 'TAXO'
  currentMap['.qName'] = 'ccp.general.Taxonomy'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # KWDF - <MetaPackage: ccp.general.KeywordDefinition>: Set up top level dictionaries
  currentMap = {}
  globalMap['KWDF'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'KWDF'
  abstractTypes['.qName'] = 'ccp.general.KeywordDefinition'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'KWDF'
  exolinks['.qName'] = 'ccp.general.KeywordDefinition'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-11-14-17:02:54_00001'
  currentMap['.prefix'] = 'KWDF'
  currentMap['.qName'] = 'ccp.general.KeywordDefinition'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # CHEL - <MetaPackage: ccp.molecule.ChemElement>: Set up top level dictionaries
  currentMap = {}
  globalMap['CHEL'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'CHEL'
  abstractTypes['.qName'] = 'ccp.molecule.ChemElement'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'CHEL'
  exolinks['.qName'] = 'ccp.molecule.ChemElement'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-18:19:49_00002'
  currentMap['.prefix'] = 'CHEL'
  currentMap['.qName'] = 'ccp.molecule.ChemElement'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # AFFI - <MetaPackage: ccp.general.Affiliation>: Set up top level dictionaries
  currentMap = {}
  globalMap['AFFI'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'AFFI'
  abstractTypes['.qName'] = 'ccp.general.Affiliation'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'AFFI'
  exolinks['.qName'] = 'ccp.general.Affiliation'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00017'
  currentMap['.prefix'] = 'AFFI'
  currentMap['.qName'] = 'ccp.general.Affiliation'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # NMRX - <MetaPackage: ccp.nmr.NmrExpPrototype>: Set up top level dictionaries
  currentMap = {}
  globalMap['NMRX'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'NMRX'
  abstractTypes['.qName'] = 'ccp.nmr.NmrExpPrototype'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'NMRX'
  exolinks['.qName'] = 'ccp.nmr.NmrExpPrototype'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:45_00019'
  currentMap['.prefix'] = 'NMRX'
  currentMap['.qName'] = 'ccp.nmr.NmrExpPrototype'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # CHEM - <MetaPackage: ccp.molecule.ChemComp>: Set up top level dictionaries
  currentMap = {}
  globalMap['CHEM'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'CHEM'
  abstractTypes['.qName'] = 'ccp.molecule.ChemComp'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'CHEM'
  exolinks['.qName'] = 'ccp.molecule.ChemComp'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:51_00046'
  currentMap['.prefix'] = 'CHEM'
  currentMap['.qName'] = 'ccp.molecule.ChemComp'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # CITA - <MetaPackage: ccp.general.Citation>: Set up top level dictionaries
  currentMap = {}
  globalMap['CITA'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'CITA'
  abstractTypes['.qName'] = 'ccp.general.Citation'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'CITA'
  exolinks['.qName'] = 'ccp.general.Citation'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:55_00010'
  currentMap['.prefix'] = 'CITA'
  currentMap['.qName'] = 'ccp.general.Citation'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # CCCO - <MetaPackage: ccp.molecule.ChemCompCoord>: Set up top level dictionaries
  currentMap = {}
  globalMap['CCCO'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'CCCO'
  abstractTypes['.qName'] = 'ccp.molecule.ChemCompCoord'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'CCCO'
  exolinks['.qName'] = 'ccp.molecule.ChemCompCoord'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:55_00005'
  currentMap['.prefix'] = 'CCCO'
  currentMap['.qName'] = 'ccp.molecule.ChemCompCoord'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # NMRR - <MetaPackage: ccp.nmr.NmrReference>: Set up top level dictionaries
  currentMap = {}
  globalMap['NMRR'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'NMRR'
  abstractTypes['.qName'] = 'ccp.nmr.NmrReference'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'NMRR'
  exolinks['.qName'] = 'ccp.nmr.NmrReference'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:25:08_00001'
  currentMap['.prefix'] = 'NMRR'
  currentMap['.qName'] = 'ccp.nmr.NmrReference'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # CCLB - <MetaPackage: ccp.molecule.ChemCompLabel>: Set up top level dictionaries
  currentMap = {}
  globalMap['CCLB'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'CCLB'
  abstractTypes['.qName'] = 'ccp.molecule.ChemCompLabel'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'CCLB'
  exolinks['.qName'] = 'ccp.molecule.ChemCompLabel'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:25:09_00013'
  currentMap['.prefix'] = 'CCLB'
  currentMap['.qName'] = 'ccp.molecule.ChemCompLabel'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # CCCA - <MetaPackage: ccp.molecule.ChemCompCharge>: Set up top level dictionaries
  currentMap = {}
  globalMap['CCCA'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'CCCA'
  abstractTypes['.qName'] = 'ccp.molecule.ChemCompCharge'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'CCCA'
  exolinks['.qName'] = 'ccp.molecule.ChemCompCharge'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:25:09_00008'
  currentMap['.prefix'] = 'CCCA'
  currentMap['.qName'] = 'ccp.molecule.ChemCompCharge'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # INST - <MetaPackage: ccp.general.Instrument>: Set up top level dictionaries
  currentMap = {}
  globalMap['INST'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'INST'
  abstractTypes['.qName'] = 'ccp.general.Instrument'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'INST'
  exolinks['.qName'] = 'ccp.general.Instrument'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:45_00038'
  currentMap['.prefix'] = 'INST'
  currentMap['.qName'] = 'ccp.general.Instrument'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # MOLE - <MetaPackage: ccp.molecule.Molecule>: Set up top level dictionaries
  currentMap = {}
  globalMap['MOLE'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'MOLE'
  abstractTypes['.qName'] = 'ccp.molecule.Molecule'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'MOLE'
  exolinks['.qName'] = 'ccp.molecule.Molecule'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00038'
  currentMap['.prefix'] = 'MOLE'
  currentMap['.qName'] = 'ccp.molecule.Molecule'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # METH - <MetaPackage: ccp.general.Method>: Set up top level dictionaries
  currentMap = {}
  globalMap['METH'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'METH'
  abstractTypes['.qName'] = 'ccp.general.Method'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'METH'
  exolinks['.qName'] = 'ccp.general.Method'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:25:09_00027'
  currentMap['.prefix'] = 'METH'
  currentMap['.qName'] = 'ccp.general.Method'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # MOLS - <MetaPackage: ccp.molecule.MolSystem>: Set up top level dictionaries
  currentMap = {}
  globalMap['MOLS'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'MOLS'
  abstractTypes['.qName'] = 'ccp.molecule.MolSystem'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'MOLS'
  exolinks['.qName'] = 'ccp.molecule.MolSystem'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00022'
  currentMap['.prefix'] = 'MOLS'
  currentMap['.qName'] = 'ccp.molecule.MolSystem'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # ANNO - <MetaPackage: ccp.general.Annotation>: Set up top level dictionaries
  currentMap = {}
  globalMap['ANNO'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'ANNO'
  abstractTypes['.qName'] = 'ccp.general.Annotation'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'ANNO'
  exolinks['.qName'] = 'ccp.general.Annotation'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:25:09_00024'
  currentMap['.prefix'] = 'ANNO'
  currentMap['.qName'] = 'ccp.general.Annotation'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # LMOL - <MetaPackage: ccp.molecule.LabeledMolecule>: Set up top level dictionaries
  currentMap = {}
  globalMap['LMOL'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'LMOL'
  abstractTypes['.qName'] = 'ccp.molecule.LabeledMolecule'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'LMOL'
  exolinks['.qName'] = 'ccp.molecule.LabeledMolecule'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-10-24-11:28:55_00001'
  currentMap['.prefix'] = 'LMOL'
  currentMap['.qName'] = 'ccp.molecule.LabeledMolecule'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # ANPR - <MetaPackage: molsim.AnnealProtocol>: Set up top level dictionaries
  currentMap = {}
  globalMap['ANPR'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'ANPR'
  abstractTypes['.qName'] = 'molsim.AnnealProtocol'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'ANPR'
  exolinks['.qName'] = 'molsim.AnnealProtocol'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-06-05-13:42:05_00002'
  currentMap['.prefix'] = 'ANPR'
  currentMap['.qName'] = 'molsim.AnnealProtocol'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # VALD - <MetaPackage: ccp.molecule.Validation>: Set up top level dictionaries
  currentMap = {}
  globalMap['VALD'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'VALD'
  abstractTypes['.qName'] = 'ccp.molecule.Validation'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'VALD'
  exolinks['.qName'] = 'ccp.molecule.Validation'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-11-13-15:55:49_00001'
  currentMap['.prefix'] = 'VALD'
  currentMap['.qName'] = 'ccp.molecule.Validation'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # SYMM - <MetaPackage: ccp.molecule.Symmetry>: Set up top level dictionaries
  currentMap = {}
  globalMap['SYMM'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'SYMM'
  abstractTypes['.qName'] = 'ccp.molecule.Symmetry'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'SYMM'
  exolinks['.qName'] = 'ccp.molecule.Symmetry'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-02-20-17:01:34_00001'
  currentMap['.prefix'] = 'SYMM'
  currentMap['.qName'] = 'ccp.molecule.Symmetry'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # REFS - <MetaPackage: ccp.lims.RefSampleComponent>: Set up top level dictionaries
  currentMap = {}
  globalMap['REFS'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'REFS'
  abstractTypes['.qName'] = 'ccp.lims.RefSampleComponent'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'REFS'
  exolinks['.qName'] = 'ccp.lims.RefSampleComponent'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00056'
  currentMap['.prefix'] = 'REFS'
  currentMap['.qName'] = 'ccp.lims.RefSampleComponent'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # COOR - <MetaPackage: ccp.molecule.MolStructure>: Set up top level dictionaries
  currentMap = {}
  globalMap['COOR'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'COOR'
  abstractTypes['.qName'] = 'ccp.molecule.MolStructure'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'COOR'
  exolinks['.qName'] = 'ccp.molecule.MolStructure'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00065'
  currentMap['.prefix'] = 'COOR'
  currentMap['.qName'] = 'ccp.molecule.MolStructure'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # SAM - <MetaPackage: ccp.lims.Sample>: Set up top level dictionaries
  currentMap = {}
  globalMap['SAM'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'SAM'
  abstractTypes['.qName'] = 'ccp.lims.Sample'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'SAM'
  exolinks['.qName'] = 'ccp.lims.Sample'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:43_00002'
  currentMap['.prefix'] = 'SAM'
  currentMap['.qName'] = 'ccp.lims.Sample'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # NMR - <MetaPackage: ccp.nmr.Nmr>: Set up top level dictionaries
  currentMap = {}
  globalMap['NMR'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'NMR'
  abstractTypes['.qName'] = 'ccp.nmr.Nmr'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'NMR'
  exolinks['.qName'] = 'ccp.nmr.Nmr'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:46_00006'
  currentMap['.prefix'] = 'NMR'
  currentMap['.qName'] = 'ccp.nmr.Nmr'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # NMRC - <MetaPackage: ccp.nmr.NmrConstraint>: Set up top level dictionaries
  currentMap = {}
  globalMap['NMRC'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'NMRC'
  abstractTypes['.qName'] = 'ccp.nmr.NmrConstraint'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'NMRC'
  exolinks['.qName'] = 'ccp.nmr.NmrConstraint'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:51_00001'
  currentMap['.prefix'] = 'NMRC'
  currentMap['.qName'] = 'ccp.nmr.NmrConstraint'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # GUIW - <MetaPackage: ccpnmr.gui.Window>: Set up top level dictionaries
  currentMap = {}
  globalMap['GUIW'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'GUIW'
  abstractTypes['.qName'] = 'ccpnmr.gui.Window'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'GUIW'
  exolinks['.qName'] = 'ccpnmr.gui.Window'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2014-10-31-16:36:25_00003'
  currentMap['.prefix'] = 'GUIW'
  currentMap['.qName'] = 'ccpnmr.gui.Window'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # ENTR - <MetaPackage: ccp.nmr.NmrEntry>: Set up top level dictionaries
  currentMap = {}
  globalMap['ENTR'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'ENTR'
  abstractTypes['.qName'] = 'ccp.nmr.NmrEntry'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'ENTR'
  exolinks['.qName'] = 'ccp.nmr.NmrEntry'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:25:09_00019'
  currentMap['.prefix'] = 'ENTR'
  currentMap['.qName'] = 'ccp.nmr.NmrEntry'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # DANG - <MetaPackage: cambridge.Dangle>: Set up top level dictionaries
  currentMap = {}
  globalMap['DANG'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'DANG'
  abstractTypes['.qName'] = 'cambridge.Dangle'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'DANG'
  exolinks['.qName'] = 'cambridge.Dangle'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-10-01-14:13:59_00001'
  currentMap['.prefix'] = 'DANG'
  currentMap['.qName'] = 'cambridge.Dangle'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # HADD - <MetaPackage: utrecht.Haddock>: Set up top level dictionaries
  currentMap = {}
  globalMap['HADD'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'HADD'
  abstractTypes['.qName'] = 'utrecht.Haddock'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'HADD'
  exolinks['.qName'] = 'utrecht.Haddock'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-10-11-22:58:43_00002'
  currentMap['.prefix'] = 'HADD'
  currentMap['.qName'] = 'utrecht.Haddock'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # CALC - <MetaPackage: ccp.nmr.NmrCalc>: Set up top level dictionaries
  currentMap = {}
  globalMap['CALC'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'CALC'
  abstractTypes['.qName'] = 'ccp.nmr.NmrCalc'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'CALC'
  exolinks['.qName'] = 'ccp.nmr.NmrCalc'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2009-04-16-16:23:57_00001'
  currentMap['.prefix'] = 'CALC'
  currentMap['.qName'] = 'ccp.nmr.NmrCalc'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # GUIT - <MetaPackage: ccpnmr.gui.Task>: Set up top level dictionaries
  currentMap = {}
  globalMap['GUIT'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'GUIT'
  abstractTypes['.qName'] = 'ccpnmr.gui.Task'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'GUIT'
  exolinks['.qName'] = 'ccpnmr.gui.Task'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2014-10-31-16:36:26_00004'
  currentMap['.prefix'] = 'GUIT'
  currentMap['.qName'] = 'ccpnmr.gui.Task'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries

  # WMSP - <MetaPackage: cambridge.WmsProtocol>: Set up top level dictionaries
  currentMap = {}
  globalMap['WMSP'] = currentMap
  abstractTypes = {}
  currentMap['abstractTypes'] = abstractTypes
  abstractTypes['.prefix'] = 'WMSP'
  abstractTypes['.qName'] = 'cambridge.WmsProtocol'
  abstractTypes['.name'] = 'abstractTypes'
  exolinks = {}
  currentMap['exolinks'] = exolinks
  exolinks['.prefix'] = 'WMSP'
  exolinks['.qName'] = 'cambridge.WmsProtocol'
  exolinks['.name'] = 'exolinks'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2010-05-06-12:26:54_00001'
  currentMap['.prefix'] = 'WMSP'
  currentMap['.qName'] = 'cambridge.WmsProtocol'
  currentMap['.name'] = 'mapping'
  currentMap['globalRelease'] = '3.0.2'

  # Set up top level dictionaries
  abstractTypes = globalMap.get('IMPL').get('abstractTypes')
  exolinks = globalMap.get('IMPL').get('exolinks')

  # DataType Any
  currentMap = {}
  abstractTypes['Any'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-11-17-09:06:35_00001'] = currentMap
  loadMaps['IMPL.Any'] = currentMap
  currentMap['tag'] = 'IMPL.Any'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-11-17-09:06:35_00001'
  currentMap['toStr'] = basicDataTypes.Any.toString
  currentMap['cnvrt'] = basicDataTypes.Any.fromString

  # DataType Boolean
  currentMap = {}
  abstractTypes['Boolean'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028'] = currentMap
  loadMaps['IMPL.Boolean'] = currentMap
  currentMap['tag'] = 'IMPL.Boolean'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028'
  currentMap['toStr'] = bool2str
  currentMap['cnvrt'] = str2bool

  # DataType DateTime
  currentMap = {}
  abstractTypes['DateTime'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00029'] = currentMap
  loadMaps['IMPL.DateTime'] = currentMap
  currentMap['tag'] = 'IMPL.DateTime'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00029'
  currentMap['toStr'] = basicDataTypes.DateTime.toString
  currentMap['cnvrt'] = basicDataTypes.DateTime.fromString

  # DataType Dict
  currentMap = {}
  abstractTypes['Dict'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00013'] = currentMap
  loadMaps['IMPL.Dict'] = currentMap
  currentMap['tag'] = 'IMPL.Dict'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00013'
  currentMap['toStr'] = basicDataTypes.Dict.toString
  currentMap['cnvrt'] = basicDataTypes.Dict.fromString

  # DataType Float
  currentMap = {}
  abstractTypes['Float'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031'] = currentMap
  loadMaps['IMPL.Float'] = currentMap
  currentMap['tag'] = 'IMPL.Float'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031'
  currentMap['toStr'] = basicDataTypes.Float.toString
  currentMap['cnvrt'] = basicDataTypes.Float.fromString

  # DataType IeeeFloat
  currentMap = {}
  abstractTypes['IeeeFloat'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2015-10-26-11:28:17_00001'] = currentMap
  loadMaps['IMPL.IeeeFloat'] = currentMap
  currentMap['tag'] = 'IMPL.IeeeFloat'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2015-10-26-11:28:17_00001'
  currentMap['toStr'] = basicDataTypes.IeeeFloat.toString
  currentMap['cnvrt'] = basicDataTypes.IeeeFloat.fromString

  # DataType Int
  currentMap = {}
  abstractTypes['Int'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032'] = currentMap
  loadMaps['IMPL.Int'] = currentMap
  currentMap['tag'] = 'IMPL.Int'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032'
  currentMap['toStr'] = basicDataTypes.Int.toString
  currentMap['cnvrt'] = basicDataTypes.Int.fromString

  # DataType Multiple
  currentMap = {}
  abstractTypes['Multiple'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2016-02-21-22:03:00_00001'] = currentMap
  loadMaps['IMPL.Multiple'] = currentMap
  currentMap['tag'] = 'IMPL.Multiple'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2016-02-21-22:03:00_00001'
  currentMap['toStr'] = basicDataTypes.Multiple.toString
  currentMap['cnvrt'] = basicDataTypes.Multiple.fromString

  # DataType String
  currentMap = {}
  abstractTypes['String'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035'] = currentMap
  loadMaps['IMPL.String'] = currentMap
  currentMap['tag'] = 'IMPL.String'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType StringKeyDict
  currentMap = {}
  abstractTypes['StringKeyDict'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-11-03-14:03:26_00001'] = currentMap
  loadMaps['IMPL.StringKeyDict'] = currentMap
  currentMap['tag'] = 'IMPL.StringKeyDict'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-11-03-14:03:26_00001'
  currentMap['toStr'] = basicDataTypes.Dict.toString
  currentMap['cnvrt'] = basicDataTypes.Dict.fromString

  # DataType NegativeFloat
  currentMap = {}
  abstractTypes['NegativeFloat'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-05-29-14:27:55_00001'] = currentMap
  loadMaps['IMPL.NegativeFloat'] = currentMap
  currentMap['tag'] = 'IMPL.NegativeFloat'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-05-29-14:27:55_00001'
  currentMap['toStr'] = basicDataTypes.Float.toString
  currentMap['cnvrt'] = basicDataTypes.Float.fromString

  # DataType FloatRatio
  currentMap = {}
  abstractTypes['FloatRatio'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00058'] = currentMap
  loadMaps['IMPL.FloatRatio'] = currentMap
  currentMap['tag'] = 'IMPL.FloatRatio'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00058'
  currentMap['toStr'] = basicDataTypes.Float.toString
  currentMap['cnvrt'] = basicDataTypes.Float.fromString

  # DataType NonNegativeFloat
  currentMap = {}
  abstractTypes['NonNegativeFloat'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00009'] = currentMap
  loadMaps['IMPL.NonNegativeFloat'] = currentMap
  currentMap['tag'] = 'IMPL.NonNegativeFloat'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00009'
  currentMap['toStr'] = basicDataTypes.Float.toString
  currentMap['cnvrt'] = basicDataTypes.Float.fromString

  # DataType PositiveFloat
  currentMap = {}
  abstractTypes['PositiveFloat'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00007'] = currentMap
  loadMaps['IMPL.PositiveFloat'] = currentMap
  currentMap['tag'] = 'IMPL.PositiveFloat'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00007'
  currentMap['toStr'] = basicDataTypes.Float.toString
  currentMap['cnvrt'] = basicDataTypes.Float.fromString

  # DataType NonNegativeInt
  currentMap = {}
  abstractTypes['NonNegativeInt'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00011'] = currentMap
  loadMaps['IMPL.NonNegativeInt'] = currentMap
  currentMap['tag'] = 'IMPL.NonNegativeInt'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00011'
  currentMap['toStr'] = basicDataTypes.Int.toString
  currentMap['cnvrt'] = basicDataTypes.Int.fromString

  # DataType PositiveInt
  currentMap = {}
  abstractTypes['PositiveInt'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00001'] = currentMap
  loadMaps['IMPL.PositiveInt'] = currentMap
  currentMap['tag'] = 'IMPL.PositiveInt'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00001'
  currentMap['toStr'] = basicDataTypes.Int.toString
  currentMap['cnvrt'] = basicDataTypes.Int.fromString

  # DataType IntSign
  currentMap = {}
  abstractTypes['IntSign'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-04-10-18:39:10_00003'] = currentMap
  loadMaps['IMPL.IntSign'] = currentMap
  currentMap['tag'] = 'IMPL.IntSign'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-04-10-18:39:10_00003'
  currentMap['toStr'] = basicDataTypes.Int.toString
  currentMap['cnvrt'] = basicDataTypes.Int.fromString

  # DataType NegativeInt
  currentMap = {}
  abstractTypes['NegativeInt'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-05-29-14:27:55_00003'] = currentMap
  loadMaps['IMPL.NegativeInt'] = currentMap
  currentMap['tag'] = 'IMPL.NegativeInt'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-05-29-14:27:55_00003'
  currentMap['toStr'] = basicDataTypes.Int.toString
  currentMap['cnvrt'] = basicDataTypes.Int.fromString

  # DataType SingleLine
  currentMap = {}
  abstractTypes['SingleLine'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00005'] = currentMap
  loadMaps['IMPL.SingleLine'] = currentMap
  currentMap['tag'] = 'IMPL.SingleLine'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00005'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType Page
  currentMap = {}
  abstractTypes['Page'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2009-01-23-10:52:32_00001'] = currentMap
  loadMaps['IMPL.Page'] = currentMap
  currentMap['tag'] = 'IMPL.Page'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2009-01-23-10:52:32_00001'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType HexString
  currentMap = {}
  abstractTypes['HexString'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2011-12-02-09:49:50_00001'] = currentMap
  loadMaps['IMPL.HexString'] = currentMap
  currentMap['tag'] = 'IMPL.HexString'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2011-12-02-09:49:50_00001'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType SpacelessString
  currentMap = {}
  abstractTypes['SpacelessString'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2007-09-12-18:31:28_00001'] = currentMap
  loadMaps['IMPL.SpacelessString'] = currentMap
  currentMap['tag'] = 'IMPL.SpacelessString'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-09-12-18:31:28_00001'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType Token
  currentMap = {}
  abstractTypes['Token'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00055'] = currentMap
  loadMaps['IMPL.Token'] = currentMap
  currentMap['tag'] = 'IMPL.Token'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00055'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType Line
  currentMap = {}
  abstractTypes['Line'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033'] = currentMap
  loadMaps['IMPL.Line'] = currentMap
  currentMap['tag'] = 'IMPL.Line'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType PathString
  currentMap = {}
  abstractTypes['PathString'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00003'] = currentMap
  loadMaps['IMPL.PathString'] = currentMap
  currentMap['tag'] = 'IMPL.PathString'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00003'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType RgbColor
  currentMap = {}
  abstractTypes['RgbColor'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-05-05-15:12:50_00007'] = currentMap
  loadMaps['IMPL.RgbColor'] = currentMap
  currentMap['tag'] = 'IMPL.RgbColor'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-05-05-15:12:50_00007'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType RgbaColor
  currentMap = {}
  abstractTypes['RgbaColor'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2011-12-02-09:49:50_00003'] = currentMap
  loadMaps['IMPL.RgbaColor'] = currentMap
  currentMap['tag'] = 'IMPL.RgbaColor'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2011-12-02-09:49:50_00003'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType LongWord
  currentMap = {}
  abstractTypes['LongWord'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2007-09-12-18:31:28_00003'] = currentMap
  loadMaps['IMPL.LongWord'] = currentMap
  currentMap['tag'] = 'IMPL.LongWord'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-09-12-18:31:28_00003'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType GuidString
  currentMap = {}
  abstractTypes['GuidString'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-06-30-16:30:50_00001'] = currentMap
  loadMaps['IMPL.GuidString'] = currentMap
  currentMap['tag'] = 'IMPL.GuidString'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-06-30-16:30:50_00001'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType Word
  currentMap = {}
  abstractTypes['Word'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037'] = currentMap
  loadMaps['IMPL.Word'] = currentMap
  currentMap['tag'] = 'IMPL.Word'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType ThreeValueAnswer
  currentMap = {}
  abstractTypes['ThreeValueAnswer'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2010-11-17-16:21:33_00001'] = currentMap
  loadMaps['IMPL.ThreeValueAnswer'] = currentMap
  currentMap['tag'] = 'IMPL.ThreeValueAnswer'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2010-11-17-16:21:33_00001'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType StorageFormat
  currentMap = {}
  abstractTypes['StorageFormat'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00054'] = currentMap
  loadMaps['IMPL.StorageFormat'] = currentMap
  currentMap['tag'] = 'IMPL.StorageFormat'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00054'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType KeyWord
  currentMap = {}
  abstractTypes['KeyWord'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2014-03-07-15:48:27_00001'] = currentMap
  loadMaps['IMPL.KeyWord'] = currentMap
  currentMap['tag'] = 'IMPL.KeyWord'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2014-03-07-15:48:27_00001'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataType UrlProtocol
  currentMap = {}
  abstractTypes['UrlProtocol'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00050'] = currentMap
  loadMaps['IMPL.UrlProtocol'] = currentMap
  currentMap['tag'] = 'IMPL.UrlProtocol'
  currentMap['type'] = 'simple'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00050'
  currentMap['toStr'] = 'text'
  currentMap['cnvrt'] = 'text'

  # DataObjType ComplexDataType
  currentMap = {}
  abstractTypes['ComplexDataType'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2007-10-18-17:15:48_00001'] = currentMap
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-10-18-17:15:48_00001'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.ComplexDataType
  contentMap = {}
  currentMap['content'] = contentMap
  # End of ComplexDataType

  currentMap = abstractTypes.get('ComplexDataType')

  # DataObjType MemopsDataTypeObject
  currentMap = {}
  abstractTypes['MemopsDataTypeObject'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-12-15-19:00:39_00003'] = currentMap
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-12-15-19:00:39_00003'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.MemopsDataTypeObject
  contentMap = {}
  currentMap['content'] = contentMap
  # End of MemopsDataTypeObject

  currentMap = abstractTypes.get('MemopsDataTypeObject')

  # DataObjType Url
  currentMap = {}
  abstractTypes['Url'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2007-11-13-15:54:00_00000'] = currentMap
  loadMaps['IMPL.Url'] = currentMap
  currentMap['tag'] = 'IMPL.Url'
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2007-11-13-15:54:00_00000'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.Url
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute Url.host
  currentMap = {}
  contentMap['host'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00029'] = currentMap
  loadMaps['IMPL.Url.host'] = currentMap
  currentMap['tag'] = 'IMPL.Url.host'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00029'
  currentMap['name'] = 'host'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033')

  # Attribute Url.password
  currentMap = {}
  contentMap['password'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00028'] = currentMap
  loadMaps['IMPL.Url.password'] = currentMap
  currentMap['tag'] = 'IMPL.Url.password'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00028'
  currentMap['name'] = 'password'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033')

  # Attribute Url.path
  currentMap = {}
  contentMap['path'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00030'] = currentMap
  loadMaps['IMPL.Url.path'] = currentMap
  currentMap['tag'] = 'IMPL.Url.path'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00030'
  currentMap['name'] = 'path'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['eType'] = 'cplx'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00003')

  # Attribute Url.port
  currentMap = {}
  contentMap['port'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00031'] = currentMap
  loadMaps['IMPL.Url.port'] = currentMap
  currentMap['tag'] = 'IMPL.Url.port'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00031'
  currentMap['name'] = 'port'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['proc'] = 'direct'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032')

  # Attribute Url.protocol
  currentMap = {}
  contentMap['protocol'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00025'] = currentMap
  loadMaps['IMPL.Url.protocol'] = currentMap
  currentMap['tag'] = 'IMPL.Url.protocol'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00025'
  currentMap['name'] = 'protocol'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = 'file'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00050')

  # Attribute Url.user
  currentMap = {}
  contentMap['user'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00027'] = currentMap
  loadMaps['IMPL.Url.user'] = currentMap
  currentMap['tag'] = 'IMPL.Url.user'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00027'
  currentMap['name'] = 'user'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033')
  # End of Url

  currentMap = abstractTypes.get('Url')
  aList = ['port', 'protocol']
  currentMap['headerAttrs'] = aList
  aList = ['host', 'password', 'path', 'user']
  currentMap['simpleAttrs'] = aList

  # DataObjType ApplicationData
  currentMap = {}
  abstractTypes['ApplicationData'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00026'] = currentMap
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00026'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.ApplicationData
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute ApplicationData.application
  currentMap = {}
  contentMap['application'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00025'] = currentMap
  loadMaps['IMPL.ApplicationData.application'] = currentMap
  currentMap['tag'] = 'IMPL.ApplicationData.application'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00025'
  currentMap['name'] = 'application'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['eType'] = 'cplx'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033')

  # Attribute ApplicationData.keyword
  currentMap = {}
  contentMap['keyword'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00026'] = currentMap
  loadMaps['IMPL.ApplicationData.keyword'] = currentMap
  currentMap['tag'] = 'IMPL.ApplicationData.keyword'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00026'
  currentMap['name'] = 'keyword'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['eType'] = 'cplx'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033')
  # End of ApplicationData

  currentMap = abstractTypes.get('ApplicationData')
  aList = ['application', 'keyword']
  currentMap['simpleAttrs'] = aList

  # DataObjType SymmTracelessMatrix
  currentMap = {}
  abstractTypes['SymmTracelessMatrix'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-04-16-13:49:36_00004'] = currentMap
  loadMaps['IMPL.SymmTracelessMatrix'] = currentMap
  currentMap['tag'] = 'IMPL.SymmTracelessMatrix'
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-04-16-13:49:36_00004'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.SymmTracelessMatrix
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute SymmTracelessMatrix.aAxial
  currentMap = {}
  contentMap['aAxial'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00001'] = currentMap
  loadMaps['IMPL.SymmTracelessMatrix.aAxial'] = currentMap
  currentMap['tag'] = 'IMPL.SymmTracelessMatrix.aAxial'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00001'
  currentMap['name'] = 'aAxial'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031')

  # Attribute SymmTracelessMatrix.aRhombic
  currentMap = {}
  contentMap['aRhombic'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00002'] = currentMap
  loadMaps['IMPL.SymmTracelessMatrix.aRhombic'] = currentMap
  currentMap['tag'] = 'IMPL.SymmTracelessMatrix.aRhombic'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00002'
  currentMap['name'] = 'aRhombic'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031')

  # Attribute SymmTracelessMatrix.alpha
  currentMap = {}
  contentMap['alpha'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00003'] = currentMap
  loadMaps['IMPL.SymmTracelessMatrix.alpha'] = currentMap
  currentMap['tag'] = 'IMPL.SymmTracelessMatrix.alpha'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00003'
  currentMap['name'] = 'alpha'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031')

  # Attribute SymmTracelessMatrix.beta
  currentMap = {}
  contentMap['beta'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00004'] = currentMap
  loadMaps['IMPL.SymmTracelessMatrix.beta'] = currentMap
  currentMap['tag'] = 'IMPL.SymmTracelessMatrix.beta'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00004'
  currentMap['name'] = 'beta'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031')

  # Attribute SymmTracelessMatrix.gamma
  currentMap = {}
  contentMap['gamma'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00005'] = currentMap
  loadMaps['IMPL.SymmTracelessMatrix.gamma'] = currentMap
  currentMap['tag'] = 'IMPL.SymmTracelessMatrix.gamma'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2008-04-16-13:49:38_00005'
  currentMap['name'] = 'gamma'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031')
  # End of SymmTracelessMatrix

  currentMap = abstractTypes.get('SymmTracelessMatrix')
  aList = ['aAxial', 'aRhombic', 'alpha', 'beta', 'gamma']
  currentMap['headerAttrs'] = aList

  # DataObjType AppDataInt
  currentMap = {}
  abstractTypes['AppDataInt'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00041'] = currentMap
  loadMaps['IMPL.AppDataInt'] = currentMap
  currentMap['tag'] = 'IMPL.AppDataInt'
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00041'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.AppDataInt
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute AppDataInt.application
  contentMap['application'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00025')

  # Attribute AppDataInt.keyword
  contentMap['keyword'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00026')

  # Attribute AppDataInt.value
  currentMap = {}
  contentMap['value'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:24_00013'] = currentMap
  loadMaps['IMPL.AppDataInt.value'] = currentMap
  currentMap['tag'] = 'IMPL.AppDataInt.value'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:24_00013'
  currentMap['name'] = 'value'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['proc'] = 'direct'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032')
  # End of AppDataInt

  currentMap = abstractTypes.get('AppDataInt')
  aList = ['value']
  currentMap['headerAttrs'] = aList
  aList = ['application', 'keyword']
  currentMap['simpleAttrs'] = aList

  # DataObjType AppDataFloat
  currentMap = {}
  abstractTypes['AppDataFloat'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00043'] = currentMap
  loadMaps['IMPL.AppDataFloat'] = currentMap
  currentMap['tag'] = 'IMPL.AppDataFloat'
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00043'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.AppDataFloat
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute AppDataFloat.application
  contentMap['application'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00025')

  # Attribute AppDataFloat.keyword
  contentMap['keyword'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00026')

  # Attribute AppDataFloat.value
  currentMap = {}
  contentMap['value'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:24_00015'] = currentMap
  loadMaps['IMPL.AppDataFloat.value'] = currentMap
  currentMap['tag'] = 'IMPL.AppDataFloat.value'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:24_00015'
  currentMap['name'] = 'value'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031')
  # End of AppDataFloat

  currentMap = abstractTypes.get('AppDataFloat')
  aList = ['value']
  currentMap['headerAttrs'] = aList
  aList = ['application', 'keyword']
  currentMap['simpleAttrs'] = aList

  # DataObjType AppDataBoolean
  currentMap = {}
  abstractTypes['AppDataBoolean'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00039'] = currentMap
  loadMaps['IMPL.AppDataBoolean'] = currentMap
  currentMap['tag'] = 'IMPL.AppDataBoolean'
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00039'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.AppDataBoolean
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute AppDataBoolean.application
  contentMap['application'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00025')

  # Attribute AppDataBoolean.keyword
  contentMap['keyword'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00026')

  # Attribute AppDataBoolean.value
  currentMap = {}
  contentMap['value'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:24_00011'] = currentMap
  loadMaps['IMPL.AppDataBoolean.value'] = currentMap
  currentMap['tag'] = 'IMPL.AppDataBoolean.value'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:24_00011'
  currentMap['name'] = 'value'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028')
  # End of AppDataBoolean

  currentMap = abstractTypes.get('AppDataBoolean')
  aList = ['value']
  currentMap['headerAttrs'] = aList
  aList = ['application', 'keyword']
  currentMap['simpleAttrs'] = aList

  # DataObjType AppDataString
  currentMap = {}
  abstractTypes['AppDataString'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00044'] = currentMap
  loadMaps['IMPL.AppDataString'] = currentMap
  currentMap['tag'] = 'IMPL.AppDataString'
  currentMap['type'] = 'cplx'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00044'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.AppDataString
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute AppDataString.application
  contentMap['application'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00025')

  # Attribute AppDataString.keyword
  contentMap['keyword'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-17-14:16:23_00026')

  # Attribute AppDataString.value
  currentMap = {}
  contentMap['value'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:24_00016'] = currentMap
  loadMaps['IMPL.AppDataString.value'] = currentMap
  currentMap['tag'] = 'IMPL.AppDataString.value'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:24_00016'
  currentMap['name'] = 'value'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['eType'] = 'cplx'
  currentMap['proc'] = 'direct'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035')
  # End of AppDataString

  currentMap = abstractTypes.get('AppDataString')
  aList = ['application', 'keyword', 'value']
  currentMap['simpleAttrs'] = aList

  # Class MemopsObject
  currentMap = {}
  abstractTypes['MemopsObject'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00027'] = currentMap
  currentMap['type'] = 'class'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00027'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject
  contentMap = {}
  currentMap['content'] = contentMap
  # End of MemopsObject

  currentMap = abstractTypes.get('MemopsObject')

  # Class DataObject
  currentMap = {}
  abstractTypes['DataObject'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00005'] = currentMap
  currentMap['type'] = 'class'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00005'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.DataObject
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute DataObject._ID
  currentMap = {}
  contentMap['_ID'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2014-03-03-16:24:15_00001'] = currentMap
  loadMaps['IMPL.DataObject._ID'] = currentMap
  currentMap['tag'] = 'IMPL.DataObject._ID'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2014-03-03-16:24:15_00001'
  currentMap['name'] = '_ID'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032')

  # Attribute DataObject.applicationData
  currentMap = {}
  contentMap['applicationData'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00007'] = currentMap
  loadMaps['IMPL.DataObject.applicationData'] = currentMap
  currentMap['tag'] = 'IMPL.DataObject.applicationData'
  currentMap['type'] = 'dobj'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00007'
  currentMap['name'] = 'applicationData'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('IMPL').get('abstractTypes')

  # Attribute DataObject.ccpnInternalData
  currentMap = {}
  contentMap['ccpnInternalData'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2016-06-28-10:49:27_00001'] = currentMap
  loadMaps['IMPL.DataObject.ccpnInternalData'] = currentMap
  currentMap['tag'] = 'IMPL.DataObject.ccpnInternalData'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2016-06-28-10:49:27_00001'
  currentMap['name'] = 'ccpnInternalData'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['proc'] = 'direct'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2016-02-21-22:03:00_00001')
  # End of DataObject

  currentMap = abstractTypes.get('DataObject')
  aList = ['_ID']
  currentMap['headerAttrs'] = aList
  aList = ['ccpnInternalData']
  currentMap['simpleAttrs'] = aList
  aList = ['applicationData']
  currentMap['cplxAttrs'] = aList

  # Class ImplementationObject
  currentMap = {}
  abstractTypes['ImplementationObject'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-12-15-19:00:39_00001'] = currentMap
  currentMap['type'] = 'class'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-12-15-19:00:39_00001'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.ImplementationObject
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute ImplementationObject._ID
  currentMap = {}
  contentMap['_ID'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2014-03-03-16:24:15_00002'] = currentMap
  loadMaps['IMPL.ImplementationObject._ID'] = currentMap
  currentMap['tag'] = 'IMPL.ImplementationObject._ID'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2014-03-03-16:24:15_00002'
  currentMap['name'] = '_ID'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032')
  # End of ImplementationObject

  currentMap = abstractTypes.get('ImplementationObject')
  aList = ['_ID']
  currentMap['headerAttrs'] = aList

  # Class TopObject
  currentMap = {}
  abstractTypes['TopObject'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002'] = currentMap
  currentMap['type'] = 'class'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002'
  currentMap['eType'] = 'cplx'
  currentMap['isTop'] = True
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.TopObject
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute TopObject._ID
  contentMap['_ID'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2014-03-03-16:24:15_00001')

  # Attribute TopObject._lastId
  currentMap = {}
  contentMap['_lastId'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2014-03-05-13:04:27_00001'] = currentMap
  loadMaps['IMPL.TopObject._lastId'] = currentMap
  currentMap['tag'] = 'IMPL.TopObject._lastId'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2014-03-05-13:04:27_00001'
  currentMap['name'] = '_lastId'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['proc'] = 'direct'
  currentMap['default'] = 0
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032')

  # Attribute TopObject.applicationData
  contentMap['applicationData'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00007')

  # Attribute TopObject.ccpnInternalData
  contentMap['ccpnInternalData'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2016-06-28-10:49:27_00001')

  # Attribute TopObject.createdBy
  currentMap = {}
  contentMap['createdBy'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-12-31-09:00:59_00002__www.ccpn.ac.uk_Fogh_2007-10-03-14:53:27_00001__www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002'] = currentMap
  loadMaps['IMPL.TopObject.createdBy'] = currentMap
  currentMap['tag'] = 'IMPL.TopObject.createdBy'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-12-31-09:00:59_00002__www.ccpn.ac.uk_Fogh_2007-10-03-14:53:27_00001__www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002'
  currentMap['name'] = 'createdBy'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037')

  # Attribute TopObject.guid
  currentMap = {}
  contentMap['guid'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-18:48:26_00002'] = currentMap
  loadMaps['IMPL.TopObject.guid'] = currentMap
  currentMap['tag'] = 'IMPL.TopObject.guid'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-18:48:26_00002'
  currentMap['name'] = 'guid'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2008-06-30-16:30:50_00001')

  # Attribute TopObject.isModifiable
  currentMap = {}
  contentMap['isModifiable'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00010__www.ccpn.ac.uk_Fogh_2007-10-03-14:53:27_00001__www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002'] = currentMap
  loadMaps['IMPL.TopObject.isModifiable'] = currentMap
  currentMap['tag'] = 'IMPL.TopObject.isModifiable'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00010__www.ccpn.ac.uk_Fogh_2007-10-03-14:53:27_00001__www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002'
  currentMap['name'] = 'isModifiable'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = True
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028')

  # Attribute TopObject.lastUnlockedBy
  currentMap = {}
  contentMap['lastUnlockedBy'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-12-31-09:00:59_00003__www.ccpn.ac.uk_Fogh_2007-10-03-14:53:27_00001__www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002'] = currentMap
  loadMaps['IMPL.TopObject.lastUnlockedBy'] = currentMap
  currentMap['tag'] = 'IMPL.TopObject.lastUnlockedBy'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-12-31-09:00:59_00003__www.ccpn.ac.uk_Fogh_2007-10-03-14:53:27_00001__www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002'
  currentMap['name'] = 'lastUnlockedBy'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037')
  # End of TopObject

  currentMap = abstractTypes.get('TopObject')
  aList = ['_ID', '_lastId', 'createdBy', 'guid', 'isModifiable', 'lastUnlockedBy']
  currentMap['headerAttrs'] = aList
  aList = ['ccpnInternalData']
  currentMap['simpleAttrs'] = aList
  aList = ['applicationData']
  currentMap['cplxAttrs'] = aList

  # Class PackageLocator
  currentMap = {}
  abstractTypes['PackageLocator'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00003'] = currentMap
  loadMaps['IMPL.PackageLocator'] = currentMap
  currentMap['tag'] = 'IMPL.PackageLocator'
  currentMap['type'] = 'class'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00003'
  currentMap['eType'] = 'cplx'
  currentMap['fromParent'] = 'packageLocators'
  currentMap['objkey'] = 'targetName'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.PackageLocator
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute PackageLocator._ID
  contentMap['_ID'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2014-03-03-16:24:15_00002')

  # Attribute PackageLocator.targetName
  currentMap = {}
  contentMap['targetName'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00006'] = currentMap
  loadMaps['IMPL.PackageLocator.targetName'] = currentMap
  currentMap['tag'] = 'IMPL.PackageLocator.targetName'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00006'
  currentMap['name'] = 'targetName'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = 'any'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037')

  # Role PackageLocator.repositories
  currentMap = {}
  contentMap['repositories'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00005'] = currentMap
  loadMaps['IMPL.PackageLocator.repositories'] = currentMap
  currentMap['tag'] = 'IMPL.PackageLocator.repositories'
  currentMap['type'] = 'link'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00005'
  currentMap['name'] = 'repositories'
  currentMap['hicard'] = -1
  currentMap['locard'] = 1
  currentMap['copyOverride'] = True
  # End of PackageLocator

  currentMap = abstractTypes.get('PackageLocator')
  aList = ['_ID', 'targetName']
  currentMap['headerAttrs'] = aList
  aList = ['repositories']
  currentMap['simpleAttrs'] = aList

  # Class MemopsRoot
  currentMap = {}
  abstractTypes['MemopsRoot'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047'] = currentMap
  loadMaps['IMPL.MemopsRoot'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot'
  currentMap['type'] = 'class'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047'
  currentMap['eType'] = 'cplx'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.MemopsRoot
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute MemopsRoot._ID
  contentMap['_ID'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2014-03-03-16:24:15_00002')

  # Attribute MemopsRoot._lastId
  currentMap = {}
  contentMap['_lastId'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2015-12-27-10:25:10_00001'] = currentMap
  loadMaps['IMPL.MemopsRoot._lastId'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot._lastId'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2015-12-27-10:25:10_00001'
  currentMap['name'] = '_lastId'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['proc'] = 'direct'
  currentMap['default'] = 0
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032')

  # Attribute MemopsRoot.accessControlOn
  currentMap = {}
  contentMap['accessControlOn'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2009-08-19-17:31:11_00004'] = currentMap
  loadMaps['IMPL.MemopsRoot.accessControlOn'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.accessControlOn'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2009-08-19-17:31:11_00004'
  currentMap['name'] = 'accessControlOn'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = False
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028')

  # Attribute MemopsRoot.createdBy
  currentMap = {}
  contentMap['createdBy'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-12-31-09:00:59_00002__www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047'] = currentMap
  loadMaps['IMPL.MemopsRoot.createdBy'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.createdBy'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-12-31-09:00:59_00002__www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047'
  currentMap['name'] = 'createdBy'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037')

  # Attribute MemopsRoot.currentGroupName
  currentMap = {}
  contentMap['currentGroupName'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2009-08-19-17:31:11_00003'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentGroupName'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentGroupName'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2009-08-19-17:31:11_00003'
  currentMap['name'] = 'currentGroupName'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = 'user'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037')

  # Attribute MemopsRoot.currentUserId
  currentMap = {}
  contentMap['currentUserId'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-12-31-09:03:01_00011'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentUserId'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentUserId'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-12-31-09:03:01_00011'
  currentMap['name'] = 'currentUserId'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = 'user'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037')

  # Attribute MemopsRoot.isModifiable
  currentMap = {}
  contentMap['isModifiable'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00010__www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047'] = currentMap
  loadMaps['IMPL.MemopsRoot.isModifiable'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.isModifiable'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-08-17-14:16:26_00010__www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047'
  currentMap['name'] = 'isModifiable'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = True
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028')

  # Attribute MemopsRoot.lastUnlockedBy
  currentMap = {}
  contentMap['lastUnlockedBy'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-12-31-09:00:59_00003__www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047'] = currentMap
  loadMaps['IMPL.MemopsRoot.lastUnlockedBy'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.lastUnlockedBy'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-12-31-09:00:59_00003__www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047'
  currentMap['name'] = 'lastUnlockedBy'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037')

  # Attribute MemopsRoot.name
  currentMap = {}
  contentMap['name'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-10-26-12:22:46_00001'] = currentMap
  loadMaps['IMPL.MemopsRoot.name'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.name'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-10-26-12:22:46_00001'
  currentMap['name'] = 'name'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = 'ccpProject'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037')

  # Attribute MemopsRoot.override
  currentMap = {}
  contentMap['override'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-29-18:30:36_00001'] = currentMap
  loadMaps['IMPL.MemopsRoot.override'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.override'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-29-18:30:36_00001'
  currentMap['name'] = 'override'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = False
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028')

  # Role MemopsRoot.affiliationStores
  currentMap = {}
  contentMap['affiliationStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.affiliationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.affiliationStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.affiliationStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.affiliationStore'
  currentMap['name'] = 'affiliationStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('AFFI').get('abstractTypes')

  # Role MemopsRoot.annealProtocolStores
  currentMap = {}
  contentMap['annealProtocolStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.annealProtocolStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.annealProtocolStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.annealProtocolStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.annealProtocolStore'
  currentMap['name'] = 'annealProtocolStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('ANPR').get('abstractTypes')

  # Role MemopsRoot.annotationStores
  currentMap = {}
  contentMap['annotationStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.annotationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.annotationStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.annotationStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.annotationStore'
  currentMap['name'] = 'annotationStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('ANNO').get('abstractTypes')

  # Role MemopsRoot.chemCompCharges
  currentMap = {}
  contentMap['chemCompCharges'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.chemCompCharge'] = currentMap
  loadMaps['IMPL.MemopsRoot.chemCompCharges'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.chemCompCharges'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.chemCompCharge'
  currentMap['name'] = 'chemCompCharges'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('CCCA').get('abstractTypes')

  # Role MemopsRoot.chemCompCoords
  currentMap = {}
  contentMap['chemCompCoords'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.chemCompCoord'] = currentMap
  loadMaps['IMPL.MemopsRoot.chemCompCoords'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.chemCompCoords'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.chemCompCoord'
  currentMap['name'] = 'chemCompCoords'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('CCCO').get('abstractTypes')

  # Role MemopsRoot.chemComps
  currentMap = {}
  contentMap['chemComps'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.chemComp'] = currentMap
  loadMaps['IMPL.MemopsRoot.chemComps'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.chemComps'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.chemComp'
  currentMap['name'] = 'chemComps'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('CHEM').get('abstractTypes')

  # Role MemopsRoot.chemElementStores
  currentMap = {}
  contentMap['chemElementStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.chemElementStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.chemElementStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.chemElementStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.chemElementStore'
  currentMap['name'] = 'chemElementStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('CHEL').get('abstractTypes')

  # Role MemopsRoot.citationStores
  currentMap = {}
  contentMap['citationStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.citationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.citationStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.citationStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.citationStore'
  currentMap['name'] = 'citationStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('CITA').get('abstractTypes')

  # Role MemopsRoot.currentAffiliationStore
  currentMap = {}
  contentMap['currentAffiliationStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentAffiliationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentAffiliationStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentAffiliationStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentAffiliationStore'
  currentMap['name'] = 'currentAffiliationStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('AFFI').get('exolinks')

  # Role MemopsRoot.currentAnnealProtocolStore
  currentMap = {}
  contentMap['currentAnnealProtocolStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentAnnealProtocolStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentAnnealProtocolStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentAnnealProtocolStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentAnnealProtocolStore'
  currentMap['name'] = 'currentAnnealProtocolStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('ANPR').get('exolinks')

  # Role MemopsRoot.currentAnnotationStore
  currentMap = {}
  contentMap['currentAnnotationStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentAnnotationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentAnnotationStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentAnnotationStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentAnnotationStore'
  currentMap['name'] = 'currentAnnotationStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('ANNO').get('exolinks')

  # Role MemopsRoot.currentChemComp
  currentMap = {}
  contentMap['currentChemComp'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentChemComp'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentChemComp'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentChemComp'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentChemComp'
  currentMap['name'] = 'currentChemComp'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('CHEM').get('exolinks')

  # Role MemopsRoot.currentChemCompCharge
  currentMap = {}
  contentMap['currentChemCompCharge'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentChemCompCharge'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentChemCompCharge'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentChemCompCharge'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentChemCompCharge'
  currentMap['name'] = 'currentChemCompCharge'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('CCCA').get('exolinks')

  # Role MemopsRoot.currentChemCompCoord
  currentMap = {}
  contentMap['currentChemCompCoord'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentChemCompCoord'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentChemCompCoord'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentChemCompCoord'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentChemCompCoord'
  currentMap['name'] = 'currentChemCompCoord'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('CCCO').get('exolinks')

  # Role MemopsRoot.currentChemElementStore
  currentMap = {}
  contentMap['currentChemElementStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentChemElementStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentChemElementStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentChemElementStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentChemElementStore'
  currentMap['name'] = 'currentChemElementStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('CHEL').get('exolinks')

  # Role MemopsRoot.currentCitationStore
  currentMap = {}
  contentMap['currentCitationStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentCitationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentCitationStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentCitationStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentCitationStore'
  currentMap['name'] = 'currentCitationStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('CITA').get('exolinks')

  # Role MemopsRoot.currentDangleStore
  currentMap = {}
  contentMap['currentDangleStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentDangleStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentDangleStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentDangleStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentDangleStore'
  currentMap['name'] = 'currentDangleStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('DANG').get('exolinks')

  # Role MemopsRoot.currentDataLocationStore
  currentMap = {}
  contentMap['currentDataLocationStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentDataLocationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentDataLocationStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentDataLocationStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentDataLocationStore'
  currentMap['name'] = 'currentDataLocationStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('DLOC').get('exolinks')

  # Role MemopsRoot.currentDatabase
  currentMap = {}
  contentMap['currentDatabase'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentDatabase'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentDatabase'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentDatabase'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentDatabase'
  currentMap['name'] = 'currentDatabase'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('DBR').get('exolinks')

  # Role MemopsRoot.currentGuiTask
  currentMap = {}
  contentMap['currentGuiTask'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentGuiTask'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentGuiTask'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentGuiTask'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentGuiTask'
  currentMap['name'] = 'currentGuiTask'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('GUIT').get('exolinks')

  # Role MemopsRoot.currentHaddockProject
  currentMap = {}
  contentMap['currentHaddockProject'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentHaddockProject'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentHaddockProject'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentHaddockProject'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentHaddockProject'
  currentMap['name'] = 'currentHaddockProject'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('HADD').get('exolinks')

  # Role MemopsRoot.currentInstrumentStore
  currentMap = {}
  contentMap['currentInstrumentStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentInstrumentStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentInstrumentStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentInstrumentStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentInstrumentStore'
  currentMap['name'] = 'currentInstrumentStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('INST').get('exolinks')

  # Role MemopsRoot.currentKeywordDefinitionStore
  currentMap = {}
  contentMap['currentKeywordDefinitionStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentKeywordDefinitionStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentKeywordDefinitionStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentKeywordDefinitionStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentKeywordDefinitionStore'
  currentMap['name'] = 'currentKeywordDefinitionStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('KWDF').get('exolinks')

  # Role MemopsRoot.currentLabeledMolecule
  currentMap = {}
  contentMap['currentLabeledMolecule'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentLabeledMolecule'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentLabeledMolecule'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentLabeledMolecule'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentLabeledMolecule'
  currentMap['name'] = 'currentLabeledMolecule'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('LMOL').get('exolinks')

  # Role MemopsRoot.currentLabelingScheme
  currentMap = {}
  contentMap['currentLabelingScheme'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentLabelingScheme'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentLabelingScheme'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentLabelingScheme'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentLabelingScheme'
  currentMap['name'] = 'currentLabelingScheme'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('CCLB').get('exolinks')

  # Role MemopsRoot.currentMethodStore
  currentMap = {}
  contentMap['currentMethodStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentMethodStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentMethodStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentMethodStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentMethodStore'
  currentMap['name'] = 'currentMethodStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('METH').get('exolinks')

  # Role MemopsRoot.currentMolSystem
  currentMap = {}
  contentMap['currentMolSystem'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentMolSystem'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentMolSystem'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentMolSystem'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentMolSystem'
  currentMap['name'] = 'currentMolSystem'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('MOLS').get('exolinks')

  # Role MemopsRoot.currentMolSystemSymmetrySet
  currentMap = {}
  contentMap['currentMolSystemSymmetrySet'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentMolSystemSymmetrySet'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentMolSystemSymmetrySet'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentMolSystemSymmetrySet'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentMolSystemSymmetrySet'
  currentMap['name'] = 'currentMolSystemSymmetrySet'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('SYMM').get('exolinks')

  # Role MemopsRoot.currentMolecule
  currentMap = {}
  contentMap['currentMolecule'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentMolecule'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentMolecule'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentMolecule'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentMolecule'
  currentMap['name'] = 'currentMolecule'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('MOLE').get('exolinks')

  # Role MemopsRoot.currentNmrCalcStore
  currentMap = {}
  contentMap['currentNmrCalcStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrCalcStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentNmrCalcStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentNmrCalcStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrCalcStore'
  currentMap['name'] = 'currentNmrCalcStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('CALC').get('exolinks')

  # Role MemopsRoot.currentNmrConstraintStore
  currentMap = {}
  contentMap['currentNmrConstraintStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrConstraintStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentNmrConstraintStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentNmrConstraintStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrConstraintStore'
  currentMap['name'] = 'currentNmrConstraintStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('NMRC').get('exolinks')

  # Role MemopsRoot.currentNmrEntryStore
  currentMap = {}
  contentMap['currentNmrEntryStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrEntryStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentNmrEntryStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentNmrEntryStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrEntryStore'
  currentMap['name'] = 'currentNmrEntryStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('ENTR').get('exolinks')

  # Role MemopsRoot.currentNmrExpPrototype
  currentMap = {}
  contentMap['currentNmrExpPrototype'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrExpPrototype'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentNmrExpPrototype'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentNmrExpPrototype'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrExpPrototype'
  currentMap['name'] = 'currentNmrExpPrototype'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('NMRX').get('exolinks')

  # Role MemopsRoot.currentNmrProject
  currentMap = {}
  contentMap['currentNmrProject'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrProject'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentNmrProject'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentNmrProject'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrProject'
  currentMap['name'] = 'currentNmrProject'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('NMR').get('exolinks')

  # Role MemopsRoot.currentNmrReferenceStore
  currentMap = {}
  contentMap['currentNmrReferenceStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrReferenceStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentNmrReferenceStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentNmrReferenceStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentNmrReferenceStore'
  currentMap['name'] = 'currentNmrReferenceStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('NMRR').get('exolinks')

  # Role MemopsRoot.currentRefSampleComponentStore
  currentMap = {}
  contentMap['currentRefSampleComponentStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentRefSampleComponentStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentRefSampleComponentStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentRefSampleComponentStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentRefSampleComponentStore'
  currentMap['name'] = 'currentRefSampleComponentStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('REFS').get('exolinks')

  # Role MemopsRoot.currentSampleStore
  currentMap = {}
  contentMap['currentSampleStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentSampleStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentSampleStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentSampleStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentSampleStore'
  currentMap['name'] = 'currentSampleStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('SAM').get('exolinks')

  # Role MemopsRoot.currentStereochemistryStore
  currentMap = {}
  contentMap['currentStereochemistryStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentStereochemistryStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentStereochemistryStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentStereochemistryStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentStereochemistryStore'
  currentMap['name'] = 'currentStereochemistryStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('STER').get('exolinks')

  # Role MemopsRoot.currentStructureEnsemble
  currentMap = {}
  contentMap['currentStructureEnsemble'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentStructureEnsemble'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentStructureEnsemble'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentStructureEnsemble'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentStructureEnsemble'
  currentMap['name'] = 'currentStructureEnsemble'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('COOR').get('exolinks')

  # Role MemopsRoot.currentTaxonomy
  currentMap = {}
  contentMap['currentTaxonomy'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentTaxonomy'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentTaxonomy'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentTaxonomy'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentTaxonomy'
  currentMap['name'] = 'currentTaxonomy'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('TAXO').get('exolinks')

  # Role MemopsRoot.currentValidationStore
  currentMap = {}
  contentMap['currentValidationStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentValidationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentValidationStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentValidationStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentValidationStore'
  currentMap['name'] = 'currentValidationStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('VALD').get('exolinks')

  # Role MemopsRoot.currentWindowStore
  currentMap = {}
  contentMap['currentWindowStore'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentWindowStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentWindowStore'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentWindowStore'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentWindowStore'
  currentMap['name'] = 'currentWindowStore'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('GUIW').get('exolinks')

  # Role MemopsRoot.currentWmsProtocol
  currentMap = {}
  contentMap['currentWmsProtocol'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.currentWmsProtocol'] = currentMap
  loadMaps['IMPL.MemopsRoot.currentWmsProtocol'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.currentWmsProtocol'
  currentMap['type'] = 'exotop'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.currentWmsProtocol'
  currentMap['name'] = 'currentWmsProtocol'
  currentMap['hicard'] = 1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['copyOverride'] = True
  currentMap['content'] = globalMap.get('WMSP').get('exolinks')

  # Role MemopsRoot.dangleStores
  currentMap = {}
  contentMap['dangleStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.dangleStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.dangleStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.dangleStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.dangleStore'
  currentMap['name'] = 'dangleStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('DANG').get('abstractTypes')

  # Role MemopsRoot.dataLocationStores
  currentMap = {}
  contentMap['dataLocationStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.dataLocationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.dataLocationStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.dataLocationStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.dataLocationStore'
  currentMap['name'] = 'dataLocationStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('DLOC').get('abstractTypes')

  # Role MemopsRoot.databases
  currentMap = {}
  contentMap['databases'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.database'] = currentMap
  loadMaps['IMPL.MemopsRoot.databases'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.databases'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.database'
  currentMap['name'] = 'databases'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('DBR').get('abstractTypes')

  # Role MemopsRoot.guiTasks
  currentMap = {}
  contentMap['guiTasks'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.guiTask'] = currentMap
  loadMaps['IMPL.MemopsRoot.guiTasks'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.guiTasks'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.guiTask'
  currentMap['name'] = 'guiTasks'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('GUIT').get('abstractTypes')

  # Role MemopsRoot.haddockProjects
  currentMap = {}
  contentMap['haddockProjects'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.haddockProject'] = currentMap
  loadMaps['IMPL.MemopsRoot.haddockProjects'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.haddockProjects'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.haddockProject'
  currentMap['name'] = 'haddockProjects'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('HADD').get('abstractTypes')

  # Role MemopsRoot.instrumentStores
  currentMap = {}
  contentMap['instrumentStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.instrumentStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.instrumentStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.instrumentStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.instrumentStore'
  currentMap['name'] = 'instrumentStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('INST').get('abstractTypes')

  # Role MemopsRoot.keywordDefinitionStores
  currentMap = {}
  contentMap['keywordDefinitionStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.keywordDefinitionStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.keywordDefinitionStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.keywordDefinitionStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.keywordDefinitionStore'
  currentMap['name'] = 'keywordDefinitionStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('KWDF').get('abstractTypes')

  # Role MemopsRoot.labeledMolecules
  currentMap = {}
  contentMap['labeledMolecules'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.labeledMolecule'] = currentMap
  loadMaps['IMPL.MemopsRoot.labeledMolecules'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.labeledMolecules'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.labeledMolecule'
  currentMap['name'] = 'labeledMolecules'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('LMOL').get('abstractTypes')

  # Role MemopsRoot.labelingSchemes
  currentMap = {}
  contentMap['labelingSchemes'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.labelingScheme'] = currentMap
  loadMaps['IMPL.MemopsRoot.labelingSchemes'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.labelingSchemes'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.labelingScheme'
  currentMap['name'] = 'labelingSchemes'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('CCLB').get('abstractTypes')

  # Role MemopsRoot.methodStores
  currentMap = {}
  contentMap['methodStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.methodStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.methodStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.methodStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.methodStore'
  currentMap['name'] = 'methodStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('METH').get('abstractTypes')

  # Role MemopsRoot.molSystemSymmetrySets
  currentMap = {}
  contentMap['molSystemSymmetrySets'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.molSystemSymmetrySet'] = currentMap
  loadMaps['IMPL.MemopsRoot.molSystemSymmetrySets'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.molSystemSymmetrySets'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.molSystemSymmetrySet'
  currentMap['name'] = 'molSystemSymmetrySets'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('SYMM').get('abstractTypes')

  # Role MemopsRoot.molSystems
  currentMap = {}
  contentMap['molSystems'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.molSystem'] = currentMap
  loadMaps['IMPL.MemopsRoot.molSystems'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.molSystems'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.molSystem'
  currentMap['name'] = 'molSystems'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('MOLS').get('abstractTypes')

  # Role MemopsRoot.molecules
  currentMap = {}
  contentMap['molecules'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.molecule'] = currentMap
  loadMaps['IMPL.MemopsRoot.molecules'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.molecules'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.molecule'
  currentMap['name'] = 'molecules'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('MOLE').get('abstractTypes')

  # Role MemopsRoot.nmrCalcStores
  currentMap = {}
  contentMap['nmrCalcStores'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2009-04-16-16:24:00_00002'] = currentMap
  loadMaps['IMPL.MemopsRoot.nmrCalcStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.nmrCalcStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2009-04-16-16:24:00_00002'
  currentMap['name'] = 'nmrCalcStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('CALC').get('abstractTypes')

  # Role MemopsRoot.nmrConstraintStores
  currentMap = {}
  contentMap['nmrConstraintStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.nmrConstraintStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.nmrConstraintStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.nmrConstraintStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.nmrConstraintStore'
  currentMap['name'] = 'nmrConstraintStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('NMRC').get('abstractTypes')

  # Role MemopsRoot.nmrEntryStores
  currentMap = {}
  contentMap['nmrEntryStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.nmrEntryStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.nmrEntryStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.nmrEntryStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.nmrEntryStore'
  currentMap['name'] = 'nmrEntryStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('ENTR').get('abstractTypes')

  # Role MemopsRoot.nmrExpPrototypes
  currentMap = {}
  contentMap['nmrExpPrototypes'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.nmrExpPrototype'] = currentMap
  loadMaps['IMPL.MemopsRoot.nmrExpPrototypes'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.nmrExpPrototypes'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.nmrExpPrototype'
  currentMap['name'] = 'nmrExpPrototypes'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('NMRX').get('abstractTypes')

  # Role MemopsRoot.nmrProjects
  currentMap = {}
  contentMap['nmrProjects'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.nmrProject'] = currentMap
  loadMaps['IMPL.MemopsRoot.nmrProjects'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.nmrProjects'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.nmrProject'
  currentMap['name'] = 'nmrProjects'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('NMR').get('abstractTypes')

  # Role MemopsRoot.nmrReferenceStores
  currentMap = {}
  contentMap['nmrReferenceStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.nmrReferenceStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.nmrReferenceStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.nmrReferenceStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.nmrReferenceStore'
  currentMap['name'] = 'nmrReferenceStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('NMRR').get('abstractTypes')

  # Role MemopsRoot.packageLocators
  currentMap = {}
  contentMap['packageLocators'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-20-10:48:39_00002'] = currentMap
  loadMaps['IMPL.MemopsRoot.packageLocators'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.packageLocators'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-20-10:48:39_00002'
  currentMap['name'] = 'packageLocators'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['proc'] = 'loadDelayed'
  currentMap['content'] = globalMap.get('IMPL').get('abstractTypes')

  # Role MemopsRoot.refSampleComponentStores
  currentMap = {}
  contentMap['refSampleComponentStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.refSampleComponentStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.refSampleComponentStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.refSampleComponentStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.refSampleComponentStore'
  currentMap['name'] = 'refSampleComponentStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('REFS').get('abstractTypes')

  # Role MemopsRoot.repositories
  currentMap = {}
  contentMap['repositories'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-20-10:48:39_00004'] = currentMap
  loadMaps['IMPL.MemopsRoot.repositories'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.repositories'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-20-10:48:39_00004'
  currentMap['name'] = 'repositories'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('IMPL').get('abstractTypes')

  # Role MemopsRoot.sampleStores
  currentMap = {}
  contentMap['sampleStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.sampleStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.sampleStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.sampleStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.sampleStore'
  currentMap['name'] = 'sampleStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('SAM').get('abstractTypes')

  # Role MemopsRoot.stereochemistryStores
  currentMap = {}
  contentMap['stereochemistryStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.stereochemistryStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.stereochemistryStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.stereochemistryStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.stereochemistryStore'
  currentMap['name'] = 'stereochemistryStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('STER').get('abstractTypes')

  # Role MemopsRoot.structureEnsembles
  currentMap = {}
  contentMap['structureEnsembles'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.structureEnsemble'] = currentMap
  loadMaps['IMPL.MemopsRoot.structureEnsembles'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.structureEnsembles'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.structureEnsemble'
  currentMap['name'] = 'structureEnsembles'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('COOR').get('abstractTypes')

  # Role MemopsRoot.taxonomies
  currentMap = {}
  contentMap['taxonomies'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-05-12:55:49_00001'] = currentMap
  loadMaps['IMPL.MemopsRoot.taxonomies'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.taxonomies'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-05-12:55:49_00001'
  currentMap['name'] = 'taxonomies'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('TAXO').get('abstractTypes')

  # Role MemopsRoot.validationStores
  currentMap = {}
  contentMap['validationStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.validationStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.validationStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.validationStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.validationStore'
  currentMap['name'] = 'validationStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('VALD').get('abstractTypes')

  # Role MemopsRoot.windowStores
  currentMap = {}
  contentMap['windowStores'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.windowStore'] = currentMap
  loadMaps['IMPL.MemopsRoot.windowStores'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.windowStores'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.windowStore'
  currentMap['name'] = 'windowStores'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('GUIW').get('abstractTypes')

  # Role MemopsRoot.wmsProtocols
  currentMap = {}
  contentMap['wmsProtocols'] = currentMap
  mapsByGuid['ccpn_automatic_memops.Implementation.MemopsRoot.wmsProtocol'] = currentMap
  loadMaps['IMPL.MemopsRoot.wmsProtocols'] = currentMap
  currentMap['tag'] = 'IMPL.MemopsRoot.wmsProtocols'
  currentMap['type'] = 'child'
  currentMap['guid'] = 'ccpn_automatic_memops.Implementation.MemopsRoot.wmsProtocol'
  currentMap['name'] = 'wmsProtocols'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('WMSP').get('abstractTypes')
  # End of MemopsRoot

  currentMap = abstractTypes.get('MemopsRoot')
  aList = ['_ID', '_lastId', 'accessControlOn', 'createdBy', 'currentGroupName', 'currentUserId', 'isModifiable', 'lastUnlockedBy', 'name', 'override']
  currentMap['headerAttrs'] = aList
  aList = ['wmsProtocols', 'windowStores', 'validationStores', 'taxonomies', 'structureEnsembles', 'stereochemistryStores', 'sampleStores', 'refSampleComponentStores', 'nmrReferenceStores', 'nmrProjects', 'nmrExpPrototypes', 'nmrEntryStores', 'nmrConstraintStores', 'nmrCalcStores', 'molecules', 'molSystems', 'molSystemSymmetrySets', 'methodStores', 'labelingSchemes', 'labeledMolecules', 'keywordDefinitionStores', 'instrumentStores', 'haddockProjects', 'guiTasks', 'databases', 'dataLocationStores', 'dangleStores', 'citationStores', 'chemElementStores', 'chemComps', 'chemCompCoords', 'chemCompCharges', 'annotationStores', 'annealProtocolStores', 'affiliationStores', 'currentWmsProtocol', 'currentWindowStore', 'currentValidationStore', 'currentTaxonomy', 'currentStructureEnsemble', 'currentStereochemistryStore', 'currentSampleStore', 'currentRefSampleComponentStore', 'currentNmrReferenceStore', 'currentNmrProject', 'currentNmrExpPrototype', 'currentNmrEntryStore', 'currentNmrConstraintStore', 'currentNmrCalcStore', 'currentMolecule', 'currentMolSystemSymmetrySet', 'currentMolSystem', 'currentMethodStore', 'currentLabelingScheme', 'currentLabeledMolecule', 'currentKeywordDefinitionStore', 'currentInstrumentStore', 'currentHaddockProject', 'currentGuiTask', 'currentDatabase', 'currentDataLocationStore', 'currentDangleStore', 'currentCitationStore', 'currentChemElementStore', 'currentChemCompCoord', 'currentChemCompCharge', 'currentChemComp', 'currentAnnotationStore', 'currentAnnealProtocolStore', 'currentAffiliationStore', 'packageLocators', 'repositories']
  currentMap['cplxAttrs'] = aList
  aList = ['affiliationStores', 'annealProtocolStores', 'annotationStores', 'chemCompCharges', 'chemCompCoords', 'chemComps', 'chemElementStores', 'citationStores', 'dangleStores', 'dataLocationStores', 'databases', 'guiTasks', 'haddockProjects', 'instrumentStores', 'keywordDefinitionStores', 'labeledMolecules', 'labelingSchemes', 'methodStores', 'molSystemSymmetrySets', 'molSystems', 'molecules', 'nmrCalcStores', 'nmrConstraintStores', 'nmrEntryStores', 'nmrExpPrototypes', 'nmrProjects', 'nmrReferenceStores', 'packageLocators', 'refSampleComponentStores', 'repositories', 'sampleStores', 'stereochemistryStores', 'structureEnsembles', 'taxonomies', 'validationStores', 'windowStores', 'wmsProtocols']
  currentMap['children'] = aList

  # Class Repository
  currentMap = {}
  abstractTypes['Repository'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00004'] = currentMap
  loadMaps['IMPL.Repository'] = currentMap
  currentMap['tag'] = 'IMPL.Repository'
  currentMap['type'] = 'class'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00004'
  currentMap['eType'] = 'cplx'
  currentMap['fromParent'] = 'repositories'
  currentMap['objkey'] = 'name'
  currentMap['class'] = ccpnmodel.ccpncore.api.memops.Implementation.Repository
  contentMap = {}
  currentMap['content'] = contentMap

  # Attribute Repository._ID
  contentMap['_ID'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2014-03-03-16:24:15_00002')

  # Attribute Repository.format
  currentMap = {}
  contentMap['format'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-18:48:28_00030'] = currentMap
  loadMaps['IMPL.Repository.format'] = currentMap
  currentMap['tag'] = 'IMPL.Repository.format'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-18:48:28_00030'
  currentMap['name'] = 'format'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['default'] = 'xml'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00054')

  # Attribute Repository.name
  currentMap = {}
  contentMap['name'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-18:48:28_00029'] = currentMap
  loadMaps['IMPL.Repository.name'] = currentMap
  currentMap['tag'] = 'IMPL.Repository.name'
  currentMap['type'] = 'attr'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-18:48:28_00029'
  currentMap['name'] = 'name'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['eType'] = 'cplx'
  currentMap['data'] = mapsByGuid.get('www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033')

  # Attribute Repository.url
  currentMap = {}
  contentMap['url'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-18:48:28_00031'] = currentMap
  loadMaps['IMPL.Repository.url'] = currentMap
  currentMap['tag'] = 'IMPL.Repository.url'
  currentMap['type'] = 'dobj'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-18:48:28_00031'
  currentMap['name'] = 'url'
  currentMap['hicard'] = 1
  currentMap['locard'] = 1
  currentMap['eType'] = 'cplx'
  currentMap['content'] = globalMap.get('IMPL').get('abstractTypes')

  # Role Repository.stored
  currentMap = {}
  contentMap['stored'] = currentMap
  mapsByGuid['www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00004'] = currentMap
  loadMaps['IMPL.Repository.stored'] = currentMap
  currentMap['tag'] = 'IMPL.Repository.stored'
  currentMap['type'] = 'link'
  currentMap['guid'] = 'www.ccpn.ac.uk_Fogh_2006-09-14-18:48:27_00004'
  currentMap['name'] = 'stored'
  currentMap['hicard'] = -1
  currentMap['locard'] = 0
  currentMap['copyOverride'] = True
  # End of Repository

  currentMap = abstractTypes.get('Repository')
  aList = ['_ID', 'format']
  currentMap['headerAttrs'] = aList
  aList = ['name', 'stored']
  currentMap['simpleAttrs'] = aList
  aList = ['url']
  currentMap['cplxAttrs'] = aList

def saveToStream(stream, topObject, mapping=None, comment=None, simplified=True, compact=True, expanded=False):
  """
  Write topObject and its descendants to open stream 'stream'.
  
  'mapping' contains all XMLtag-Model and Model-XMLtag mapping info.
  'comment' is added at the top of the file as an XML comment,
  If 'simplified' one-to-many links are written out at one end only,
  (otherwise at both ends), and attributes equal to the default are skipped.
  If 'compact' most hicard==1 attributes are written as XML attributes of
  the container, otherwise all attributes are written as elements.
  If 'expanded' all attributes are written with inside an explicit type
  definition element (e.g. <aSerial><Int>5</Int></aSerial> instead of
   <aSerial>5</aSerial>. Expanded form may be easier to do backwards
   compatibility in some rare cases.
  """
  
  import time
  strapp = stream.write
  indents = {0:''}
  
  if mapping is None:
    mapping = getGlobalMap()[topObject.metaclass.container.shortName]
  
  # set up
  doComplex = not (simplified)

  if ((compact and expanded)):
    raise ApiError("""XML save: Parameters 'compact' and 'expanded' are incompatible"""
    )

  # check for topObject
  if (isinstance(topObject, ccpnmodel.ccpncore.api.memops.Implementation.MemopsRoot)):
    isImplementation = True
  elif (isinstance(topObject, ccpnmodel.ccpncore.api.memops.Implementation.TopObject)):
    isImplementation = False
  else:
    raise ApiError("""XML save: top obj is neither MemopsRoot nor TopObject"""
     + ": %s" % (topObject,)
    )

  # make sentinel objects
  startObj = list()
  endObj = list()

  reuseList = [None]
  emptyList = list()

  # set start indent
  indentBySpaces = 2
  nIndent = 0
  indent = ''

  strapp('<?xml version="1.0" encoding="UTF-8"?>\n')

  if (comment):
    strapp("<!--%s-->\n" % comment.replace('--','\-\-'))

  guid = mapping.get('guid')
  release = mapping.get('globalRelease')
  date = time.ctime()
  originator = 'CCPN Python XmlIO'
  strapp('%s<%s time="%s" packageGuid="%s" release="%s" originator="%s">\n' % (indent, '_StorageUnit', date, guid, release, originator))
  strapp('\n')

  # Write objects
  print('start generating output : ', topObject.getQualifiedName())
  stack = [topObject]
  mapStack = [mapping['abstractTypes'][topObject.__class__.__name__]]
  while stack:

    val = stack.pop()
    curMap0 = mapStack.pop()

    # IF BLOCK 1
    if (val is startObj):
      # start new attribute-less element
      # NB we have been cheating, putting a string on the mapStack
      strapp('%s<%s>\n' % (indent, curMap0))
      nIndent += indentBySpaces
      indent = indents.setdefault(nIndent, nIndent*' ')

    elif (val is endObj):
      # end element
      # NB we have been cheating, putting a string on the mapStack
      nIndent -= indentBySpaces
      indent = indents[nIndent]
      strapp('%s</%s>\n' % (indent, curMap0))

    else:
      curMap = curMap0
      typ = curMap.get('type')

      # IF BLOCK 2
      if (typ == 'simple'):
        tag = curMap['tag']
        toStr = curMap.get('toStr')

        if ('text' == toStr):
          # String type
          val = val.replace('&', '&amp;')
          val = val.replace('"', '&quot;')
          val = val.replace('<', '&lt;')
          val = val.replace('>', '&gt;')
        else:
          # non-string simple type - toStr is conversion function
          val = toStr(val)

        strapp('%s<%s>' % (indent, tag))
        strapp(val)
        strapp('</%s>\n' % tag)

      elif (typ == 'exo'):
        tag = curMap['tag']
        stack.append(endObj)
        mapStack.append(tag)
        keyMaps = curMap['keyMaps']

        # put keys on stack
        keys = val.getFullKey(True)
        for ii in reversed(range(len(keys))):
          key = keys[ii]
          stack.append(key)
          if ((isinstance(key, ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject) or isinstance(key, ccpnmodel.ccpncore.api.memops.Implementation.MemopsDataTypeObject))):
            mapStack.append(keyMaps[ii].get(key.__class__.__name__))
          else:
            mapStack.append(keyMaps[ii])

        # Could be done directly
        # But it will not make much difference, so for consistency
        stack.append(startObj)
        mapStack.append(tag)

      else:
        # type class or cplx

        # setup
        stackVal = val
        contDict = curMap['content']
        headerAttrs = curMap.get('headerAttrs', emptyList)
        optLinks = curMap.get('optLinks', emptyList)
        simpleAttrs = curMap.get('simpleAttrs', emptyList)
        cplxAttrs = curMap.get('cplxAttrs', emptyList)

        classtag = curMap['tag']

        # put end-of-object marker on stack
        stack.append(endObj)
        mapStack.append(classtag)

        # IF BLOCK 3
        if (typ == 'class'):
          strapp('%s<%s' % (indent, classtag))

        else:
          # typ == 'cplx'
          strapp('%s<%s' % (indent, classtag))

        # IF BLOCK 4
        if (compact):
          # set header attributes and links
          if ((doComplex and optLinks)):
            names = headerAttrs + optLinks
          else:
            names = headerAttrs

          # LOOP A
          for name in names:
            tmpMap = contDict[name]
            if ((isImplementation and tmpMap.get('implSkip', False))):
              continue

            # NB hicard is always 1 here
            # NB here we use name instead of tag, as tag is 'Clazz.attr'
            value = stackVal.__dict__[name]

            # IF BLOCK 5
            if (value is not None):
              typ = tmpMap['type']

              # IF BLOCK 6
              if (typ == 'link'):
                _ID = value.__dict__['_ID']
                strapp(' %s="%s"' % (tmpMap.get('name'), _ID))

              else:
                # typ == 'attr'
                # IF BLOCK 7
                if ((doComplex or value != tmpMap.get('default'))):
                  toStr = tmpMap['data'].get('toStr')
                  if ('text' == toStr):
                    # String type
                    value = value.replace('&', '&amp;')
                    value = value.replace('"', '&quot;')
                    value = value.replace('<', '&lt;')
                    value = value.replace('>', '&gt;')
                  else:
                    # non-string simple type - toStr is conversion function
                    value = toStr(value)

                  strapp(' %s="%s"' % (tmpMap['name'], value))

        # IF BLOCK 8
        if ((compact and (not simpleAttrs and not cplxAttrs))):
          # class contains no XML elements. end immediately
          stack.pop()
          mapStack.pop()
          strapp('/>\n')

        else:
          # class may have more elements - process them
          # end start element
          strapp('>\n')

          # set indent
          nIndent += indentBySpaces
          indent = indents.setdefault(nIndent, nIndent*' ')

          if (compact):
            names = simpleAttrs
          elif ((doComplex and optLinks)):
            names = headerAttrs + optLinks + simpleAttrs
          else:
            names = headerAttrs + simpleAttrs

          # LOOP B
          # set simple attributes and links
          for name in names:
            tmpMap = contDict[name]
            if ((isImplementation and tmpMap.get('implSkip', False))):
              continue

            # IF BLOCK 9
            val = stackVal.__dict__[name]
            if (doComplex or (tmpMap.get('default') is None and val is not None) or val != tmpMap.get('default')):
              if ((tmpMap['hicard'] == 1 and val is not None)):
                # put here in case of (future) types
                reuseList[0] = val
                val = reuseList

              # IF BLOCK 10
              if (val):
                vals = val
                tag = tmpMap['tag']
                typ = tmpMap['type']

                # IF BLOCK 11
                if (typ == 'link'):
                  strapp('%s<%s>' % (indent, tag))
                  # LOOP C
                  for value in vals:
                    _ID = value.__dict__['_ID']
                    strapp(' %s' % _ID)

                  strapp('</%s>\n' % tag)

                elif (('cplx' == tmpMap.get('eType') or expanded)):
                  # typ == 'attr', complex XML element
                  strapp('%s<%s>\n' % (indent, tag))
                  nIndent += indentBySpaces
                  indent = indents.setdefault(nIndent, nIndent*' ')

                  tTag = tmpMap['data']['tag']
                  toStr = tmpMap['data'].get('toStr')
                  if ('text' == toStr):
                    for value in vals:
                      # String type
                      value = value.replace('&', '&amp;')
                      value = value.replace('"', '&quot;')
                      value = value.replace('<', '&lt;')
                      value = value.replace('>', '&gt;')

                      strapp('%s<%s>' % (indent, tTag))
                      strapp(value)
                      strapp('</%s>\n' % tTag)

                  else:
                    for value in vals:
                      # non-string simple type - toStr is conversion function
                      value = toStr(value)

                      strapp('%s<%s>' % (indent, tTag))
                      strapp(value)
                      strapp('</%s>\n' % tTag)

                  nIndent -= indentBySpaces
                  indent = indents[nIndent]
                  strapp('%s</%s>\n' % (indent, tag))

                else:
                  # typ == 'attr', simple XML element
                  toStr = tmpMap['data'].get('toStr')
                  strapp('%s<%s>' % (indent, tag))

                  if ('text' == toStr):
                    for value in vals:
                      # String type
                      value = value.replace('&', '&amp;')
                      value = value.replace('"', '&quot;')
                      value = value.replace('<', '&lt;')
                      value = value.replace('>', '&gt;')
                      strapp(' %s' % value)

                  else:
                    for value in vals:
                      # non-string simple type - toStr is conversion function
                      value = toStr(value)
                      strapp(' %s' % value)

                  strapp('</%s>\n' % tag)

          # put DataObjType attrs, exolinks, and child links on stack

          # LOOP D
          for name in cplxAttrs:
            val = stackVal.__dict__[name]

            # IF BLOCK 12
            if (val):
              tmpMap = contDict[name]

              # IF BLOCK 13
              if (not ((isImplementation and tmpMap.get('implSkip', False)))):

                tag = tmpMap['tag']
                tmpCont = tmpMap['content']

                stack.append(endObj)
                mapStack.append(tag)

                # IF BLOCK 14
                if (tmpMap['hicard'] == 1):
                  stack.append(val)
                  mapStack.append(tmpCont[val.__class__.__name__])

                else:
                  
                  if tmpMap['type'] == 'child':
                    items = list(val.items())
                    items.sort()
                    ll = [x[1] for x in items]
                  else:
                    ll = list(val)
                  ll.reverse() # for reproducibility
                  
                  stack.extend(ll)
                  mapStack.extend(tmpCont[x.__class__.__name__] for x in ll)

                stack.append(startObj)
                mapStack.append(tag)

  strapp('\n</_StorageUnit>\n<!--End of Memops Data-->\n')

def loadFromStream(stream, topObjId=None, topObject=None, partialLoad=False):
  """
  load Ccpn XML document using elementtree parser.
  
  topObjId should be the guid (for objects with such an attribute),
  otherwise the name (for objects with sucn an attribute), otherwise None.
  It is meant to reflect the file name, for proper topObjects.
  topObjId must match the guid/name.
  
  topObject can be None, the memopsRoot, or a package TopObject.
  If None the file must correspond to the Implementation package.
  If memopsRoot the file must be from a non-Implementaiton package, and the
  function will use the file to create a new TopObject under MemopsRoot.
  If a package TopObject the function will read the data from the file
  topObject into the passed-in TopObject, checking that the packages match,
  and giving a warning if the topObject (pseudo)key changes.
    
  if partialLoad is True only the TopObject (minus children) will be loaded
  for normal packages. For the Implementation package Classes actually 
  in Implementation will be loaded while shell topObjectas and links to]
  them will be skipped.
    
  Conceivably the rules could later be relaxed to allow a lower-level empty
  object  to be passed in for the purpose of reading subtrees. This would
  require some code modifications.
  """
  if (topObject is not None):
    # check for topObject
    if (not ((isinstance(topObject, ccpnmodel.ccpncore.api.memops.Implementation.MemopsRoot) or isinstance(topObject, ccpnmodel.ccpncore.api.memops.Implementation.TopObject)))):
      raise ApiError("""XML load: top obj is neither MemopsRoot nor TopObject"""
       + ": %s" % (topObject,)
      )

  try:
    crossLinkData = list()
    exoTopLinkData = list()
    objStack = []
    loadMaps = None
    mapping = None
    topObjectMap = None
    objectDict = {}
    # delayDataDict: AnyVarType --> (dd: string --> list)
    delayDataDict = {}
    topObjectKey = None
    parserState = 'starting'
    skipElement = None
    topObjByGuid = None
    foundClosingTag = False
    doOutOfPackage = False
    linkTopToParent = False
    needCompatibility = False
    earlyExit = False
    implPrefix = 'IMPL'

    result = None

    # needed for error handling
    elem = None
    
    # get elementtree NBNB TBD to be redone to allow for different sources
    from xml.etree import ElementTree
    
    # LOOP H
    for event, elem in ElementTree.iterparse(stream, events=("start", "end")):
    
      # IF BLOCK 100
      if (event == 'start'):
        # element start

        if (skipElement is not None):
          # we are skipping an element
          continue

        tag = elem.tag

        # IF BLOCK 102
        if (loadMaps is not None):
          # file already started

          # get map and test
          try:
            curMap = loadMaps[tag]
          except KeyError as ex:
            raise ApiError("""no map found for element"""
             + ": %s" % (tag,)
            )
          except Exception as ex:
            raise ApiError("""Load maps not set up correctly - should not get here"""
             + ": %s" % (tag,)
            )

          # check if we start skipping
          if ('skip' == curMap.get('proc')):
            skipElement = elem
            continue

          typ = curMap.get('type')

          # IF BLOCK 103
          if (not objStack):
            # inside _StorageUnit - preliminary check for TopObject element
            if (not (('class' == typ and topObjectKey is None))):
              raise ApiError("""_StorageUnit has more than one child element"""
              )

          # IF BLOCK 104
          if ('cplx' == curMap.get('eType')):
            # start of class, complex attribute, collection or exolink

            # IF BLOCK 105
            if (('cplx' == typ or 'class' == typ)):
              # class, or cplx

              clazz = curMap['class']
              constructor = curMap.get('constructor', clazz)

              # IF BLOCK 106
              obj = None
              if ('class' == typ):

                # IF BLOCK 107
                if (topObjectKey is None):
                  # start of first topObject (passed in)

                  if (objStack):
                    raise ApiError("""Non-empty stack at TopObject - should not get here"""
                    )

                  # IF BLOCK 108
                  if (topObject is None):
                    # reading Implementation.xml
                    if (mapping['.prefix'] == implPrefix):
                      topObjectKey = 'ignore'
                      obj = constructor(isReading=True)
                    else:
                      raise ApiError("""non-Implementation package called without TopObject"""
                       + ": %s" % (implPrefix,)
                      )

                    if (needCompatibility):
                      partialLoad = True

                    # get stored topObjId
                    idTag = 'name'
                    elemId = elem.get(idTag)

                  elif (isinstance(topObject, ccpnmodel.ccpncore.api.memops.Implementation.MemopsRoot)):
                    # IF BLOCK 108
                    # topObject is MemopsRoot
                    # reading new TopObject first time

                    linkTopToParent = True

                    if (mapping['.prefix'] == implPrefix):
                      raise ApiError("""Attempt to load into pre-existing MemopsRoot"""
                      )

                    # non-impl package - create TopObject afresh
                    topObjectKey = 'ignore'
                    obj = constructor(topObject, isReading=True)
                    topObjectMap = curMap

                    # get stored topObjId
                    idTag = 'guid'
                    elemId = elem.get(idTag)

                  else:
                    # IF BLOCK 108
                    # reading with pre-existing topObject - should fit mapping

                    if (clazz is not topObject.__class__):
                      raise ApiError("""TopObject class does not fit first element class"""
                       + ": %s:%s" % (topObject.__class__, clazz)
                      )

                    # check topObject status
                    if (topObject.__dict__.get('isLoaded', False)):
                      raise ApiError("""trying to load already loaded TopObject"""
                       + ": %s" % (topObject,)
                      )

                    if (topObject.__dict__.get('isModified', False)):
                      raise ApiError("""trying to load already modified TopObject"""
                       + ": %s" % (topObject,)
                      )

                    # check guid against topObj identifier
                    idTag = 'guid'
                    elemId = elem.get(idTag)

                    objId = topObject.__dict__.get(idTag)
                    if (objId != elemId):
                      raise ApiError("""TopObject identifier does not fit stored identifier"""
                       + ": %s:%s" % (objId, elemId)
                      )

                    # set up for continuing
                    obj = topObject
                    # NB only MemopsRoot has fullKey None.
                    topObjectKey = topObject.getFullKey()
                    if (topObjectKey is None):
                      topObjectKey = 'ignore'

                    obj.__dict__['isReading'] = True

                  # check that file contents match file name
                  if (elemId != topObjId):
                    raise ApiError("""TopObject identifier does not fit passed=in identifier"""
                     + ": %s:%s" % (elemId, topObjId)
                    )

                  # initialise with topObject
                  result = obj
                  if (isinstance(obj, ccpnmodel.ccpncore.api.memops.Implementation.MemopsRoot)):
                    memopsRoot = obj
                  else:
                    memopsRoot = obj.getMemopsRoot()

                  topObjByGuid = memopsRoot.__dict__.get('topObjects')

                else:
                  # IF BLOCK 107
                  # normal case - start of non-TopObject class

                  # make new class object
                  objStackList = objStack.pop()
                  stackObj = objStack[-1]
                  obj = constructor(stackObj)
                  objStackList.append(obj)
                  objStack.append(objStackList)

                # set delayDataDict
                objDelayDict = {}
                delayDataDict[obj] = objDelayDict

              elif ('cplx' == typ):
                # IF BLOCK 106
                # start of complex datatype object

                # make new dataObjType object
                obj = constructor(override=True)
                stackObj = objStack[-1]
                stackObj.append(obj)
                objDelayDict = {}
                delayDataDict[id(obj)] = objDelayDict

              else:
                # IF BLOCK 106
                raise ApiError("""Unknown element type"""
                 + ": %s" % (typ,)
                )

              # put obj on stack
              objStack.append(obj)

              # treat XML attributes
              contMap = curMap['content']
              # LOOP I
              for (tag2, value) in elem.items():
                # IF BLOCK 110
                if ('_ID' == tag2):
                  objectDict[value] = obj
                  if (value[0:1] == '_'):
                    value = value[1:]

                try:
                  tmpMap = contMap[tag2]
                except KeyError as ex:
                  raise ApiError("""no map found for XML attribute"""
                   + ": %s" % (tag2,)
                  )

                # IF BLOCK 111
                if (tmpMap.get('skip') is None):
                  typ = tmpMap['type']

                  # IF BLOCK 112
                  if ('link' == typ):
                    ll = list()
                    ll.append(value)

                    if ('delay' == tmpMap.get('proc')):
                      objDelayDict[tmpMap['name']] = ll
                    else:
                      crossLinkData.append(obj)
                      crossLinkData.append(ll)
                      crossLinkData.append(tmpMap)

                  else:
                    # types attr and text
                    dataMap = tmpMap['data']
                    cnvrt = dataMap.get('cnvrt')
                    if ('text' != cnvrt):
                      value = cnvrt(value)

                    name = tmpMap['name']
                    proc = tmpMap.get('proc')

                    # IF BLOCK 113
                    if ('delay' == proc):
                      ll = list()
                      ll.append(value)
                      objDelayDict[name] = ll

                    elif ('direct' == proc):
                      # set, bypassing API
                      obj.__dict__[name] = value

                    elif (tmpMap.get('hicard') == 1):
                      # always, except when cardinality has changed
                      setattr(obj, name, value)

                    else:
                      # only when hicard has changed from 1 to something else
                      ll = list()
                      ll.append(value)
                      setattr(obj, name, ll)

            elif ((partialLoad and ('child' == typ and result is not memopsRoot))):
              # IF BLOCK 105
              # partially loading TopObject - end now

              xx = objStack.pop()

              # IF BLOCK 109
              if (topObjectMap is not None):
                if (topObjectMap.get('isTop') is not None):
                  # set TopObjects into TopObjects dictionary.
                  yy = xx
                  guid = yy.__dict__['guid']
                  if (topObjByGuid.get(guid) is None):
                    topObjByGuid[guid] = yy

                  earlyExit = True
                  break

              # if we get here there was an error
              raise ApiError("""partial load with in incorrect context for """
               + ": %s" % (xx,)
              )

            else:
              # IF BLOCK 105
              # exolink, collection (of exo, cplx, or attr (e.g. text))
              ll = list()
              objStack.append(ll)

          # no action for : 'simple'.
          # Nor for 'attr' or  'link' if eType != 'cplx'

        else:
          # IF BLOCK 102
          # no map - at start of file or error
          # IF BLOCK 114
          if ('starting' == parserState):
            # IF BLOCK 115
            if ('_StorageUnit' == tag):
              # first element

              # get version,  package, and updated mapping
              fileVersion = elem.get('release')
              packageGuid = elem.get('packageGuid')
              if ((fileVersion is None or packageGuid is None)):
                raise ApiError("""<_StorageUnit element lacks 'release' or 'packageGuid'"""
                )

              lm = getLoadingMaps(packageGuid, fileVersion)
              mapping = lm[0]
              loadMaps = lm[1]
              needCompatibility = lm[2]

              # state tracker - for tests an error messages
              parserState = 'reading'

            else:
              raise ApiError("""no '_StorageUnit' element found, or setup failed"""
              )

          else:
            raise ApiError("""Read past end of _StorageUnit"""
            )

      else:
        # IF BLOCK 100
        # event == 'end', element end

        if (skipElement is not None):
          # we are skipping an element
          if (elem is skipElement):
            skipElement = None

          continue

        tag = elem.tag
        if ('_StorageUnit' == tag):
          foundClosingTag = True
          break

        try:
          curMap = loadMaps[tag]
        except KeyError as ex:
          raise ApiError("""no map found for element"""
           + ": %s" % (tag,)
          )
        except Exception as ex:
          raise ApiError("""Load maps not set up correctly - should not get here"""
           + ": %s" % (tag,)
          )

        # IF BLOCK 202
        if (objStack):
          # we are not yet finished

          typ = curMap.get('type')

          # IF BLOCK 203
          if ('simple' == typ):
            # DataType value
            value = elem.text
            cnvrt = curMap.get('cnvrt')
            if ('text' != cnvrt):
              value = cnvrt(value)

            stackObj = objStack[-1]
            stackObj.append(value)

          elif ('child' == typ):
            # child link
            ll = objStack.pop()
            oo = objStack[-1]
            dd = delayDataDict[oo]
            nm = curMap['name']
            dd[nm] = ll

            if ('loadDelayed' == curMap.get('proc')):
              # Special case:
              # premature link dereferencing.
              # necessary to handle Impl package properly
              delayedLoadLinksStd(objectDict, crossLinkData)
              if (exoTopLinkData):
                raise ApiError("""ExoTopLinks should not exist at intermediate MemopsRoot link-up"""
                )

              linkChildData(delayDataDict, result, mapping, linkTopToParent, doOutOfPackage)
              doOutOfPackage = True
              # Reading MemopsRoot
              # and skipping everything to do with other packages
              if (partialLoad):
                earlyExit = True
                break

          elif ('class' == typ):
            # class
            xx = objStack.pop()

            # IF BLOCK 204
            if (curMap.get('isTop', False)):
              # set TopObjects into TopObjects dictionary.
              guid = xx.__dict__['guid']
              yy = topObjByGuid.get(guid)
              if (yy is None):
                topObjByGuid[guid] = xx
              elif (yy is not xx):
                raise ApiError("""Read topObj with guid conflicts with existing topObj"""
                 + ": %s" % (guid,)
                )

            elif (not (needCompatibility)):
              dd = delayDataDict[xx]
              if (not dd):
                del delayDataDict[xx]

          elif ('exo' == typ):
            # exolink
            xx = objStack.pop()

            lenxx = len(xx)
            # IF BLOCK 205
            if (lenxx > 1):
              # normal exoLink. Append curMap for later dereferencing
              xx.append(curMap)
              stackObj = objStack[-1]
              stackObj.append(xx)

            elif (lenxx == 1):
              # link to TopObject. Must be handled differently, because
              # of toTopObject links that may be present in Implementation
              stackObj = objStack[-1]
              yy = xx[0]
              stackObj.append(yy)

            else:
              raise ApiError("""XML element appears empty"""
              )

          elif ('cplx' == typ):
            # complex datatype
            xx = objStack.pop()
            del xx.__dict__['override']

            dd = delayDataDict[id(xx)]
            if (not dd):
              del delayDataDict[id(xx)]

          else:
            # class elements - typ is 'link', 'attr', 'exolink', 'exotop', 'dobj'

            # get value
            # IF BLOCK 206
            if ('cplx' == curMap.get('eType')):
              val = objStack.pop()
              if (not val):
                # NBNB with elements being skipped
                # this might legitimately happen during backwards compatibility
                continue

            elif ('attr' == typ):
              dataMap = curMap['data']
              cnvrt = dataMap['cnvrt']
              
              if cnvrt == 'text':
                val = elem.text.split()
              else:
                val = [cnvrt(x) for x in elem.text.split()]
              # check if non-empty
              if (not val):
                raise ApiError("""XML element appears empty"""
                )

            else:
              val = elem.text.split()
              # check if non-empty
              if (not val):
                raise ApiError("""XML element appears empty"""
                )

            # set up
            proc = curMap.get('proc')

            # IF BLOCK 207
            if ('delay' == proc):
              # defunct element, preserved for backwards compatibility
              containerObj = objStack[-1]
              if (isinstance(containerObj, ccpnmodel.ccpncore.api.memops.Implementation.MemopsObject)):
                dictid = containerObj
              else:
                dictid = id(containerObj)

              dd = delayDataDict[dictid]
              dd[curMap['name']] = val

            elif ('link' == typ):
              # crosslink - delayed setting
              stackObj = objStack[-1]
              crossLinkData.append(stackObj)
              crossLinkData.append(val)
              crossLinkData.append(curMap)

            elif ('exotop' == typ):
              # exolink to topObject. delayed setting
              stackObj = objStack[-1]
              exoTopLinkData.append(stackObj)
              exoTopLinkData.append(val)
              exoTopLinkData.append(curMap)

            else:
              # attribute for setting now
              if ('exolink' == typ):
                # exolink not to topObject - convert to objects now.
                # val is topObjGuid, followed by rest of key,
                # followed by the exo link I/O map.
                
                for ii, vv in enumerate(val):
                  oo = topObjByGuid.get(vv[0])
                  clazz = vv[-1]['class']
                  if (oo is None):
                    # NB naughty - _packageName is a private attribute. 
                    # But getPackageName is not static
                    memopsRoot.refreshTopObjects(clazz._packageName)
                    try:
                      oo = topObjByGuid[vv[0]]
                    except:
                      raise ApiError("""TopObject with package:gui not found or loaded"""
                       + ": %s:%s" % (curMap['content']['.qName'], vv[0])
                      )
                  value = clazz.getByKey(oo,vv[1:-1])
                  if value is None:
                    raise ApiError("No object found with package,class,key: %s" 
                                   % ((curMap['content']['.qName'], clazz.__name__, vv[1:-1]),))
                  else:
                    val[ii] = value

              # set up
              name = curMap['name']
              hicard = curMap['hicard']

              # set value
              stackObj = objStack[-1]
              # IF BLOCK 208
              if (hicard == 1):
                vv = val[0]
                if ('direct' == proc):
                  # set, bypassing API - hicard must be 1.
                  stackObj.__dict__[name] = vv
                else:
                  # std set, hicard == 1
                  setattr(stackObj, name, vv)

              elif (hicard < 1):
                # std set, hicard == infinity
                setattr(stackObj, name, val)

              else:
                setattr(stackObj, name, val[:hicard])

        elif ('_StorageUnit' != tag):
          # IF BLOCK 202
          raise ApiError("""objStack empty but element is not _StorageUnit"""
          )

    if (not (earlyExit)):
      if (not (foundClosingTag)):
        raise ApiError("""Premature end of file - no </_StorageUnit> found"""
        )

      if ((objStack or skipElement is not None)):
        raise ApiError("""Illegal state after parsing: objStack length, skipElement"""
         + ": %s:%s" % (len(objStack), skipElement)
        )

    # delayed load
    parserState = 'postprocessing data'
    if ((result is memopsRoot or not (partialLoad))):
      delayedLoadLinksStd(objectDict, crossLinkData)

    delayedLoadLinksExo(topObjByGuid, exoTopLinkData)

    if (needCompatibility):
      # backwards compatibility
      parserState = 'handling version compatibility'
      from ccpnmodel.ccpncore.memops.format.compatibility import Converters1
      Converters1.minorPostProcess(fileVersion, result, delayDataDict, objectDict, mapping)

    # link children to parents
    linkChildData(delayDataDict, result, mapping, linkTopToParent, doOutOfPackage)

    # validity check
    parserState = 'checking validity'

    # unset isReading (NB - extra link is for future load of non-topObjects)
    resultTop = result.getTopObject()
    resultTop.__dict__['isReading'] = False
    if ((not (partialLoad) or result is memopsRoot)):
      resultTop.__dict__['isLoaded'] = True
      if ((needCompatibility and resultTop.__dict__.get('isModifiable', False))):
        resultTop.__dict__['isModified'] = True

    if ((topObjectKey is not None and topObjectKey != 'ignore')):
      xx = result.getFullKey()
      if (topObjectKey != xx):
        print('WARNING TopObject key changed on reading', topObjectKey, xx)

    if (not (memopsRoot._upgradedFromV2)):
      for obj in objectDict.values():
        obj.checkValid()

  except:
    
    if elem:
      tag = elem.tag
    else:
      tag = 'None'
    
    # clean up in case of error.
    # Currently not done, as too hard to do properly. NBNB TBD
    if (result is not None):
      result.getTopObject().__dict__['isReading'] = False

    print('Error loading file for: ', result)
    print('Reading: ', stream)
    print('Last xml tag read: ', tag)
    print('Parser state was: ', parserState)
    if (objStack):
      print('Current object was: ', objStack[-1])
    else:
      print('Object stack was empty')

    raise

  return result

def getLoadingMaps(packageGuid, fileVersion):
  """
  returns (mapping, loadMaps, needCompatibility) tuple.
  Allows for backwards compatibility
  """
  
  from ccpnmodel.ccpncore.memops.Version import currentModelVersion
  newVersionStr = str(currentModelVersion)
  from ccpnmodel.ccpncore.xml.memops.Implementation import getGlobalMap
   
  globalMapping = getGlobalMap(fileVersion)
  
  # handle compatibility considerations
  if fileVersion == newVersionStr:
    needCompatibility = False
  else:
    needCompatibility = True
  
  # select mapping for package
  mapping = None
  for dd in globalMapping.values():
    if (packageGuid == dd.get('guid')):
      mapping = dd
      break

  if (mapping is None):
    raise ApiError("""No package mapping with guid found"""
     + ": %s" % (packageGuid,)
    )

  ll = list()
  ll.append(mapping)
  ll.append(globalMapping['loadMaps'])
  ll.append(needCompatibility)

  return ll

def linkChildData(delayDataDict, topObj, mapping, linkTopToParent=False, doOutOfPackage=False):
  """
  set parent-child links.
  delayDataDict is an obj/id:{childRoleName:listOfChildren}} dictionary
  (it also contains other information used elsewhere for compatibility)
  topObj is the TopObject
  mapping is the package mapping
  linkTopToParent determines if the root-to-topObject link must be set
  doOutOfPackage determines if out-of-package children must be linked -
  This is only relevant for the Implementation package, where first
  intrapackge and later out-of-package children are set.
  """
  # set up
  dataTypeMap = mapping['abstractTypes']
  topObjMap = dataTypeMap[topObj.__class__.__name__]

  # prime the stacks
  # IF BLOCK 301
  if (linkTopToParent):
    parentStack = [topObj.getParent()]
    ll = list()
    ll.append(topObj)
    childStack = [ll]

  else:
    parentStack = [topObj]
    ll = list()
    childStack = [ll]
    cl = topObjMap['children']
    dt = delayDataDict[topObj]
    for tag in cl:
      xx = dt.get(tag)
      if (xx is not None):
        ll.extend(xx)

  # IF BLOCK 302
  if (doOutOfPackage):
    # special case for TopObjects in Implementation

    # IF BLOCK 303
    if (isinstance(topObj, ccpnmodel.ccpncore.api.memops.Implementation.MemopsRoot)):

      dd = delayDataDict[topObj]
      content = topObjMap['content']
      cl = topObjMap['children']
      for tag in cl:
        val = dd.get(tag)
        # IF BLOCK 304
        if (val is not None):

          linkMap = content[tag]
          # IF BLOCK 305
          if ('child' == linkMap['type']):
            # child link

            linkContent = linkMap['content']
            for obj in val:
              obj2 = obj
              curMap = linkContent[obj2.__class__.__name__]
              # IF BLOCK 306
              if (curMap.get('isTop') is not None):
                # TopObject. Do the link to parent

                # get key
                tag2 = curMap.get('objkey')
                if (tag2 is None):
                  key = obj2.getLocalKey()
                else:
                  key = obj2.__dict__[tag2]

                parDict = topObj.__dict__[curMap['fromParent']]

                # add child link to parent dict
                if (key in parDict):
                  raise ApiError("""Cannot add child - key already in use"""
                   + ": %s:%s:%s" % (obj2.getQualifiedName(), obj2.getParent(), key)
                  )
                else:
                  parDict[key] = obj2
                  # NB these are shell TopObjects read in Implementation package
                  obj2.__dict__['isReading'] = False

    else:
      raise ApiError("""linkChildData: called with doOutOfPackage for non-root"""
       + ": %s" % (topObj,)
      )

  else:
    # Normal case. Add children to parent dictionary

    while childStack:

      kids = childStack[-1]
      # IF BLOCK 307
      if (kids):
        obj = kids.pop()
        curMap = dataTypeMap[obj.__class__.__name__]
        parentObj = parentStack[-1]
        fromParent = curMap['fromParent']
        # IF BLOCK 308
        if (curMap.get('singleKid') is not None):
          # only child
          sibling = parentObj.__dict__.get(fromParent)

          if (sibling is None):
            parentObj.__dict__[fromParent] = obj
          else:
            raise ApiError("""Attempt to override single child"""
             + ": %s" % (sibling,)
            )

        else:
          parDict = parentObj.__dict__[fromParent]

          # get key
          tag = curMap.get('objkey')
          if (tag is None):
            key = obj.getLocalKey()
          else:
            key = obj.__dict__[tag]

          # add child link to parent dict
          if (key in parDict):
            raise ApiError("""Cannot add child - key already in use"""
             + ": %s:%s:%s" % (obj.getQualifiedName(), obj.getParent(), key)
            )
          else:
            parDict[key] = obj

        parentStack.append(obj)
        ll = list()
        childStack.append(ll)
        dd = delayDataDict.get(obj)
        # IF BLOCK 309
        if (dd is not None):
          mm = curMap.get('children')
          # IF BLOCK 310
          if (mm is not None):
            for tag2 in mm:
              xx = dd.get(tag2)
              if (xx is not None):
                ll.extend(xx)

      else:
        # no children left - go up a step
        childStack.pop()
        parentStack.pop()

def delayedLoadLinksStd(objectDict, linkData):
  """
  Load single or multiple, crosslinks
  derefencing as you go using objectDict.
  """
  obj = None
  val = None
  name = None

  try:
    while linkData:
      # setup
      curMap = linkData.pop()
      val = linkData.pop()
      obj = linkData.pop()

      name = curMap.get('name')
      hicard = curMap.get('hicard')
      valueList = list()

      # map values
      for vv in val:
        try:
          oo = objectDict[vv]
          valueList.append(oo)
        except:
          raise ApiError("""Linked-to object with ID not found"""
           + ": %s:%s:%s" % (obj, name, vv)
          )

      # set element
      if (hicard == 1):
        ov = valueList[0]
      elif (hicard > 1):
        ov = valueList[:hicard]
      else:
        ov = valueList

      setattr(obj, name, ov)

  except:
    print('Error during Std link dereferencing. Object was: ', obj)
    print('values were: ', val)
    print('tag name was: ', name)
    raise

def delayedLoadLinksExo(objectDict, linkData):
  """
  Load single or multiple, exo-to-TopObjectlinks
  derefencing as you go using objectDict.
  """
  obj = None
  val = None
  name = None

  try:
    while linkData:
      # setup
      curMap = linkData.pop()
      val = linkData.pop()
      obj = linkData.pop()

      name = curMap.get('name')
      hicard = curMap.get('hicard')
      valueList = list()

      # map values
      for vv in val:
        oo = objectDict.get(vv)
        if (oo is None):
          root = obj.getRoot()
          packageName = curMap['content']['.qName']
          root.refreshTopObjects(packageName)
          try:
            oo = objectDict[vv]
          except:
            raise ApiError("""Linked-to object with ID not found"""
             + ": %s:%s:%s" % (obj, name, vv)
            )

        valueList.append(oo)

      # set element
      if (hicard == 1):
        ov = valueList[0]
      elif (hicard > 1):
        ov = valueList[:hicard]
      else:
        ov = valueList

      setattr(obj, name, ov)

  except:
    print('Error during Exo link dereferencing. Object was: ', obj)
    print('values were: ', val)
    print('tag name was: ', name)
    raise
